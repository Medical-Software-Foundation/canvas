----- BEGIN PAGE https://docs.canvasmedical.com/sdk/
# The Canvas SDK
Last updated: 17 Jan 2025
##  Get started #
Here are some step-by-step guides to get you started:
[ Your First PluginThis guide steps you through installing the Canvas SDK,
creating a plugin, and deploying it to a Canvas instance. ](/guides/your-
first-plugin) [ Creating WebhooksMake automatic API requests based on Canvas
events ](/guides/creating-webhooks-with-the-canvas-sdk) [ Customize Search
ResultsAdd your own logic to surface the right options with the appropriate
context ](/guides/customize-search-results)
And here are some other [guides](/guides)
##  What is the Canvas SDK? #
The Canvas SDK is your toolkit for customizing workflows natively across the
full Canvas platform: scheduling, charting, billing, and more. It is a [python
package](https://pypi.org/project/canvas/) used to develop and deploy plugins,
which then run in this [open source runtime
environment](https://github.com/canvas-medical/canvas-plugins) on your Canvas
instance.
Plugins, the custom packages you author with the Canvas SDK, run in a
sandboxed process directly on the Canvas instance. The Canvas application
emits many [events](/sdk/events) at runtime, which you can choose to respond
to and produce some number of [effects](/sdk/effects). These effects are then
interpreted by the Canvas application, which applies the changes your plugin
returned. Events are accompanied by contextual information, and your plugin
has access to additional information through the [data module](/sdk/data),
which exposes a subset of the Canvas application database through a series of
[Django ORM
classes](https://docs.djangoproject.com/en/5.1/ref/models/querysets/) backed
by read-only views.
##  Where can I get additional help? #
Our [open-source GitHub repo](https://github.com/canvas-medical/canvas-
plugins) has a [discussions](https://github.com/canvas-medical/canvas-
plugins/discussions) section, where you can request help or suggest
improvements. We also welcome [issue reports](https://github.com/canvas-
medical/canvas-plugins/issues) and [pull requests](https://github.com/canvas-
medical/canvas-plugins/pulls)!
Ready? Get started!
----- END PAGE https://docs.canvasmedical.com/sdk/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/caching/
# Caching API
Last updated: 24 Sep 2025
The Canvas SDK provides a caching API for plugin developers to store and
retrieve temporary data efficiently.
* * *
##  Getting the Cache Client #
To use the cache in your plugin, simply import and call:
    from canvas_sdk.caching.plugins import get_cache
    cache = get_cache()
* * *
##  TTL and Expiration #
  * By default, all cached keys expire after **14 days**.
  * You can set a shorter TTL when writing to the cache via the `timeout_seconds` parameter.
  * If a longer TTL is provided, a `CachingException` will be raised.
* * *
##  Supported Methods #
###  `get(key: str, default: Any | None = None) -> Any` #
Retrieve a value from the cache:
    user = cache.get("key")
You can specify a fallback if the key doesnât exist:
    user = cache.get("key", default="default_value")
* * *
###  `set(key: str, value: Any, timeout_seconds: int | None = None) -> None` #
Store a value in the cache:
    cache.set("key", {"name": "Alice"}, timeout_seconds=600)
* * *
###  `get_or_set(key: str, default: Any | Callable, timeout_seconds: int | None = None) -> Any` #
Fetch a value or set it if not present:
    value = cache.get_or_set("key", default=lambda: compute_value(), timeout_seconds=300)
* * *
###  `set_many(data: dict[str, Any], timeout_seconds: int | None = None) -> list[str]` #
Set multiple values at once:
    cache.set_many({
        "key1": {"name": "Alice"},
        "key2": {"name": "Bob"}
    }, timeout_seconds=900)
* * *
###  `get_many(keys: Iterable[str]) -> dict[str, Any]` #
Fetch multiple values in one operation:
    users = cache.get_many(["key1", "key2"])
* * *
###  `delete(key: str) -> None` #
Remove a key from the cache:
    cache.delete("key")
* * *
###  `__contains__(key: str) -> bool` #
Check if a key exists in cache:
    if "key" in cache:
        ...
----- END PAGE https://docs.canvasmedical.com/sdk/caching/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/canvas_cli/
# Canvas CLI
Last updated: 29 Aug 2025
##  Getting Started #
###  Installation using `pip` #
To install the Canvas CLI using `pip`, execute `pip install canvas`. Python
3.11, 3.12, or 3.13 is required.
To upgrade the Canvas CLI if you installed using `pip`, execute `pip install
--upgrade canvas`.
###  Installation using `uv` #
To install the Canvas CLI using `uv`, execute `uv tool install canvas`. `uv`
will find or procure an acceptable Python version.
To upgrade the Canvas CLI if you installed using `uv`, execute `uv tool
upgrade canvas`.
###  Configuration and Authenticating to Your Canvas Instance #
Create a file `~/.canvas/credentials.ini` with sections for each of your
Canvas instance subdomains, and add client_id and client_secret credentials to
each section. For example, if your Canvas instance url is `https://buttered-
popcorn.canvasmedical.com/`, you would have a section `[buttered-popcorn]`
with key-value pairs for `client_id` and `client_secret`.
**Getting Credentials:** Learn how to get register a client_id and
client_secret [here](/api/customer-authentication/#registering-a-third-party-
application-on-canvas).  
The Canvas CLI uses OAuth, just like the FHIR API.
**Example:**
    [buttered-popcorn]
    client_id=butter
    client_secret=salt
    [dev-buttered-popcorn]
    client_id=devbutter
    client_secret=devsalt
    is_default=true
    [localhost]
    client_id=localclientid
    client_secret=localclientsecret
You can define your default host with `is_default=true`. If no default is
explicitly defined, the Canvas CLI will use the first instance in the file as
the default for each of the CLI commands.
**You are now ready to use the Canvas CLI**
##  Usage #
    $ canvas [OPTIONS] COMMAND [ARGS]...
**Options** :
  * `--version`
  * `--help`: Show this message and exit.
##  Commands #
  * `init`: Create a new plugin
  * `install`: Install a plugin into a Canvas instance
  * `uninstall`: Uninstall a plugin from a Canvas instance
  * `enable`: Enable a plugin from a Canvas instance
  * `disable`: Disable a plugin from a Canvas instance
  * `list`: List all plugins from a Canvas instance
  * `validate-manifest`: Validate the Canvas Manifest json file
  * `logs`: Listen and print log streams from a Canvas instance
  * `config list`: List all secrets from a plugin
  * `config set`: Configure plugin secrets
###  `canvas init` #
Create a new plugin.
**Usage** :
    $ canvas init [OPTIONS]
**Options** :
  * `--help`: Show this message and exit.
###  `canvas install` #
Install a plugin into a Canvas instance.
**Usage** :
    $ canvas install [OPTIONS] PLUGIN_NAME
**Arguments** :
  * `PLUGIN_NAME`: Path to plugin to install [required]
**Options** :
  * `--secret TEXT`: Secrets to set, e.g. Key=value
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
**Notes** :
Files can be excluded from the packaged plugin using a `.canvasignore` in the
current working directory. The file behaves similarly to
[.gitignore](https://git-scm.com/docs/gitignore)
Example
    # Exclude test files
    test_*.py
###  `canvas uninstall` #
Uninstall a plugin from a Canvas instance.
**Usage** :
    $ canvas uninstall [OPTIONS] NAME
**Arguments** :
  * `NAME`: Plugin name to delete [required]
**Options** :
  * `--force`: Force uninstallation of the plugin
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas enable` #
Enable a plugin from a Canvas instance..
**Usage** :
    $ canvas enable [OPTIONS] NAME
**Arguments** :
  * `NAME`: Plugin name to enable [required]
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas disable` #
Disable a plugin from a Canvas instance..
**Usage** :
    $ canvas disable [OPTIONS] NAME
**Arguments** :
  * `NAME`: Plugin name to disable [required]
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas list` #
List all plugins on a Canvas instance.
**Usage** :
    $ canvas list [OPTIONS]
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas validate-manifest` #
Validate the Canvas Manifest json file.
**Usage** :
    $ canvas validate-manifest [OPTIONS] PLUGIN_NAME
**Arguments** :
  * `PLUGIN_NAME`: Path to plugin to validate [required]
**Options** :
  * `--help`: Show this message and exit.
###  `canvas logs` #
Subscribes to a log stream and prints to your console.
**Usage** :
    $ canvas logs [OPTIONS]
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas config list` #
List all secrets from a plugin.
**Usage** :
    $ canvas config list [OPTIONS] PLUGIN
**Arguments** :
  * `PLUGIN`: Plugin name to list secrets for
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
###  `canvas config set` #
Configure plugin secrets.
**Usage** :
    $ canvas config set [OPTIONS] PLUGIN
**Arguments** :
  * `PLUGIN`: Plugin name to list secrets for
  * `SECRETS...`: Secrets to set, e.g. Key=value
**Options** :
  * `--host TEXT`: Canvas instance to connect to
  * `--help`: Show this message and exit.
----- END PAGE https://docs.canvasmedical.com/sdk/canvas_cli/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/commands/
# Commands
Last updated: 11 Nov 2025
The commands module lets you create and update commands within a specific note
in Canvas. Commands are the building blocks of many end-user workflows in
Canvas, including nearly all clinical workflows for documentation, like HPIs
and questionnaires, as well as orders like prescriptions, labs, and referrals.
Each Command class can be instantiated in your plugin and used to build a new
command instance within a specific note or update an existing instance. The
commands are then displayed in real time within the end userâs workflow.
Common objectives that can be met by using Command classes include dynamic
note templates, clinical decision support, order set composition, care gap
closure, and care coordination automation.
##  Common Attributes #
###  Parameters #
All commands share the following init kwarg parameters:
Name| Type| Required| Description  
---|---|---|---  
`note_uuid`|  _string_| `true` if creating a new command| The externally
exposable id of the note in which to insert the command.  
`command_uuid`|  _string_| `true` if updating an existing command| The
externally exposable id of the command which is being referenced.  
All parameters can be set upon initialization, and also updated on the class
instance.
###  Methods #
All commands have the following methods:
####  originate #
Returns an Effect that originates a new command in the note body.
**See also:** For efficiently inserting multiple commands at once, see [Batch
Originate Commands](/sdk/effect-batch-originate/).
####  edit #
Returns an Effect that edits an existing command with the values set on the
command class instance.
**Behavior and Considerations:**
  * **Partial Edits:** If you update only some fields of the command, any fields not explicitly modified will retain their existing values.
  * **No Changes:** Calling `edit()` without making any changes will result in a no-op; the command remains unchanged.
  * **Invalid Values:** If you attempt to set an invalid value, you should receive a validation error.
####  delete #
Returns an Effect that deletes an existing, non-committed command from the
note body.
####  commit #
Returns an Effect that commits an existing, non-committed command to the note
body.
####  review #
Returns an Effect that sets a command in review.
**Limited availability** The `review()` method can only be called on Prescribe
commands objects. Other command types do not support this operation.
####  send #
Returns an Effect that sends a signed command.
**Limited availability** The `send()` method can only be called on LabOrder
and Prescribe command objects. Other command types do not support this
operation.
####  enter_in_error #
Returns an effect that enter-in-errors an existing, committed command in the
note body.
**Example** :
    from canvas_sdk.commands import PlanCommand
    def compute():
        existing_plan = PlanCommand(command_uuid='63hdik', narrative='something new')
        new_plan = PlanCommand(note_uuid='rk786p', narrative='new')
        new_plan.narrative = 'newer'
        return [existing_plan.edit(), new_plan.originate()]
##  Command Constants #
The `canvas_sdk.commands.constants` module provides essential classes and
enumerations used across various Canvas SDK command implementations. These
constants ensure consistency and provide structured data types for common
medical and administrative elements.
###  ClinicalQuantity #
`ClinicalQuantity` represents detailed information about the form or unit of
medication, particularly for prescription-related commands.
Field Name| Type| Description  
---|---|---  
`representative_ndc`|  _string_|  National Drug Code (NDC) representing the
medication.  
`ncpdp_quantity_qualifier_code`|  _string_|  NCPDP code indicating the
quantity qualifier.  
**Usage Example** :
    from canvas_sdk.commands import PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    # Using ClinicalQuantity in a prescription
    clinical_quantity = ClinicalQuantity(
        representative_ndc="12843016128",
        ncpdp_quantity_qualifier_code="C48542"
    )
    prescribe = PrescribeCommand(
        note_uuid="rk786p",
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=clinical_quantity,
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED
    )
###  ServiceProvider #
`ServiceProvider` represents detailed information about healthcare service
providers, used in referral and imaging order commands.
Field Name| Type| Description  
---|---|---  
`first_name`|  _string_|  Service providerâs first name (max length 512)  
`last_name`|  _string_|  Service providerâs last name (max length 512)  
`specialty`|  _string_|  Providerâs specialty (max length 512)  
`practice_name`|  _string_|  Name of the practice (max length 512)  
`business_fax`|  _Optional[string]_|  Business fax number (optional, max
length 512)  
`business_phone`|  _Optional[string]_|  Business phone number (optional, max
length 512)  
`business_address`|  _Optional[string]_|  Business address (optional, max
length 512)  
`notes`|  _Optional[string]_|  Additional notes (optional, max length 512)  
**Usage Example** :
    from canvas_sdk.commands import ReferCommand
    from canvas_sdk.commands.constants import ServiceProvider
    # Creating a referral with service provider information
    service_provider = ServiceProvider(
        first_name="John",
        last_name="Smith",
        specialty="Cardiology",
        practice_name="Heart Health Center",
        business_phone="555-0123",
        business_address="123 Medical Plaza, Suite 100"
    )
    refer = ReferCommand(
        note_uuid="rk786p",
        diagnosis_codes=["E119"],
        priority=ReferCommand.Priority.ROUTINE,
        clinical_question=ReferCommand.ClinicalQuestion.DIAGNOSTIC_UNCERTAINTY,
        notes_to_specialist="Patient needs cardiac evaluation",
        service_provider=service_provider
    )
###  CodeSystems #
`CodeSystems` provides standardized medical coding system identifiers used
throughout Canvas for consistent medical code classification.
**Available Code Systems** :
Code System| Description  
---|---  
`ICD10`| International Classification of Diseases, 10th Revision  
`SNOMED`| Systematized Nomenclature of Medicine Clinical Terms  
`RXNORM`| RxNorm - standardized nomenclature for medications  
`UNSTRUCTURED`| Canvas-specific system for unstructured or custom codes  
**Usage Example** :
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using different code systems
    icd10_coding = Coding(
        system=CodeSystems.ICD10,
        code="E11.9",
        display="Type 2 diabetes mellitus without complications"
    )
    snomed_coding = Coding(
        system=CodeSystems.SNOMED,
        code="65921008",
        display="Drink plenty of fluids"
    )
    unstructured_coding = Coding(
        system=CodeSystems.UNSTRUCTURED,
        code="Custom instruction text"
    )
###  Coding #
`Coding` represents a coded value from a medical terminology system, providing
structured representation of medical concepts.
Field Name| Type| Description  
---|---|---  
`system`|  _string_|  The coding system identifier (e.g., ICD-10, SNOMED)  
`code`|  _string_|  The specific code within the system  
`display`|  _Optional[string]_|  Human-readable description of the code  
**Usage Example** :
    from canvas_sdk.commands import InstructCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using structured coding with SNOMED
    instruct_snomed = InstructCommand(
        note_uuid="rk786p",
        coding=Coding(
            system=CodeSystems.SNOMED,
            code="65921008",
            display="Drink plenty of fluids"
        ),
        comment="To address mild dehydration symptoms"
    )
    # Using unstructured coding for custom instructions
    instruct_custom = InstructCommand(
        note_uuid="rk786p",
        coding=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Physical medicine neuromuscular training"
        )
    )
##  Command Actions #
All commands support user-triggered actions through the Canvas UI. These
actions appear as buttons or menu items that users can click to perform
specific operations on commands.
Commands have two types of actions:
  * **Generic actions** (available on all commands): print, audit history
  * **Command-specific actions** (vary by command type): documented in each commandâs respective section below
###  Customizing Action Availability #
Developers can programmatically control command actions by:
  * **Hiding actions** based on user permissions, roles, or command state
  * **Reordering actions** to prioritize commonly used operations
  * **Conditional display** depending on workflow requirements or business logic
Action customization is handled through plugin code that modifies the
available action set accordingly.
###  Generic Actions #
The following actions are available on all command types:
####  print #
Generates a printable version of the command for documentation or external
sharing purposes.
####  audit_history #
Displays the complete audit trail for the command, showing all modifications,
state changes, and user interactions over time.
####  carry_forward #
Populates the command with the last known data for this command type and
patient, allowing users to quickly recreate similar commands based on previous
entries.
###  Command-Specific Actions #
Individual command types have additional actions tailored to their
functionality. These actions are documented in each commandâs respective
section below.
The send action is the only command action available through the SDK and is
limited to LabOrder and Prescribe commands only.
###  Example #
    import json
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.v1.data import Staff
    class Handler(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__AVAILABLE_ACTIONS)
        def compute(self) -> list[Effect]:
            actions = self.context["actions"]
            user_id = self.context["user"]["staff"]
            # Filter actions based on user permissions
            try:
                staff = Staff.objects.get(id=user_id)
                # Example: Hide print action for specific user
                if staff.first_name == "Larry":
                    filtered_actions = [
                        action for action in actions
                        if action["name"] != "print"
                    ]
                else:
                    filtered_actions = actions
            except Staff.DoesNotExist:
                # If staff not found, return original actions
                filtered_actions = actions
            return [Effect(
                type=EffectType.COMMAND_AVAILABLE_ACTIONS_RESULTS,
                payload=json.dumps(filtered_actions)
            )]
##  Chaining Methods with a User-set UUID #
A common use case is to originate and also commit a command in a single plugin
action. However, attempting to commit a command without a `command_uuid` will
throw an error. Because the `originate` method executes asynchronously, there
is not currently a clean way to get the `command_uuid` back from the originate
action and use it for the commit action in the same operation.
The solution is to set the UUID in the plugin â using a valid Version 4 UUID
â and pass it through to both the originate and commit actions. This is
accomplished by manually setting the `command_uuid` before calling the
methods:
    from uuid import uuid4
    from canvas_sdk.commands import DiagnoseCommand
    def compute():
        note_uuid = '550e8400-e29b-41d4-a716-446655440000'
        diagnose_command = DiagnoseCommand(
            note_uuid=note_uuid,
            icd10_code='E11.9'
        )
        # To chain command effects, you must know what the command's id
        # is. To accomplish that, we set the id ourselves rather than
        # allow the database to assign one.
        diagnose_command.command_uuid = str(uuid4())
        # Now we can both originate and commit in a single operation
        return [diagnose_command.originate(), diagnose_command.commit()]
This pattern ensures that both the originate and commit operations use the
same `command_uuid`, allowing them to be chained together reliably in a single
plugin execution.
Command-specific details for each command class can be found below.
##  AdjustPrescription #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`new_fdb_code`|  _string_| `true`| The [FDB code](/sdk/utils/#fdb_code) of the
new medication.  
Check the Prescribe command for the other parameters used in the Adjust
Prescription command.
    from canvas_sdk.commands import AdjustPrescriptionCommand, PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    AdjustPrescriptionCommand(
        fdb_code="172480",
        new_fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id="provider_456",
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
* * *
##  Allergy #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`allergy`|  _Allergen_| `false`| Represents the allergen. See details in the
Allergen type below.  
`severity`|  _Severity enum_| `false`| The severity of the allergic reaction.
Must be one of `AllergyCommand.Severity`.  
`narrative`|  _string_| `false`| A narrative or free-text description of the
allergy.  
`approximate_date`|  _datetime_| `false`| The approximate date the allergy was
identified.  
**Enums and Types** :
**`Allergen`**
Attribute| Type| Description  
---|---|---  
`concept_id`|  _integer_|  The identifier for the allergen concept.  
`concept_type`|  _AllergenType enum_|  The type of allergen. See
`AllergenType` values below.  
AllergenType| Description  
---|---  
`ALLERGEN_GROUP`| Represents a group of allergens.  
`MEDICATION`| Represents a medication allergen.  
`INGREDIENT`| Represents an ingredient allergen.  
Severity| Description  
---|---  
`MILD`| Indicates a mild reaction.  
`MODERATE`| Indicates a moderate reaction.  
`SEVERE`| Indicates a severe reaction.  
**Example** :
    from canvas_sdk.commands.commands.allergy import AllergyCommand, AllergenType, Allergen
    from datetime import date
    allergy = AllergyCommand(
        note_uuid="rk786p",
        allergy=Allergen(concept_id=12345, concept_type=AllergenType.MEDICATION),
        severity=AllergyCommand.Severity.SEVERE,
        narrative="Severe rash and difficulty breathing after penicillin.",
        approximate_date=date(2023, 6, 15)
    )
* * *
##  Assess #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`condition_id`|  _string_| `true`| The externally exposable id of the
condition being assessed.  
`background`|  _string_| `false`| Background information about the diagnosis.  
`status`|  _Status enum_| `false`| The current status of the diagnosis. Must
be one of `AssessCommand.Status`  
`narrative`|  _string_| `false`| The narrative for the current assessment.  
`Status`| Value  
---|---  
IMPROVED| âimprovedâ  
STABLE| âstableâ  
DETERIORATED| âdeterioratedâ  
**Example** :
    from canvas_sdk.commands import AssessCommand
    assess = AssessCommand(
        note_uuid='rk786p',
        condition_id='hu38rlo',
        background='started in 2012',
        status=AssessCommand.Status.STABLE,
        narrative='experiencing more pain lately'
    )
* * *
##  ChangeMedication #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`medication_id`|  _string_| `true`| Externally exposable id of the patientâs
medication being changed.  
`sig`|  _string_| `false`| Administration details of the medication.  
**Example** :
    from canvas_sdk.commands.commands.change_medication import ChangeMedicationCommand
    change_medication = ChangeMedicationCommand(
        note_uuid='rk786p',
        medication_id='2u309j',
        sig='two pills taken orally'
    )
* * *
##  CloseGoal #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`goal_id`|  _int_| `true`| The externally exposable ID of the goal being
closed.  
`achievement_status`|  _AchievementStatus enum_| `false`| The final
achievement status of the goal. Must be one of
`GoalCommand.AchievementStatus`.  
`progress`|  _string_| `false`| A narrative about the patientâs progress
toward the goal.  
**Example** :
    from canvas_sdk.commands import CloseGoalCommand, GoalCommand
    close_goal = CloseGoalCommand(
        note_uuid="rk786p",
        goal_id=12345,
        achievement_status=GoalCommand.AchievementStatus.ACHIEVED,
        progress="Patient has achieved the target weight goal of 150 lbs."
    )
* * *
##  Diagnose #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`icd10_code`|  _string_| `true`| ICD-10 code of the condition being diagnosed.  
`background`|  _string_| `false`| Background information about the diagnosis.  
`approximate_date_of_onset`|  _datetime_| `false`| The approximate date the
condition began.  
`today_assessment`|  _string_| `false`| The narrative for the initial
assessment of the condition.  
**Example** :
    from canvas_sdk.commands import DiagnoseCommand
    from datetime import datetime
    diagnose = DiagnoseCommand(
        note_uuid='rk786p',
        icd10_code='M54.50',
        background='lifted heavy box',
        approximate_date_of_onset=datetime(2012, 1, 1),
        today_assessment='unable to sleep lately'
    )
* * *
##  FamilyHistory #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`family_history`|  _string_ or _Coding_| `true`| A description of the family
history being documented.  
`relative`|  _string_| `false`| A description of the relative (e.g., mother,
uncle).  
`note`|  _string_| `false`| Additional notes or context about the family
history.  
**Coding Support** :
The `family_history` parameter accepts either:
  * **String** : Searches for matching family history condition
  * **Coding object** : Allows structured or unstructured coding
    * Supported systems: `SNOMED`, `UNSTRUCTURED`
    * Required fields: `system`, `code`
    * Optional field: `display`
**Example** :
    from canvas_sdk.commands import FamilyHistoryCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using a string (searches for matching conditions)
    family_history = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history="Diabetes Type 2",
        relative="Mother",
        note="Diagnosed at age 45"
    )
    # Using a SNOMED code
    family_history_snomed = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history=Coding(
            system=CodeSystems.SNOMED,
            code="44054006",
            display="Diabetes Type 2"
        ),
        relative="Mother",
        note="Diagnosed at age 45"
    )
    # Using unstructured (free text)
    family_history_unstructured = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Family history of heart disease"
        ),
        relative="Father"
    )
* * *
##  FollowUp #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`structured`|  _boolean_| `false`| Whether the RFV is structured or not.
Defaults to False.  
`requested_date`|  _date_| `false`| The desired follow up date.  
`note_type_id`|  _UUID (str)_| `false`| The desired type of appointment.  
`coding`|  _Coding_ or _UUID (str)_| `true` if structured=True| The coding for
the structured RFV. Either a full Coding object (with `code`, `system`,
`display`) or a UUID string referencing a verified coding record. If a Coding
is provided, it is validated against existing records  
`comment`|  _string_| `false`| Additional commentary on the RFV.  
**Example** :
    from canvas_sdk.commands import FollowUpCommand
    from datetime import date
    structured = FollowUpCommand(
      note_uuid='rk786p',
      structured=True,
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      coding={'code': '', 'system': '', 'display': ''},
      comment='also wants to discuss treatment options'
    )
    # Example with a UUID string referencing a Coding record
    structured2 = FollowUpCommand(
      note_uuid='rk786p',
      structured=True,
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      coding="e2b1e1e3-3f52-4a0a-bb3a-123456789abc",  # Must correspond to an existing coding record
      comment="Discuss treatment options"
    )
    unstructured = FollowUpCommand(
      note_uuid='rk786p',
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      comment='also wants to discuss treatment options'
    )
* * *
##  Goal #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`goal_statement`|  _string_| `true`| Description of the goal.  
`start_date`|  _datetime_| `false`| The date the goal begins.  
`due_date`|  _datetime_| `false`| The date the goal is due.  
`achievement_status`|  _AchievementStatus enum_| `false`| The current
achievement status of the goal.  
`priority`|  _Priority enum_| `false`| The priority of the goal.  
`progress`|  _string_| `false`| A narrative about the patientâs progress
toward the goal.  
`AchievementStatus`| Value  
---|---  
IN_PROGRESS| âin-progressâ  
IMPROVING| âimprovingâ  
WORSENING| âworseningâ  
NO_CHANGE| âno-changeâ  
ACHIEVED| âachievedâ  
SUSTAINING| âsustainingâ  
NOT_ACHIEVED| ânot-achievedâ  
NO_PROGRESS| âno-progressâ  
NOT_ATTAINABLE| ânot-attainableâ  
`Priority`| Value  
---|---  
HIGH| âhigh-priorityâ  
MEDIUM| âmedium-priorityâ  
LOW| âlow-priorityâ  
**Example** :
    from canvas_sdk.commands import GoalCommand
    from datetime import datetime
    goal = GoalCommand(
        note_uuid='rk786p',
        goal_statement='Eat more healthy vegetables.',
        start_date=datetime(2024, 1, 1),
        due_date=datetime(2024, 12, 31),
        achievement_status=GoalCommand.AchievementStatus.IN_PROGRESS,
        priority=GoalCommand.Priority.HIGH,
        progress='patient is frequenting local farmers market to find healthy options'
    )
* * *
##  HistoryOfPresentIllness #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`narrative`|  _string_| `true`| The narrative of the patientâs history of
present illness.  
**Example** :
    from canvas_sdk.commands import HistoryOfPresentIllnessCommand
    hpi = HistoryOfPresentIllnessCommand(
            note_uuid='rk786p',
            narrative='presents with chronic back pain and headaches'
        )
* * *
##  ImagingOrder #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`image_code`|  _string_| `true`| Code identifier of the imaging order.  
`diagnosis_codes`|  _list[string]_| `true`| ICD-10 Diagnosis codes justifying
the imaging order.  
`priority`|  _Priority enum_| `false`| Priority of the imaging order. Must be
one of `ImagingOrderCommand.Priority`.  
`additional_details`|  _string_| `false`| Additional details or instructions
related to the imaging order.  
`service_provider`|  _ServiceProvider_| `true`| Service provider of the
imaging order.  
`comment`|  _string_| `false`| Additional comments.  
`ordering_provider_key`|  _string_| `true`| The key for the provider ordering
the imaging.  
`linked_items_urns`|  _list[string]_| `false`| List of URNs for items linked
to the imaging order command.  
**Command-specific actions** :
Action Name| Available When| Description  
---|---|---  
`delegate_action`| command is staged| Delegates the order by creating a task.  
`sign_action`| command is staged| Signs the order, transitioning it from
staged to committed state.  
`print_specialist`| command is committed| Prints the order using a specialist-
focused template.  
`print_patient`| command is committed| Prints the order using a patient-
friendly template.  
`fax`| command is committed| Transmits the order electronically via fax.  
**Enums and Types** :
**`Priority`**
Priority| Description  
---|---  
`ROUTINE`| Indicates a routine order.  
`URGENT`| Indicates un urgent order.  
**Example** :
    from canvas_sdk.commands import ImagingOrderCommand
    from canvas_sdk.commands.constants import ServiceProvider
    imaging_order = ImagingOrderCommand(
        note_uuid="rk786p",
        image_code="G0204",
        diagnosis_codes=["E119"],
        priority=ImagingOrderCommand.Priority.ROUTINE,
        comment="this is a comment",
        additional_details="more details",
        ordering_provider_key="pk3920p",
        service_provider=ServiceProvider(
          first_name="Clinic",
          last_name="Imaging",
          practice_name="Clinic Imaging",
          specialty="radiology",
          business_address="Street Address",
          business_phone="1234569874",
          business_fax="1234569874"
     ),
    )
* * *
##  ImmunizationStatement #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`cpt_code`|  _string_ or _Coding_| `false`*| The CPT code for the immunization
procedure. Used with CVX code to search against ontologies server for
validation.  
`cvx_code`|  _string_ or _Coding_| `false`*| The CVX code for the vaccine
administered. Used with CPT code to search against ontologies server for
validation.  
`unstructured`|  _Coding_| `false`*| Free-text immunization description.  
`approximate_date`|  _date_| `false`| The approximate date when the
immunization was administered.  
`comments`|  _string_| `false`| Additional comments about the immunization
(max 255 characters).  
*Must provide either both `cpt_code` and `cvx_code` together, or `unstructured` alone (cannot mix structured and unstructured).
**Coding Support** :
The `cpt_code` and `cvx_code` parameters accept either:
  * **String** : Looks up the code in the respective system (CPT or CVX)
  * **Coding object** : Allows structured coding
    * `cpt_code` must use system: `CPT`
    * `cvx_code` must use system: `CVX`
    * Required fields: `system`, `code`
    * Optional field: `display`
The `unstructured` parameter:
  * **Coding object** : For free-text immunizations
    * Required system: `UNSTRUCTURED`
    * Required fields: `system`, `code`
    * Optional field: `display`
**Examples** :
    from canvas_sdk.commands.commands.immunization_statement import ImmunizationStatementCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    from datetime import date
    immunization_statement = ImmunizationStatementCommand(
        cpt_code="90724",
        cvx_code="88",
        approximate_date=date(2024, 1, 15),
        comments="Patient received influenza vaccine"
    )
    # Using Coding objects for structured codes
    immunization_statement_coded = ImmunizationStatementCommand(
        cpt_code=Coding(
            system=CodeSystems.CPT,
            code="90724"
        ),
        cvx_code=Coding(
            system=CodeSystems.CVX,
            code="88"
        ),
        approximate_date=date(2024, 1, 15),
        comments="Patient received influenza vaccine"
    )
    # Using unstructured (free text immunization)
    immunization_statement_unstructured = ImmunizationStatementCommand(
        unstructured=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="COVID-19 booster at pharmacy"
        ),
        approximate_date=date(2024, 1, 15)
    )
* * *
##  Instruct #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`coding`| **Coding**| `true`| The SNOMED code or UNSTRUCTURED code that
represents the instruction.  
`comment`|  _string_| `false`| Additional comments related to the instruction.  
**Example** :
    from canvas_sdk.commands import InstructCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # SNOMED code
    InstructCommand(
        note_uuid='rk786p',
        coding=Coding(system=CodeSystems.SNOMED, code="65921008"),
        comment="To address mild dehydration symptoms"
    )
    # UNSTRUCTURED code
    InstructCommand(
        note_uuid='rk786p',
        coding=Coding(system=CodeSystems.UNSTRUCTURED, code="Physical medicine neuromuscular training"),
    )
* * *
##  LabOrder #
The `LabOrderCommand` is used to initiate a lab order through the Canvas
system. This command requires detailed information about the lab partner, the
tests being ordered, and the provider placing the order. Built-in validations
ensure that:
  * The specified lab partner exists (whether provided by name or ID).
  * The ordered tests are available for the chosen lab partner.
**Electronic ordering:** LabOrder commands support the `send()` method for
electronic ordering of signed orders directly to lab partners. However,
electronic ordering has additional requirements:
  * Only lab partners with electronic ordering enabled support the `send()` method.
  * The command must be committed/signed before it can be sent electronically.
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`lab_partner`|  _string_| `true`| The lab partner processing the order.
Accepts either the lab partnerâs name or its unique identifier (ID).  
`tests_order_codes`|  _list[string]_| `true`| A list of codes or IDs for the
tests being ordered. The system verifies that each provided value corresponds
to an available test for the specified lab partner.  
`ordering_provider_key`|  _string_| `false`| The key for the provider ordering
the tests.  
`diagnosis_codes`|  _list[string]_| `false`| ICD-10 Diagnosis codes justifying
the lab order.  
`fasting_required`|  _boolean_| `false`| Indicates if fasting is required for
the tests.  
`comment`|  _string_| `false`| Additional comments related to the lab order.  
**Command-specific actions** :
Action Name| Available When| Description  
---|---|---  
`sign_send_action`| command is staged| Signs and immediately sends the order
electronically to the lab partner.  
`send_action`| command is staged| Sends the order electronically to the chosen
lab partner.  
`sign_action`| command is staged| Signs the order, transitioning it from
staged to committed state.  
`print_requisition_form`| command is committed| Prints the order using a
requisition-focused template for lab submission.  
`print_specimen_label`| command is committed| Prints the template using a
specimen-focused template.  
`fax_requisition_form`| command is committed| Transmits the order
electronically via fax.  
**ABN Workflow Actions**
When the ABN (Advance Beneficiary Notice) workflow is enabled, additional
actions become available:
Action Name| Available When| Description  
---|---|---  
`send_abn_signed`| command is staged| Sends the order electronically after ABN
requirements are met.  
`make_changes`| command is staged| Allows modifications to complete ABN
requirements before sending.  
###  Validations #
  * **Lab Partner Validation:** The system checks that the provided `lab_partner` (by name or ID) exists in the system. If no matching lab partner is found, a validation error is raised.
  * **Tests Order Codes Validation:** Each test code or ID in `tests_order_codes` is verified against the tests available for the specified lab partner. If one or more tests cannot be found, the error will indicate which codes or IDs are missing.
**Example** :
    from canvas_sdk.commands import LabOrderCommand
    from canvas_sdk.v1.data.lab import LabPartner, LabPartnerTest
    partner = LabPartner.objects.first()
    tests = [test.order_code for test in LabPartnerTest.objects.filter(lab_partner=partner)]
    LabOrderCommand(
      lab_partner=str(partner.id),
      tests_order_codes=tests,
      ordering_provider_key="provider_key_123",
      diagnosis_codes=["E119"],
      fasting_required=True,
      comment="Patient should fast for 8 hours before the test."
    )
* * *
##  MedicalHistory #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`past_medical_history`|  _string_| `true`| A description of the past medical
condition or history.  
`approximate_start_date`|  _date_| `false`| Approximate start date of the
condition.  
`approximate_end_date`|  _date_| `false`| Approximate end date of the
condition.  
`show_on_condition_list`|  _boolean_| `false`| Whether the condition should
appear on the condition list.  
`comments`|  _string_| `false`| Additional comments (max length: 1000
characters).  
**Example** :
    from canvas_sdk.commands import MedicalHistoryCommand
    from datetime import date
    MedicalHistoryCommand(
        past_medical_history="Resistant Hypertension",
        approximate_start_date=date(2015, 1, 1),
        show_on_condition_list=True,
        comments="Controlled with medication."
    )
* * *
##  MedicationStatement #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`fdb_code`|  _string_ or _Coding_| `true`| The [FDB
code](/sdk/utils/#fdb_code) of the medication  
`sig`|  _string_| `false`| Administration details of the medication.  
**Coding Support** :
The `fdb_code` parameter accepts either:
  * **String (FDB code)** : Looks up the medication in the FDB system
  * **Coding object** : Allows structured or unstructured coding
    * Supported systems: `FDB`, `UNSTRUCTURED`
    * Required fields: `system`, `code`
    * Optional field: `display`
**Example** :
    from canvas_sdk.commands import MedicationStatementCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using an FDB code string (recommended for FDB medications)
    medication_statement = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code='198698',
        sig='two pills taken orally'
    )
    # Using an FDB Coding object
    medication_statement_fdb = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code=Coding(
            system=CodeSystems.FDB,
            code='198698',
            display='aspirin 81 mg oral tablet'
        ),
        sig='two pills taken orally'
    )
    # Using unstructured (free text medication)
    medication_statement_unstructured = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code='Herbal supplement for joint health'
        )
    )
* * *
##  SurgicalHistory #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`past_surgical_history`|  _string_ or _Coding_| `true`| A description of the
past surgical procedure.  
`approximate_date`|  _date_| `false`| Approximate date of the surgery.  
`comment`|  _string_| `false`| Additional comments (max length: 1000
characters).  
**Coding Support** :
The `past_surgical_history` parameter accepts either:
  * **String** : Searches for matching surgical procedures
  * **Coding object** : Allows structured or unstructured coding
    * Supported systems: `SNOMED`, `UNSTRUCTURED`
    * Required fields: `system`, `code`
    * Optional field: `display`
**Example** :
    from canvas_sdk.commands import PastSurgicalHistoryCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    from datetime import date
    # Using a string (searches for matching procedures)
    PastSurgicalHistoryCommand(
        past_surgical_history="Appendectomy",
        approximate_date=date(2008, 6, 15),
        comment="No complications reported."
    )
    # Using a SNOMED code
    surgical_history_snomed = PastSurgicalHistoryCommand(
        past_surgical_history=Coding(
            system=CodeSystems.SNOMED,
            code="80146002",
            display="Appendectomy"
        ),
        approximate_date=date(2008, 6, 15),
        comment="No complications reported."
    )
    # Using unstructured (free text)
    surgical_history_unstructured = PastSurgicalHistoryCommand(
        past_surgical_history=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Minor outpatient procedure on left knee"
        ),
        approximate_date=date(2020, 3, 10)
    )
* * *
##  Perform #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`cpt_code`|  _string_ or _Coding_| `true`| The CPT code of the procedure or
action performed.  
`notes`|  _string_| `false`| Additional notes related to the performed
procedure.  
**Coding Support** :
The `cpt_code` parameter accepts either:
  * **String** : Searches for matching procedures
  * **Coding object** : Allows structured or unstructured coding
    * Supported systems: `CPT`, `UNSTRUCTURED`
    * Required fields: `system`, `code`
    * Optional field: `display`
**Example** :
    from canvas_sdk.commands import PerformCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using a string (searches for matching procedures)
    PerformCommand(
        cpt_code="99213",
        notes="Patient presented with a common cold."
    )
    # Using a CPT code
    perform_cpt = PerformCommand(
        cpt_code=Coding(
            system=CodeSystems.CPT,
            code="99213",
            display="Office visit, established patient"
        ),
        notes="Annual wellness visit"
    )
    # Using unstructured (free text)
    perform_unstructured = PerformCommand(
        cpt_code=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Custom procedure performed"
        ),
        notes="Non-standard procedure documentation"
    )
* * *
##  Plan #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`narrative`|  _string_| `true`| The narrative of the patientâs plan.  
**Example** :
    from canvas_sdk.commands import PlanCommand
    plan = PlanCommand(
        note_uuid='rk786p',
        narrative='will return in 2 weeks to check on pain management'
    )
* * *
##  Prescribe #
**Electronic prescribing:** Prescribe commands support the `send()` method for
electronic transmission of signed prescriptions. However, electronic
prescribing has additional validations:
  * A pharmacy must be specified on the command before it can be sent.
  * The command must be committed/signed before it can be sent electronically.
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`fdb_code`|  _string_| `false`*| The [FDB code](/sdk/utils/#fdb_code) of the
medication.  
`compound_medication_id`|  _string_| `false`*| The ID of an existing compound
medication to prescribe.  
`compound_medication_data`| `CompoundMedicationData`| `false`*| Data for
creating a new compound medication inline.  
`icd10_codes`|  _list[string]_| `false`| List of ICD-10 codes (maximum 2)
associated with the prescription.  
`sig`|  _string_| `true`| Administration instructions/details of the
medication.  
`days_supply`|  _integer_| `false`| Number of days the prescription is
intended to cover.  
`quantity_to_dispense`|  _Decimal | float | integer_| `true`| The amount of medication to dispense.  
`type_to_dispense`|  _ClinicalQuantity_| `true`**| Information about the form
or unit of the medication to dispense.  
`refills`|  _integer_| `true`| Number of refills allowed for the prescription.  
`substitutions`|  _Substitutions Enum_| `true`| Specifies whether
substitutions (e.g., generic drugs) are allowed.  
`pharmacy`|  _string_| `false`| The NCPDP ID of the pharmacy where the
prescription should be sent.  
`prescriber_id`|  _string_| `true`| The key of the prescriber.  
`supervising_provider_id`|  _string_| `false`| The key of the supervising
provider of the prescriber.  
`note_to_pharmacist`|  _string_| `false`| Additional notes or instructions for
the pharmacist.  
*Must provide exactly one of: fdb_code, compound_medication_id, or compound_medication_data
**ClinicalQuantity is only required when `fdb_code` is provided. It is
optional for compound medications.
**Command-specific actions** :
Action Name| Available When| Description  
---|---|---  
`sign_send_action`| command is in review| Signs and immediately sends the
prescription electronically.  
`sign_action`| command is in review| Signs the prescription, transitioning it
from staged to committed state.  
`print_action`| command is in review| Prints and commits the command.  
`make_changes`| command is in review| Allow users to revert the command to
staged state and make changes.  
`send_action`| command is committed| Sends the prescription electronically.  
**Enums and Types**
Substitutions| Value| Description  
---|---|---  
`ALLOWED`| `"allowed"`| Generic or substitute medications are permitted.  
`NOT_ALLOWED`| `"not_allowed"`| Only the prescribed brand is allowed.  
**CompoundMedicationData** : Data for creating a compound medication inline
within a prescription.
Field Name| Type| Description| Required  
---|---|---|---  
`formulation`|  _string_|  The compound medication formulation (max 105
characters)| `true`  
`potency_unit_code`|  _string_|  The unit of measurement for the medication|
`true`  
`controlled_substance`|  _string_|  The controlled substance schedule| `true`  
`controlled_substance_ndc`|  _string_|  NDC for controlled substances (dashes
removed)| `false`*  
`active`|  _bool_|  Whether the compound medication is active (default: true)|
`false`  
*Required when controlled_substance is not âNâ (None)
**Examples**
** _Option 1: Standard Prescription (FDB Code)_**
     from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands import PrescribeCommand
    prescription = PrescribeCommand(
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
**_Option 2: Existing Compound Medication (by ID)_**
     from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands import PrescribeCommand
    from canvas_sdk.v1.data.compound_medication import CompoundMedication as CompoundMedicationModel
    # Get an existing compound medication (let's assume it exists in the database)
    compound_med = CompoundMedicationModel.objects.filter(
        active=True,
        formulation="Testosterone 200mg/mL in Grapeseed Oil"
    ).first()
    prescription = PrescribeCommand(
        compound_medication_id=str(compound_med.id),
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
**_Option 3: Create New Compound Medication Inline_**
     from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands.commands.prescribe import PrescribeCommand, CompoundMedicationData
    from canvas_sdk.v1.data.compound_medication import CompoundMedication
    compound_medication_data = CompoundMedicationData(
        formulation="Testosterone 200mg/mL in Grapeseed Oil",
        potency_unit_code=CompoundMedication.PotencyUnits.GRAM,
        controlled_substance=CompoundMedication.ControlledSubstanceOptions.SCHEDULE_III,
        controlled_substance_ndc="12345678901",
        active=True,
    )
    prescription = PrescribeCommand(
        compound_medication_data=compound_medication_data,
        icd10_codes=["M79.3"],
        sig="Apply thin layer to affected area twice daily",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
**Validation Notes**
  * Medication Type Validation: Exactly one of fdb_code, compound_medication_id, or compound_medication_data must be provided
  * Compound Medication ID: When using compound_medication_id, the system validates that the compound medication exists
  * Compound Medication Data: When using compound_medication_data:
    * All required fields in the dataclass must be provided
    * If controlled substance is not âNâ (None), then controlled_substance_ndc is required
    * The formulation is limited to 105 characters
    * Any dashes in the NDC are automatically removed
    * Before creating a new compound medication, the system checks if a compound with the same formulation and potency unit code already exists. If it does, it reuses the existing compound medication instead of creating a new one.
  * Potency Unit and Controlled Substance Values: Must use valid enum values from PotencyUnit and ControlledSubstanceSchedule
* * *
##  PhysicalExam #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`questionnaire_id`|  _string_| `true`| The externally exposable id of the
questionnaire being answered by the patient.  
`result`|  _string_| `false`| A summary of the result of the patientâs
answers.  
###  Toggle Questions Feature #
The PhysicalExamCommand includes special functionality for toggling questions
on/off. When working with a PhysicalExam Command, the following methods are
available:
**Methods** :
Method| Parameters| Returns| Description  
---|---|---|---  
`is_question_enabled`| `question_id: str` or `int`| `bool`| Check if a
specific question is enabled (not skipped).  
`set_question_enabled`| `question_id: str` or `int, enabled: bool`| `None`|
Enable or disable a specific question.  
`question_toggles`|  _property_| `dict`| Get all current toggle states
(question_id â enabled).  
**Example - Working with Existing Commands** :
A common use case is retrieving existing PhysicalExam commands from a note and
modifying their toggle states. Hereâs how to work with the Canvas SDK data
objects:
    from canvas_sdk.commands import PhysicalExamCommand
    from canvas_sdk.v1.data import Command, Note
    from logger import log
    # Get existing physical exam commands from a note
    note = Note.objects.get(id="ff287601-fff4-46c4-b21f-04760e88adf1")
    physical_exam_commands = Command.objects.filter(
        note=note,
        schema_key="exam"  # Physical exam commands have schema_key "exam"
    ).all()
    effects = []
    for command in physical_exam_commands:
        # The command.data contains the question responses and skip states
        # Example structure of command.data:
        # {
        #     "questionnaire": {"value": "83d93454-25a9-404d-83a5-e0ed2ec3af00"},
        #     "question-12": "70",  # Body length response
        #     "question-13": None,   # Head circumference (no response)
        #     "skip-12": True,   # Body length is enabled (counterintuitive: skip=True means enabled)
        #     "skip-13": False,  # Head circumference is disabled
        # }
        # Create a PhysicalExamCommand instance from the existing command
        exam = PhysicalExamCommand(command_uuid=str(command.id))
        # The exam.questions property gives you access to all questions with their IDs
        log.info(f"Processing Physical Exam Command: {exam.command_uuid}")
        for question in exam.questions:
            # Each question object has an 'id' property with the question ID
            question_id = question.id
            if exam.is_question_enabled(question_id):
                log.info(f"Question {question_id} is enabled")
                # Check if there's a response in the command data
                question_key = f"question-{question_id}"
                if question_key in command.data:
                    response = command.data[question_key]
                    if response:
                        log.info(f"Response: {response}")
        # Example: Enable all questions that have responses, disable those without
        for question in exam.questions:
            question_id = question.id
            question_key = f"question-{question_id}"
            # Check if question has a response in command.data
            has_response = question_key in command.data and command.data[question_key]
            if has_response:
                exam.set_question_enabled(question_id, True)
            else:
                # Optionally disable questions without responses
                exam.set_question_enabled(question_id, False)
        effects.append(exam.edit())
**Example - Creating a New Physical Exam** :
    from canvas_sdk.commands import PhysicalExamCommand
    # Create a new physical exam
    exam = PhysicalExamCommand(
      note_uuid='a229456f-c10d-4f85-a04e-e8675d4e56dd',
      questionnaire_id='83d93454-25a9-404d-83a5-e0ed2ec3af00',
    )
    questions = exam.questions  # Retrieve the list of questions
    # Returns: [
    #               Question(
    #                       self.name='question-12',
    #                       self.label='Body length (in)',
    #                       self.type='TXT',
    #                       self.options=[ResponseOption(self.dbid=38, self.name='Body length (in)', self.code='8306-3', self.value='')],
    #                       self.response=None
    #               ),
    #               Question(
    #                       self.name='question-13',
    #                       self.label='Head circumference (cm)',
    #                       self.type='TXT', self.options=[ResponseOption(self.dbid=39, self.name='Head circumference (cm)', self.code='8287-5', self.value='')],
    #                       self.response=None
    #               )
    # Check if a question is enabled
    if exam.is_question_enabled("12"):
      print("Body length question is enabled.")
    # Disable irrelevant questions
    exam.set_question_enabled("13", False)
    # Get all toggle states
    states = exam.question_toggles
    # Returns: {"12": True, "13": False, "14": True, ...}, where keys are question IDs and values are enabled states.
    # Working with existing exam - toggle states are preserved
    existing_exam = PhysicalExamCommand(command_uuid='existing-exam-uuid')
    # All previously set toggle states are automatically loaded
**Note:** The PhysicalExamCommand is a subclass of the QuestionnaireCommand,
so it supports all the questionnaire features (including response recording,
question mapping, etc.). For detailed information on these features, please
refer to the Questionnaire Command Documentation.
* * *
##  Questionnaire #
###  Overview #
The `QuestionnaireCommand` is used to present a questionnaire to a patient and
commit their responses to an interview. It requires the ID of the
questionnaire
**Automatic Questionnaire ID Loading** : When instantiating a
QuestionnaireCommand with an existing `command_uuid`, the questionnaire_id
will be automatically loaded from the database if not explicitly provided.
This means you donât need to specify the questionnaire_id when working with
existing commands.
In addition to the basic parameters, this command supports a dynamic response
interface. Once instantiated, you can retrieve the list of questions via the
`questions` property, and then record responses for each question using the
question objectâs `add_response()` method. Each question type enforces its
expected response format:
  * **Text questions (TYPE_TEXT):** Accept a keyword argument `text` (a string).
  * **Integer questions (TYPE_INTEGER):** Accept a keyword argument `integer` (an integer or a value convertible to an integer).
  * **Radio questions (TYPE_RADIO):** Accept a keyword argument `option` (a `ResponseOption` instance); only one option may be selected.
  * **Checkbox questions (TYPE_CHECKBOX):** Accept a keyword argument `option` (a `ResponseOption` instance) along with an optional boolean `selected` (defaulting to True) and an optional string `comment`. Multiple responses can be recorded.
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`questionnaire_id`|  _string_| `true`| The externally exposable id of the
questionnaire being answered by the patient.  
`result`|  _string_| `false`| A summary of the result of the patientâs
answers.  
**Example** :
    from canvas_sdk.commands import QuestionnaireCommand
    questionnaire = QuestionnaireCommand(
        note_uuid='rk786p',
        questionnaire_id='g73hd9',
        result='The patient is feeling average today.'
    )
###  Usage Example #
Below is an example that demonstrates how to instantiate a
`QuestionnaireCommand`, retrieve the questions, and add responses to them
based on their type:
    import uuid
    from canvas_sdk.commands.commands.questionnaire import QuestionnaireCommand
    from canvas_sdk.commands.commands.questionnaire.question import ResponseOption
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Note, Questionnaire
    class Protocol(BaseHandler):
        def compute(self) -> list[Effect]:
          q = Questionnaire.objects.filter(name="Exercise").first()
          note = Note.objects.last()
          # Create a QuestionnaireCommand instance.
          command = QuestionnaireCommand(questionnaire_id=str(q.id))
          command.note_uuid = str(note.id)
          command.command_uuid = str(uuid.uuid4())
          # Alternatively you can just retrieve an existing questionnaire command, and only return an `edit` effect.
          # Retrieve the list of questions.
          questions = command.questions
          # Record responses for each question.
          for question in questions:
              if question.type == ResponseOption.TYPE_TEXT:
                  # For text questions, pass a 'text' keyword argument.
                  question.add_response(text=f"Thanks for all the fish")
              elif question.type == ResponseOption.TYPE_INTEGER:
                  # For integer questions, pass an 'integer' keyword argument.
                  question.add_response(integer=42)
              elif question.type == ResponseOption.TYPE_RADIO:
                  # For radio questions, pass an 'option' keyword argument (a ResponseOption instance).
                  first_option = question.options[0]
                  question.add_response(option=first_option)
              elif question.type == ResponseOption.TYPE_CHECKBOX:
                  # For checkbox questions, add responses with option, selected flag, and optionally a comment.
                  first_option = question.options[0]
                  last_option = question.options[-1]
                  question.add_response(option=first_option, selected=True, comment="Don't panic")
                  question.add_response(option=last_option, selected=True)
          # Because we're directly setting a command_uuid, we can return both originate and edit.
          return [command.originate(), command.edit()]
###  Explanation #
  * **Retrieving Questions:** The `questions` property returns a list of question objects created from the questionnaireâs data.
  * **Recording Responses:** Each question object provides an `add_response()` method that enforces the correct response format:
    * For **TextQuestion** , you must pass a `text` parameter.
    * For **IntegerQuestion** , you must pass an `integer` parameter.
    * For **RadioQuestion** , you must pass an `option` parameter (a `ResponseOption` instance) that corresponds to one of the allowed options.
    * For **CheckboxQuestion** , you must pass an `option` parameter along with an optional `selected` flag (defaulting to True) and an optional `comment`. Multiple responses can be recorded for checkbox questions.
    * **Note for Checkboxes:** Only the responses explicitly provided in the command payload will be updated in the UI. If a checkbox response is already selected and is not sent as unselected in the payload, its state remains unchanged.
  * **Creating and Editing:** When creating a new questionnaire command, you must explicitly set a unique `command_uuid`. Providing this UUID enables you to originate the command within the note and then subsequently edit it with detailed responses in the same protocol execution.
  * This approach is necessary because given the dynamic nature of the questionnaire command, the initial creation (origination) only includes the questionnaire ID. Once the command has been originated, you can immediately follow up with an edit to populate it with the patientâs responses.
  * If you are looking to insert a committed questionnaire command, youâll need to return three effects:
    * An `.originate()` to insert the command and select the questionnaire
    * An `.edit()` to populate the responses
    * A `.commit()` to commit the command
* * *
##  ReasonForVisit #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`structured`|  _boolean_| `false`| Whether the RFV is structured or not.
Defaults to False.  
`coding`|  _Coding_ or _UUID (str)_| `true` if structured=True| The coding for
the structured RFV. Either a full Coding object (with `code`, `system`,
`display`) or a UUID string referencing a verified coding record. If a Coding
is provided, it is validated against existing records  
`comment`|  _string_| `false`| Additional commentary on the RFV.  
**Example** :
    from canvas_sdk.commands import ReasonForVisitCommand
    structured_rfv = ReasonForVisitCommand(
      note_uuid='rk786p',
      structured=True,
      coding={'code': '', 'system': '', 'display': ''},
      comment='also wants to discuss treatment options'
    )
    # Example with a UUID string referencing a Coding record
    structured_rfv2 = ReasonForVisitCommand(
      note_uuid='rk786p',
      structured=True,
      coding="e2b1e1e3-3f52-4a0a-bb3a-123456789abc",  # Must correspond to an existing coding record
      comment="Discuss treatment options"
    )
    unstructured_rfv = ReasonForVisitCommand(
      note_uuid='rk786p',
      comment='also wants to discuss treatment options'
    )
##  Refer #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`service_provider`|  _ServiceProvider_| `true`| The service provider
associated with the referral command.  
`diagnosis_codes`|  _list[string]_| `true`| A list of relevant ICD-10
Diagnosis.  
`clinical_question`|  _ClinicalQuestion enum_| `true`| The clinical question
prompting the referral. Must be one of `ReferCommand.ClinicalQuestion`  
`priority`|  _Priority enum_| `false`| Priority of the imaging order. Must be
one of `ReferCommand.Priority`.  
`notes_to_specialist`|  _string_| `true`| Notes or additional information
directed to the specialist.  
`include_visit_note`|  _boolean_| `false`| Flag indicating whether the visit
note should be included in the referral.  
`comment`|  _string_| `false`| An optional comment providing further details
about the referral.  
`linked_items_urns`|  _list[string]_| `false`| List of URNs for items linked
to the referral command.  
**Command-specific actions** :
Action Name| Available When| Description  
---|---|---  
`delegate_action`| command is staged| Delegates the order by creating a task.  
`sign_action`| command is staged| Signs the order, transitioning it from
staged to committed state.  
`print_specialist`| command is committed| Prints the order using a specialist-
focused template.  
`print_patient`| command is committed| Prints the order using a patient-
friendly template.  
`fax`| command is committed| Transmits the order electronically via fax.  
**Enums and Types** :
**`Priority`**
Priority| Description  
---|---  
`ROUTINE`| Indicates a routine order.  
`URGENT`| Indicates un urgent order.  
**`ClinicalQuestion`**
Clinical Question| Description  
---|---  
COGNITIVE_ASSISTANCE| Cognitive Assistance (Advice/Guidance)  
ASSISTANCE_WITH_ONGOING_MANAGEMENT| Assistance with Ongoing Management  
SPECIALIZED_INTERVENTION| Specialized intervention  
DIAGNOSTIC_UNCERTAINTY| Diagnostic Uncertainty  
**Example** :
    from canvas_sdk.commands import ReferCommand
    from canvas_sdk.commands.constants import ServiceProvider
    refer_command = ReferCommand(
        note_uuid="rk786p",
        diagnosis_codes=["E119"],
        priority=ReferCommand.Priority.ROUTINE,
        clinical_question=ReferCommand.ClinicalQuestion.DIAGNOSTIC_UNCERTAINTY,
        comment="this is a comment",
        notes_to_specialist="This is a note to specialist",
        include_visit_note=True,
        service_provider=ServiceProvider(
          first_name="Clinic",
          last_name="Acupuncture",
          practice_name="Clinic Acupuncture",
          specialty="Acupuncture",
          business_address="Street Address",
          business_phone="1234569874",
          business_fax="1234569874"
     ),
    )
* * *
##  Refill #
**Command-specific parameters** :
Check the Prescribe command for the parameters used in the Refill command.
**Example** :
    from canvas_sdk.commands import RefillCommand, PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    RefillCommand(
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id="provider_456",
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
* * *
##  RemoveAllergy #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`allergy_id`|  _string_| `true`| The external ID of the allergy to remove.  
`narrative`|  _string_| `false`| Additional context or narrative for the
removal.  
**Example** :
    from canvas_sdk.commands import RemoveAllergyCommand
    RemoveAllergyCommand(
        allergy_id="123",
        narrative="Allergy no longer applies after reassessment."
    )
* * *
##  Resolve Condition #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`condition_id`|  _string_| `true`| The externally exposable id of the
condition being resolved.  
`show_in_condition_list`|  _boolean_| `false`| Determines whether the
condition remains visible in patient chart summary.  
`rationale`|  _string_| `false`| Additional context.  
    from canvas_sdk.commands.commands.resolve_condition import ResolveConditionCommand
    from canvas_sdk.v1.data import Condition
    patient_id = '<a patient ID from your instance>'
    patient_condition = Condition.objects.for_patient(patient_id).committed().active().first()
    ResolveConditionCommand(
       condition_id=patient_condition.id,
       show_in_condition_list=True,
       rationale="Additional notes.",
       note_uuid="rk786p",
    )
* * *
##  Review of Systems #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`questionnaire_id`|  _string_| `true`| The externally exposable id of the
questionnaire being answered by the patient.  
`result`|  _string_| `false`| A summary of the result of the patientâs
answers.  
###  Toggle Questions Feature #
The ReviewOfSystemsCommand includes the same toggle functionality as
PhysicalExamCommand, allowing practitioners to enable or disable specific
system review questions based on patient relevance. You can find an extra
example of this functionality on the Physical Exam Command Documentation.
**Methods** :
Method| Parameters| Returns| Description  
---|---|---|---  
`is_question_enabled`| `question_id: str` or `int`| `bool`| Check if a
specific question is enabled (not skipped).  
`set_question_enabled`| `question_id: str` or `int, enabled: bool`| `None`|
Enable or disable a specific question.  
`question_toggles`|  _property_| `dict`| Get all current toggle states
(question_id â enabled).  
**Example** :
    from canvas_sdk.commands import ReviewOfSystemsCommand
    # Create a new review of systems
    ros = ReviewOfSystemsCommand(
      note_uuid='8a18931a-acd9-474b-9070-ccd6fd472313',
      questionnaire_id='ed92577b-a023-4370-bc85-2b57e8afc4d8',
    )
    questions = ros.questions  # Retrieve the list of questions
    # Returns: [
    #               Question(
    #                       self.name='question-14',
    #                       self.label='Recurrent fever or chills',
    #                       self.type='TXT',
    #                       self.options=[]],
    #                       self.response=None
    #               ),
    #               Question(
    #                       self.name='question-25',
    #                       self.label='Other',
    #                       self.type='TXT', self.options=[],
    #                       self.response=None
    #               )
    # Check if a question is enabled
    if ros.is_question_enabled("14"):
      print("Recurrent fever or chills question is enabled.")
    # Disable irrelevant questions
    ros.set_question_enabled("25", False)
    # Get all toggle states
    states = ros.question_toggles
    # Returns: {"14": True, "25": False, "26": True, ...}, where keys are question IDs and values are enabled states.
    # Working with existing ros - toggle states are preserved
    existing_ros = ReviewOfSystemsCommand(command_uuid='existing-exam-uuid')
    # All previously set toggle states are automatically loaded
**Note:** The ReviewOfSystemsCommand is a subclass of the
QuestionnaireCommand, so it supports all the questionnaire features (including
response recording, question mapping, etc.). For detailed information on these
features, please refer to the Questionnaire Command Documentation.
* * *
##  StopMedication #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`medication_id`|  _string_| `true`| Externally exposable id of the patientâs
medication being stopped.  
`rationale`|  _string_| `false`| The reason for stopping the medication.  
**Example** :
    from canvas_sdk.commands import StopMedicationCommand
    stop_medication = StopMedicationCommand(
        note_uuid='rk786p',
        medication_id='2u309j',
        rationale='In remission'
    )
* * *
##  StructuredAssessment #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`questionnaire_id`|  _string_| `true`| The externally exposable id of the
questionnaire being answered by the patient.  
`result`|  _string_| `false`| A summary of the result of the patientâs
answers.  
**Example** :
    from canvas_sdk.commands import StructuredAssessmentCommand
    questionnaire = StructuredAssessmentCommand(
        note_uuid='rk786p',
        questionnaire_id='g73hd9',
        result='The patient is feeling average today.'
    )
**Note:** The StructuredAssessmentCommand is a subclass of the
QuestionnaireCommand, so it supports all the questionnaire features (including
response recording, question mapping, etc.). For detailed information on these
features, please refer to the Questionnaire Command Documentation.
* * *
##  Task #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`title`|  _string_| `true`| The title or summary of the task.  
`assign_to`|  _TaskAssigner_| `true`| Specifies the assignee (role, team, or
individual).  
`due_date`|  _date_| `false`| Due date for completing the task.  
`comment`|  _string_| `false`| Additional comments or notes about the task.  
`labels`|  _list[string]_| `false`| Labels associated with the task.  
`linked_items_urns`|  _list[string]_| `false`| URNs for items linked to the
task.  
**Enums and Types** :
**TaskAssigner Type** :
Key| Type| Required| Description  
---|---|---|---  
`to`|  _AssigneeType_| `true`| Type of assignee (e.g., role, team, etc.).  
`id`|  _integer_| `false`| Identifier of the specific assignee.  
AssigneeType| Value| Description  
---|---|---  
`ROLE`| `"role"`| Task assigned to a specific role.  
`TEAM`| `"team"`| Task assigned to a specific team.  
`UNASSIGNED`| `"unassigned"`| Task is unassigned.  
`STAFF`| `"staff"`| Task assigned to a specific staff member.  
**Example** :
    from canvas_sdk.commands import TaskCommand
    from canvas_sdk.commands.commands.task import TaskAssigner, AssigneeType
    from datetime import date
    TaskCommand(
        title="Follow-up appointment scheduling",
        assign_to=TaskAssigner(to=AssigneeType.STAFF, id=123),
        due_date=date(2024, 12, 15),
        comment="Ensure the patient schedules a follow-up within 30 days.",
        labels=["Urgent"],
        linked_items_urns=["urn:task:123", "urn:note:456"]
    )
* * *
##  UpdateDiagnosis #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`condition_code`|  _string_| `true`| The ICD-10 code of the existing diagnosis
to update.  
`new_condition_code`|  _string_| `true`| The new condition ICD-10 code to
replace the existing diagnosis.  
`background`|  _string_| `false`| Background information or notes related to
the updated diagnosis.  
`narrative`|  _string_| `false`| A narrative or explanation about the update.  
* * *
**Example**
     from canvas_sdk.commands import UpdateDiagnosisCommand
    UpdateDiagnosisCommand(
        condition_code="E119",
        new_condition_code="E109",
        background="Patient previously diagnosed with diabetes type 2; now updated to diabetes type 1.",
        narrative="Updating condition based on recent clinical findings."
    )
* * *
##  UpdateGoal #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`goal_id`|  _string_| `true`| Externally exposable id of the goal being
updated.  
`due_date`|  _datetime_| `false`| The date the goal is due.  
`achievement_status`|  _AchievementStatus enum_| `false`| The current
achievement status of the goal.  
`priority`|  _Priority enum_| `false`| The priority of the goal.  
`progress`|  _string_| `false`| A narrative about the patientâs progress
toward the goal.  
`AchievementStatus`| Â  
---|---  
IN_PROGRESS| âin-progressâ  
IMPROVING| âimprovingâ  
WORSENING| âworseningâ  
NO_CHANGE| âno-changeâ  
ACHIEVED| âachievedâ  
SUSTAINING| âsustainingâ  
NOT_ACHIEVED| ânot-achievedâ  
NO_PROGRESS| âno-progressâ  
NOT_ATTAINABLE| ânot-attainableâ  
`Priority`| Â  
---|---  
HIGH| âhigh-priorityâ  
MEDIUM| âmedium-priorityâ  
LOW| âlow-priorityâ  
**Example** :
    from canvas_sdk.commands import UpdateGoalCommand, GoalCommand
    from datetime import datetime
    update_goal = UpdateGoalCommand(
        note_uuid='rk786p',
        goal_id='0j9whjjk',
        due_date=datetime(2025, 3, 31),
        achievement_status=GoalCommand.AchievementStatus.WORSENING,
        priority=GoalCommand.Priority.MEDIUM,
        progress='patient has slowed down progress and requesting to move due date out'
    )
* * *
##  Vitals #
**Command-specific parameters** :
Name| Type| Required| Description  
---|---|---|---  
`height`|  _integer_| `false`| Height in inches.  
`weight_lbs`|  _integer_| `false`| Weight in pounds.  
`weight_oz`|  _integer_| `false`| Weight in ounces.  
`waist_circumference`|  _integer_| `false`| Waist circumference in inches.  
`body_temperature`|  _integer_| `false`| Body temperature in Fahrenheit.  
`body_temperature_site`|  _enum_| `false`| Site of body temperature
measurement.  
`blood_pressure_systole`|  _integer_| `false`| Systolic blood pressure.  
`blood_pressure_diastole`|  _integer_| `false`| Diastolic blood pressure.  
`blood_pressure_position_and_site`|  _enum_| `false`| Position and site of
blood pressure measurement.  
`pulse`|  _integer_| `false`| Pulse rate in beats per minute.  
`pulse_rhythm`|  _enum_| `false`| Rhythm of the pulse.  
`respiration_rate`|  _integer_| `false`| Respiration rate in breaths per
minute.  
`oxygen_saturation`|  _integer_| `false`| Oxygen saturation in percentage.  
`note`|  _string_| `false`| Additional notes (max length: 150 characters).  
**Enums and Types** :
BodyTemperatureSite| Value| Description  
---|---|---  
`AXILLARY`| `0`| Measurement taken from the armpit.  
`ORAL`| `1`| Measurement taken from the mouth.  
`RECTAL`| `2`| Measurement taken from the rectum.  
`TEMPORAL`| `3`| Measurement taken from the forehead.  
`TYMPANIC`| `4`| Measurement taken from the ear.  
BloodPressureSite| Value| Description  
---|---|---  
`SITTING_RIGHT_UPPER`| `0`| Sitting position, right upper arm.  
`SITTING_LEFT_UPPER`| `1`| Sitting position, left upper arm.  
`STANDING_RIGHT_UPPER`| `4`| Standing position, right upper arm.  
`SUPINE_LEFT_LOWER`| `11`| Supine position, left lower arm.  
PulseRhythm| Value| Description  
---|---|---  
`REGULAR`| `0`| Regular rhythm.  
`IRREGULARLY_IRREGULAR`| `1`| Completely irregular rhythm.  
`REGULARLY_IRREGULAR`| `2`| Regularly irregular rhythm.  
**Example** :
    from canvas_sdk.commands import VitalsCommand
    VitalsCommand(
        height=70,
        weight_lbs=150,
        body_temperature=98,
        body_temperature_site=VitalsCommand.BodyTemperatureSite.ORAL,
        blood_pressure_systole=120,
        blood_pressure_diastole=80,
        blood_pressure_position_and_site=VitalsCommand.BloodPressureSite.SITTING_RIGHT_UPPER,
        pulse=72,
        pulse_rhythm=VitalsCommand.PulseRhythm.REGULAR,
        oxygen_saturation=98,
        note="Vitals are within normal range."
    )
----- END PAGE https://docs.canvasmedical.com/sdk/commands/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data/
# Data
Last updated: 17 Jan 2025
The data module provides you with data to compute on. It provides curated,
secure access to both PHI (e.g. patient data) and non-PHI (e.g. staff and
practice-level data), representing the current state of your target Canvas
instance. The moduleâs classes offer convenience methods and operators that
make business logic and clinical logic easy to express with standard
terminologies like ICD-10, SNOMED-CT, CPT, and the like.
Data module classes are Django ORM models, which allow easy retrieval of data
at runtime through Djangoâs expressive [QuerySet
API](https://docs.djangoproject.com/en/5.1/ref/models/querysets/).
The pages below provide listings of the models, their attributes, and examples
of usage.
[ AllergyIntoleranceHarmful or undesired physiological responses associated
with exposure to a substance. ](/sdk/data-allergy-intolerance/)[ AppointmentA
scheduled meeting between a patient and a provider. ](/sdk/data-appointment/)[
AssessmentClinical assessment of a patient's condition. ](/sdk/data-
assessment/)[ BannerAlertAn alert notification linked to a patient.
](/sdk/data-banner-alert/)[ BillingLineItemA billable code linked to a patient
note. ](/sdk/data-billing-line-item/)[ BusinessLineA group of patients that
share a common brand under an organization. ](/sdk/data-business-line/)[
CanvasUserUser accounts associated with other records. ](/sdk/data-
canvasuser/)[ CareTeamTeams assigned for patient care. ](/sdk/data-care-
team/)[ ChargeDescriptionMasterBilling charges in Canvas that can be added to
the note footer. ](/sdk/data-charge-description-master/)[ ClaimA healthcare
claim. ](/sdk/data-claim/)[ CommandStructured units of documentation in a
patient's chart. ](/sdk/data-command/)[ CommonEnumerationTypesCommon choice
classes used in multiple models. ](/sdk/data-enumeration-types/)[
CompoundMedicationCompound medications, which are custom-made medications
tailored to a patient's specific needs. ](/sdk/data-compound-medication/)[
ConditionCondition, diagnosis, or reason for seeking medical attention.
](/sdk/data-condition/)[ CoveragePatient insurance coverage. ](/sdk/data-
coverage/)[ DetectedIssueActual or potential clinical issue with or between
one or more active or proposed clinical actions for a patient. ](/sdk/data-
detected-issue/)[ DeviceType of a manufactured item that is used in the
provision of healthcare. ](/sdk/data-device/)[ EligibilitySummarySummary of
copay and coinsurance for a Coverage. ](/sdk/data-
coverage/#eligilibitysummary)[ EncounterA patient Encounter connected to a
Note in Canvas. ](/sdk/data-encounter/)[ FacilityA location where healthcare
services are provided. ](/sdk/data-facility/)[ ImagingAnalysis of imaging
tests to obtain information about the health of a patient. ](/sdk/data-
imaging/)[ ImmunizationA record of a vaccination that is being administered to
a patient, either now, in the past, or in the future. ](/sdk/data-
immunization/)[ LabsAnalysis of clinical specimens to obtain information about
the health of a patient. ](/sdk/data-labs/)[ LabPartnerLab partners and the
tests they offer within Canvas. ](/sdk/data-lab-partner-and-test/)[
MedicationA record of a medication that is being consumed by a patient, either
now, in the past, or in the future. ](/sdk/data-medication/)[ Medication
HistoryA record of a patient's medication history, including medications that
were taken in the past but are no longer active. ](/sdk/data-medication-
history/)[ Medication StatementA record of a medication statement by a patient
from the past. ](/sdk/data-medication-statement/)[ MessageMessages sent to and
from Canvas. ](/sdk/data-message/)[ NoteClinical notes on patient charts.
](/sdk/data-note/)[ ObservationMeasurements and simple assertions made about a
patient. ](/sdk/data-observation/)[ OrganizationThe clinical organization
present in the Canvas EMR. ](/sdk/data-organization/)[ PatientData used to
categorize individuals for identification, records matching, and other
purposes. ](/sdk/data-patient/)[ PatientConsentDocumented patient consents
that ensure legal compliance and protect patient rights. ](/sdk/data-patient-
consent/)[ PayorSpecificChargeA billing charge specific to a certain
transactor in Canvas. ](/sdk/data-payor-specific-charge/)[ PostingPayments and
postings associated with healthcare claims. ](/sdk/data-posting/)[
PracticeLocationThe practice locations present in the Canvas EMR. ](/sdk/data-
practicelocation/)[ ProtocolCurrentThe current state of clinical protocols
applied to patients within Canvas. ](/sdk/data-protocol-current/)[
ProtocolOverrideA record of a protocol being snoozed for a patient.
](/sdk/data-protocol-override/)[ Stop Medication EventA record of a Stop
Medication Event, when a medication is removed from a patient's medication
list. ](/sdk/data-stop-medication-event)[ QuestionnaireGroups of coded
questions and the coded patient responses. ](/sdk/data-questionnaire)[
ReasonForVisitThe reason for a patient's visit. ](/sdk/data-reason-for-
visit/)[ ReferralA referral directing a specific patient to another provider
or specialist. ](/sdk/data-referral/)[ ServiceProviderData associated with
Service Providers. ](/sdk/data-serviceprovider/)[ StaffData associated with
Staff members. ](/sdk/data-staff)[ TaskData associated with Tasks.
](/sdk/data-task)[ TeamData associated with Teams. ](/sdk/data-team)[
ValueSetsLists of codes and terms from various clinical coding systems grouped
by a defining concept. ](/sdk/data-value-sets/)
----- END PAGE https://docs.canvasmedical.com/sdk/data/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-allergy-intolerance/
# AllergyIntolerance
Last updated: 8 Sep 2025
##  Introduction #
The `AllergyIntolerance` model represents a known risk, specific to a patient,
of a harmful or undesirable physiological response associated with exposure to
a substance.
##  Basic usage #
To get an allergy intolerance by identifier, use the `get` method on the
`AllergyIntolerance` model manager:
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    allergy = AllergyIntolerance.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the allergy intolerances for a patient can be
accessed with the `allergy_intolerances` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    allergies = patient.allergy_intolerances.all()
If you have a patient ID, you can get the allergies for the patient with the
`for_patient` method on the `AllergyIntolerance` model manager:
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    allergies = AllergyIntolerance.objects.for_patient(patient_id)
##  Codings #
The codings for an allergy intolerance can be accessed with the `codings`
attribute on an `AllergyIntolerance` object:
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    from logger import log
    allergy = AllergyIntolerance.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in allergy.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
##  Filtering #
Allergy intolerances can be filtered by any attribute that exists on the
model.
Filtering for allergy intolerances is done with the `filter` method on the
`AllergyIntolerance` model manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    allergies = AllergyIntolerance.objects.filter(status="active")
###  By ValueSet #
Filtering by ValueSet works a little differently. The `find` method on the
model manager is used to perform `ValueSet` filtering:
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    from canvas_sdk.value_set.v2022.allergy import EggSubstance
    allergies = AllergyIntolerance.objects.find(EggSubstance)
##  Attributes #
###  AllergyIntolerance #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
note_id| Integer  
allergy_intolerance_type| String  
category| Integer  
status| String  
severity| String  
onset_date| Date  
onset_date_original_input| String  
last_occurrence| Date  
last_occurrence_original_input| String  
recorded_date| DateTime  
narrative| String  
codings| AllergyIntoleranceCoding[]  
###  AllergyIntoleranceCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
allergy_intolerance| AllergyIntolerance  
----- END PAGE https://docs.canvasmedical.com/sdk/data-allergy-intolerance/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-appointment/
# Appointment
Last updated: 16 Sep 2025
##  Introduction #
The `Appointment` model represents a single scheduled meeting from a patient,
that may be in the future or past.
##  Basic usage #
To get an appointment by identifier, use the `get` method on the `Appointment`
model manager:
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
If you have a patient object, the appointments for a patient can be accessed
with the `appointments` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    appointments = patient.appointments.all()
To get appointments part of a recurrence.
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    # parent appointment
    parent_appointment = appointment.parent_appointment
    # children appointments
    children = parent_appointment.children.all()
##  Filtering #
Appointments can be filtered by any attribute that exists on the model.
Filtering for appointments is done with the `filter` method on the
`Appointment` model manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.appointment import Appointment, AppointmentProgressStatus
    appointments = Appointment.objects.filter(status=AppointmentProgressStatus.CONFIRMED)
###  Filtering by External Identifiers #
To query Appointments by external identifiers, the `external_identifiers`
relation can be used with double-underscores to identify values stored on the
AppointmentExternalIdentifier model. For example:
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.filter(
        external_identifiers__system="COMPANY_IDENTIFIER",
        external_identifiers__value="ejNoTa5vKzoT9oSjg87MVB").first()
##  Attributes #
###  Appointment #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
appointment_rescheduled_from| Appointment  
parent_appointment| Appointment  
provider| Staff  
start_time| DateTime  
duration_minutes| Integer  
comment| String  
note_id| Integer  
note_type_id| Integer  
status| String  
meeting_link| URL  
telehealth_instructions_sent| Boolean  
location| PracticeLocation  
description| String  
external_identifiers| AppointmentExternalIdentifier[]  
metadata| AppointmentMetadata[]  
###  AppointmentExternalIdentifier #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
use| String  
identifier_type| String  
system| String  
value| String  
issued_date| Date  
expiration_date| Date  
appointment| Appointment  
###  AppointmentMetadata #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
appointment| Appointment  
key| String  
value| String  
    from canvas_sdk.v1.data.appointment import Appointment
    from logger import log
    appointment_id = "f53626e4-0683-43ac-a1b7-c52815639ce2"
    appointment = Appointment.objects.get(id=appointment_id)
    appointment_metadata = appointment.metadata.all()
    for metadata in appointment_metadata:
       log.info(f"Appointment metadata: {metadata.key}, {metadata.value}")
----- END PAGE https://docs.canvasmedical.com/sdk/data-appointment/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-banner-alert/
# BannerAlert
Last updated: 8 Sep 2025
##  Introduction #
The `BannerAlert` model represents alerts associated with [Patient](/sdk/data-
patient/#patient) records. This page deals with data retrieval. To create or
remove `BannerAlert` records, see [Banner Alert Effects](/sdk/effect-banner-
alerts/).
##  Usage #
The `BannerAlert` model can be used to find all of the banner alert records
linked to a patient. For example, to find all of the banner alerts for a
patient, the `Patient.banner_alerts` method can be used:
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_banner_alerts = patient_1.banner_alerts.all()
    >>> print([item.narrative for item in patient_banner_alerts])
    ['Patient spits when angry', 'Confirm contact info']
##  Filtering #
The `filter` method can be used to filter by desired attributes. The following
examples show commonly used operations to filter banner alert data:
**Show a Patientâs active BannerAlert records from the âfooâ plugin in
order of descending creation date**
     >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> banner_alerts = patient_1.banner_alerts.filter(status='active', plugin_name='foo').order_by("created")
    >>> print([item.narrative for item in banner_alerts])
    ['foo', 'bar']
##  Attributes #
###  BannerAlert #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
patient| [Patient](/sdk/data-patient/#patient)  
plugin_name| String  
key| String  
narrative| String  
placement| BannerAlertPlacement[]  
intent| BannerAlertIntent  
href| String  
status| BannerAlertStatus  
##  Enumeration types #
###  BannerAlertStatus #
Value| Label  
---|---  
active| Active  
inactive| Inactive  
###  BannerAlertIntent #
Value| Label  
---|---  
info| Info  
warning| Warning  
alert| Alert  
###  BannerAlertPlacement #
Value| Label  
---|---  
chart| Chart  
timeline| Timeline  
appointment_card| Appointment Card  
scheduling_card| Scheduling Card  
profile| Profile
----- END PAGE https://docs.canvasmedical.com/sdk/data-banner-alert/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-billing-line-item/
# BillingLineItem
Last updated: 8 Sep 2025
##  Introduction #
The `BillingLineItem` model represents billing line items linked to
[Notes](/sdk/data-note) that can be found in the note footer. BillingLineItems
are also linked to [Patient](/sdk/data-patient/#patient) instances.
##  Usage #
The `BillingLineItem` model can be used to find all of the billable codes
linked to a patient note. For example, to find all of the current billing line
items for a note, the `Note.billing_line_items` method can be used:
    >>> from canvas_sdk.v1.data.note import Note
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> note_1 = Note.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> note_1_billing_line_items = note_1.billing_line_items.filter(status=BillingLineItemStatus.ACTIVE)
    >>> print([item.cpt for item in note_1_billing_line_items])
    ['99213', '90703']
Alternatively, you could find all the `BillingLineItem` instances for a single
`Patient`:
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_billing_line_items = patient_1.billing_line_items.all()
    >>> print([item.cpt for item in patient_billing_line_items])
    ['99213', '90703', '76942', '67505']
You can also access all `BillingLineItemModifier`s associated with a
`BillingLineItem`:
    >>> from canvas_sdk.v1.data.billing import BillingLineItem, BillingLineItemModifier
    >>> line_item = BillingLineItem.objects.get(id="b80b1cdc2e6a4aca90ccebc02e683f35")
    >>> line_item_modifiers = line_item.modifiers.all()
    >>> print([mod.code for mod in line_item_modifiers])
    ['25', '59']
##  Filtering #
The `filter` method can be used to filter by desired attributes. The following
examples show commonly used operations to filter billing line item data:
**Show a Patientâs active BillingLineItems that start with â99-â in
order of descending charge amount**
     >>> from canvas_sdk.v1.data.patient import Patient
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> office_visit_charges = patient_1.billing_line_items.filter(status=BillingLineItemStatus.ACTIVE, cpt__startswith='99').order_by("charge")
    >>> print([(item.cpt, item.charge,) for item in office_visit_charges])
    [('99215', 200.00), ('99215', 190.00), ('99214', 100.00), ('99213', 80.00)]
**Find All Removed BillingLineItems from a Note**
     >>> import arrow
    >>> from canvas_sdk.v1.data.note import Note
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> note_1 = Note.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> note_1_removed_items = note_1.billing_line_items.filter(status=BillingLineItemStatus.REMOVED)
    >>> print([item.cpt for item in note_1_removed_items])
    ['11901', '00950']
For examples of how to use the BillingLineItem data class with the
BillingLineItem effects, check out [this page](/sdk/effect-billing-line-items)
##  Attributes #
###  BillingLineItem #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
note| [Note](/sdk/data-note)  
patient| [Patient](/sdk/data-patient/#patient)  
cpt| String  
charge| Decimal  
description| String  
units| Integer  
command_type| String  
command_id| Integer  
status| BillingLineItemStatus  
###  BillingLineItemModifier #
Field Name| Type  
---|---  
dbid| Integer  
line_item| BillingLineItem  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
##  Enumeration types #
###  BillingLineItemStatus #
Value| Label  
---|---  
ACTIVE| Active  
REMOVED| Removed
----- END PAGE https://docs.canvasmedical.com/sdk/data-billing-line-item/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-canvasuser/
# CanvasUser
Last updated: 13 Nov 2025
##  Introduction #
The `CanvasUser` model represents a Canvas User. This could be linked to a
staff member or a patient. This model isnât meant to be referenced directly,
but is sometimes used to attribute a record to user.
##  Basic usage #
To get a user by identifier, use the `get` method on the `CanvasUser` model
manager:
    from canvas_sdk.v1.data import CanvasUser
    user = CanvasUser.objects.get(dbid=123)
##  Filtering #
Users can be filtered by any attribute that exists on the model.
Filtering for users is done with the `filter` method on the `CanvasUser` model
manager.
###  By attribute #
Specify attributes with `filter` to filter by those attributes:
    from canvas_sdk.v1.data import CanvasUser
    users = CanvasUser.objects.filter(phone_number="1111111111", email="test@canvasmedical.com")
##  Attributes #
###  User #
Field Name| Type  
---|---  
dbid| Integer  
email| String  
phone_number| String  
last_invite_date_time| DateTime  
----- END PAGE https://docs.canvasmedical.com/sdk/data-canvasuser/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-care-team/
# CareTeam
Last updated: 8 Sep 2025
##  Introduction #
The `CareTeam` model represents a collection of [Staff](/sdk/data-
staff/#staff) that are responsible for the care of a [Patient](/sdk/data-
patient/#patient).
##  Usage #
There are 2 data models associated with Care Teams - `CareTeamMembership` and
`CareTeamRole`. The `CareTeamRole` model stores all of the available roles
that are available to be filled by staff members (i.e. _Physician_ , _Nurse
Practitioner_ , etc.). For example, the following code will show the names of
active roles that are available in a Canvas instance:
    >>> from canvas_sdk.v1.data.care_team import CareTeamRole
    >>> active_care_team_roles = CareTeamRole.objects.filter(active=True)
    >>> role_names = [role.display for role in active_care_team_roles]
    >>> print(role_names)
    ['Primary care physician', 'Physician', 'Physician assistant', 'Nurse practitioner', 'Health coach', 'Care coordinator']
The `CareTeamMembership` model connects patients, staff members and their
associated roles to make up the assembly of a patientâs Care Team. To
retrieve staff members and their respective roles on a patientâs care team,
the `care_team_memberships` attribute available on a [Patient](/sdk/data-
patient/#patient) instance can be used:
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_care_team = patient_1.care_team_memberships.all()
    >>> print([(ctm.role.display, ctm.staff,) for ctm in patient_1_care_team])
    [('Primary care physician', <Staff: Steven Magee>), ('Nurse practitioner', <Staff: Annalies Hines>), ('Physician assistant', <Staff: Erik McDonald>)]
##  Filtering #
The `filter` method can be used to filter by desired attributes. The following
examples show commonly used operations to filter care team data:
**Find a patientâs care team lead**
     >>> from canvas_sdk.v1.data.patient import Patient
    >>> from canvas_sdk.v1.data.care_team import CareTeamMembershipStatus
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_care_team_lead = patient_1.care_team_memberships.filter(lead=True, status=CareTeamMembershipStatus.ACTIVE).first()
    >>> assert patient_1_care_team_lead is not None
    >>> print((patient_1_care_team_lead.staff, patient_1_care_team_lead.role,))
    (<Staff: Steven Magee>, <CareTeamRole: Primary care physician>)
**Find all Patients that have a Certain Staff Member on their Care Team**
     >>> from canvas_sdk.v1.data.staff import Staff
    >>> from canvas_sdk.v1.data.care_team import CareTeamMembershipStatus
    >>> staff_member = Staff.objects.get(id="3640cd20de8a470aa570a852859ac87e")
    >>> staff_care_teams = staff_member.care_team_memberships.filter(status=CareTeamMembershipStatus.ACTIVE)
    >>> print([(ctm.patient, ctm.lead,) for ctm in staff_care_teams])
    [(<Patient: Danny Boy>, True), (<Patient: Sally Mae>, False)]
##  Attributes #
###  CareTeamRole #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| BooleanField  
active| Boolean  
care_teams| [CareTeamMembership](/sdk/data-care-team/#careteammembership)[]  
###  CareTeamMembership #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
patient| [Patient](/sdk/data-patient/#patient)  
staff| [Staff](/sdk/data-staff#staff)  
role| CareTeamRole  
status| CareTeamMembershipStatus  
lead| Boolean  
role_code| String  
role_system| String  
role_display| String  
##  Enumeration types #
###  CareTeamMembershipStatus #
Value| Label  
---|---  
proposed| Proposed  
active| Active  
suspended| Suspended  
inactive| Inactive  
entered-in-error| Entered in Error
----- END PAGE https://docs.canvasmedical.com/sdk/data-care-team/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-command/
# Command
Last updated: 24 Sep 2025
##  Introduction #
The `Command` model represents a [command](/sdk/commands/) in a note.
##  Basic usage #
To get a command by identifier, use the `get` method on the `Command` model
manager:
    from canvas_sdk.v1.data.command import Command
    command = Command.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
##  Filtering #
Commands can be filtered by any attribute that exists on the model.
Filtering for commands is done with the `filter` method on the `Command` model
manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.command import Command
    commands = Command.objects.filter(state="committed")
##  Command types and data #
When events are fired as part of [Command Lifecycle
Events](/sdk/events/#command-lifecycle-events), the `self.target` value that
is available within a plugin will contain the `id` value of the command. For
example:
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from logger import log
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.REASON_FOR_VISIT_COMMAND__POST_UPDATE),
        ]
        def compute(self) -> list[Effect]:
            log.info(self.target) # logs the Command id
Using this value, the `Command` model can be queried to fetch additional data
about the command. Two main fields to pay attention to here are the
`schema_key` and `data` fields. The `schema_key` field contains the type of
the command, while the `data` field contains a JSON object with command data
as key/value pairs:
    import json
    from canvas_sdk.effects import Effect
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.command import Command
    from logger import log
    class Protocol(BaseProtocol):
        def compute(self) -> list[Effect]:
            command_instance = Command.objects.get(id=self.target)
            log.info(command_instance.schema_key)
            log.info(json.dumps(command_instance.data, indent=2))
For example, for a _Reason For Visit_ command, the preceding code would log
the following lines:
    reasonForVisit
    {
      "coding": {
        "text": "Accident-prone",
        "extra": null,
        "value": "165002",
        "disabled": false,
        "annotations": null,
        "description": null
      },
      "comment": "Patient would like to discuss condition."
    }
The following table shows the different command `schema_key` values with links
to their respective [Command Modules](/sdk/commands). The attributes shown in
each corresponding entry contain the structure that will appear in the `data`
JSON field of each `Command`.
Schema Key| Command Data  
---|---  
adjustPrescription| [AdjustPrescription](/sdk/commands/#adjustprescription)  
allergy| [Allergy](/sdk/commands/#allergy)  
assess| [Assess](/sdk/commands/#assess)  
changeMedication| [ChangeMedication](/sdk/commands/#changemedication)  
closeGoal| [CloseGoal](/sdk/commands/#closegoal)  
diagnose| [Diagnose](/sdk/commands/#diagnose)  
familyHistory| [FamilyHistory](/sdk/commands/#familyhistory)  
followUp| [FollowUp](/sdk/commands/#followUp)  
goal| [Goal](/sdk/commands/#goal)  
hpi| [HistoryOfPresentIllness](/sdk/commands/#historyofpresentillness)  
imagingOrder| [ImagingOrder](/sdk/commands/#imagingorder)  
instruct| [Instruct](/sdk/commands/#instruct)  
labOrder| [LabOrder](/sdk/commands/#laborder)  
medicalHistory| [MedicalHistory](/sdk/commands/#medicalhistory)  
medicationStatement| [MedicationStatement](/sdk/commands/#medicationstatement)  
perform| [Perform](/sdk/commands/#perform)  
plan| [Plan](/sdk/commands/#plan)  
prescribe| [Prescribe](/sdk/commands/#prescribe)  
questionnaire| [Questionnaire](/sdk/commands/#questionnaire)  
reasonForVisit| [ReasonForVisit](/sdk/commands/#reasonforvisit)  
refer| [Refer](/sdk/commands/#refer)  
refill| [Refill](/sdk/commands/#refill)  
removeAllergy| [RemoveAllergy](/sdk/commands/#removeallergy)  
resolveCondition| [ResolveCondition](/sdk/commands/#resolvecondition)  
stopMedication| [StopMedication](/sdk/commands/#stopmedication)  
surgicalHistory| [SurgicalHistory](/sdk/commands/#surgicalhistory)  
task| [Task](/sdk/commands/#task)  
updateDiagnosis| [UpdateDiagnosis](/sdk/commands/#updatediagnosis)  
updateGoal| [UpdateGoal](/sdk/commands/#updategoal)  
vitals| [Vitals](/sdk/commands/#vitals)  
**PLEASE NOTE** the Commands Module is under development and Canvas is working
to migrate all commands to be available. This means that some commands are not
able to emit events available in plugins, and historical commands created
prior to their Commands Module availability may not be able to be queried
using the data module. [This product updates table](/product-updates/commands-
module/) shows the commands and their release statuses. If a command in a
chart is not available by querying the `Command` data model, the data is still
available to be queried using corresponding data models (i.e.
[Questionnaire](/sdk/data-questionnaire/), [ImagingOrder](/sdk/data-imaging/),
etc.).
##  Attributes #
###  Command #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
state| String  
patient| [Patient](/sdk/data-patient/#patient)  
note| [Note](/sdk/data-note/#note)  
schema_key| String  
data| JSON  
origination_source| String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-command/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-enumeration-types/
# Common Enumeration Type
Last updated: 24 Jan 2025
##  Introduction #
This page shows common enumeration types that are used in multiple models.
##  Enumeration types #
###  AddressState #
Value| Label  
---|---  
active| Active  
deleted| Deleted  
###  AddressType #
Value| Label  
---|---  
postal| Postal  
physical| Physical  
both| Both  
###  AddressUse #
Value| Label  
---|---  
home| Home  
work| Work  
temp| Temp  
old| Old  
###  ColorEnum #
Value| Label  
---|---  
red| Red  
orange| Orange  
yellow| Yellow  
olive| Olive  
green| Green  
teal| Teal  
blue| Blue  
violet| Violet  
purple| Purple  
pink| Pink  
brown| Brown  
grey| Grey  
black| Black  
###  ContactPointState #
Value| Label  
---|---  
active| Active  
deleted| Deleted  
###  ContactPointUse #
Value| Label  
---|---  
home| Home  
work| Work  
temp| Temp  
old| Old  
other| Other  
mobile| Mobile  
automation| Automation  
###  DocumentReviewMode #
Value| Label  
---|---  
RR| Review required  
AR| Already reviewed offline  
RN| Review not required  
###  OrderStatus #
Value| Description  
---|---  
proposed| Proposed  
draft| Draft  
planned| Planned  
requested| Requested  
received| Received  
accepted| Accepted  
in-progress| In-progress  
review| Review  
completed| Completed  
cancelled| Cancelled  
suspended| Suspended  
rejected| Rejected  
failed| Failed  
EIE| Entered in Error  
###  Origin #
Value| Label  
---|---  
REF_CMD| Referral command  
CMP_IMG_ORD| Completing image orders  
IMG_REP_REV| Imaging report review  
LAB_RES_REV| Lab results review  
CON_REP_REV| Consult report review  
UNC_DOC_REP_REV| Uncategorized document report review  
ASN_NOT_PHN_REV| Assigned note/phone call for review  
POP_HLT_OUT| Population health outreach  
CMP_LAB_ORD| Completing lab orders  
CHT_PDF| Chart PDF  
EXP_CLM_SNO| Expired claim snoozed  
FLG_PST_REV| Flagged posting review  
BAT_PTN_STA| Batch patient statements  
INC_COV| Incomplete Coverage  
###  PersonSex #
Value| Label  
---|---  
F| female  
M| male  
O| other  
UNK| unknown  
###  ReviewPatientCommunicationMethod #
Value| Description  
---|---  
DM| delegate call, can leave message  
DA| delegate call, need patient to answer  
DL| delegate letter  
DC| do not communicate  
AM| already left message  
AR| already reviewed with patient  
###  ReviewStatus #
Value| Label  
---|---  
reviewing| reviewing  
reviewed| reviewed  
###  TaxIDType #
Value| Label  
---|---  
E| EIN text  
S| SSN
----- END PAGE https://docs.canvasmedical.com/sdk/data-enumeration-types/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-condition/
# Condition
Last updated: 15 Jul 2025
##  Introduction #
The `Condition` model represents a clinical condition, problem, diagnosis, or
other event, situation, issue, or clinical concept that has risen to a level
of concern.
##  Basic usage #
To get a condition by identifier, use the `get` method on the `Condition`
model manager:
    from canvas_sdk.v1.data.condition import Condition
    condition = Condition.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the conditions for a patient can be accessed
with the `conditions` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    conditions = patient.conditions.all()
If you have a patient ID, you can get the conditions for the patient with the
`for_patient` method on the `Condition` model manager:
    from canvas_sdk.v1.data.condition import Condition
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    condition = Condition.objects.for_patient(patient_id)
##  Codings #
The codings for a condition can be accessed with the `codings` attribute on an
`Condition` object:
    from canvas_sdk.v1.data.condition import Condition
    from logger import log
    condition = Condition.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in condition.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
##  Filtering #
Conditions can be filtered by any attribute that exists on the model.
Filtering for conditions is done with the `filter` method on the `Condition`
model manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.condition import Condition
    conditions = Condition.objects.filter(onset_date__gte="2024-10-15")
###  By ValueSet #
Filtering by ValueSet works a little differently. The `find` method on the
model manager is used to perform `ValueSet` filtering:
    from canvas_sdk.v1.data.condition import Condition
    from canvas_sdk.value_set.v2022.condition import Diabetes
    conditions = Condition.objects.find(Diabetes)
##  Attributes #
###  Condition #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
deleted| Boolean  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
onset_date| Date  
resolution_date| Date  
clinical_status| ClinicalStatus  
codings| ConditionCoding[]  
lab_order_reason_conditions| [LabOrderReasonConditionCoding](/sdk/data-
labs/#laborderreasoncondition)[]  
surgical| Boolean  
###  ConditionCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
condition| Condition  
##  Enumeration types #
###  ClinicalStatus #
Value| Label  
---|---  
active| active  
relapse| relapse  
remission| remission  
resolved| resolved  
investigative| investigative  
----- END PAGE https://docs.canvasmedical.com/sdk/data-condition/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-coverage/
# Coverage
Last updated: 6 Oct 2025
##  Introduction #
The `Coverage` model represents insurance coverage linked to
[Patients](/sdk/data-patient/#patient). Coverages are linked to
[Patient](/sdk/data-patient/#patient) instances, as well as `Transactor`
instances, which represent the issuer for the corresponding coverage.
`Coverage`s also have an associated `EligibilitySummary`, which provides the
most up-to-date copay and and coinsurance values.
##  Usage #
The `Coverage` model can be used to find all of the coverages defined in a
Canvas instance, whether overall or for a particular patient. For example, to
find all of the current coverages for a patient, the `Patient.coverages`
method can be used:
    >>> import arrow
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_current_coverages = patient_1.coverages.filter(coverage_end_date__gt=arrow.now().date().isoformat())
    >>> print([coverage.issuer.name for coverage in patient_1_current_coverages])
    ['AVALON HEALTHCARE SOLUTIONS CAPITAL BLUE CROSS']
Alternatively, to find all of the `Coverage` instances issed by a particular
issuer/transactor, the `Transactor` model can be queried:
    >>> from canvas_sdk.v1.data.coverage import Coverage, Transactor
    >>> transactor_1 = Transactor.objects.get(payer_id="AVA03")
    >>> transactor_coverages = Coverage.objects.filter(issuer=transactor_1)
    >>> print(transactor_coverages)
    <QuerySet [<Coverage: id=89793979-dbff-4a53-b928-75db973c2bdc>, <Coverage: id=423c0f77-8083-4cc1-8e29-2c7d348281e4>]>
    >>>
Find the latest eligibility summary for a patient:
        from canvas_sdk.v1.data.coverage import Coverage, EligibilitySummary
        coverage = Coverage.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
        elig_summary_from_model = EligibilitySummary.objects.filter(coverage=coverage).first()
        elig_summary_from_cvg = coverage.eligibility_summary
        if elig_summary_from_model:
            print(elig_summary_from_model.copay_cents, elig_summary_from_model.coinsurance) # 1000 5
        if elig_summary_from_cvg:
            print(elig_summary_from_cvg.copay_cents, elig_summary_from_cvg.coinsurance) # 1000 5
##  Filtering #
The `filter` method can be used to filter by desired attributes. The following
examples show commonly used operations to filter coverage data:
**Show a Patientâs Coverages in order of Rank (Primary, Secondary, etc.)**
     >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_coverages = patient_1.coverages.all().order_by("coverage_rank")
    >>> print([(coverage.issuer.name, coverage.coverage_rank,) for coverage in patient_coverages])
    [('AVALON HEALTHCARE SOLUTIONS CAPITAL BLUE CROSS', 1), ('Blue Cross Blue Shield of Arizona Advantage', 2)]
**Find All Expired Coverages**
     >>> import arrow
    >>> from canvas_sdk.v1.data.coverage import Coverage
    >>> expired_coverages = Coverage.objects.filter(coverage_end_date__lt=arrow.now().date().isoformat())
    >>> print([f"{coverage.issuer.name} expired {coverage.coverage_end_date.isoformat()}" for coverage in expired_coverages])
    ['Blue Cross Blue Shield of Arizona Advantage expired 2025-01-10']
##  Attributes #
###  Coverage #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
patient| [Patient](/sdk/data-patient/#patient)  
guarantor| [Patient](/sdk/data-patient/#patient)  
subscriber| [Patient](/sdk/data-patient/#patient)  
patient_relationship_to_subscriber| CoverageRelationshipCode  
issuer| Transactor  
id_number| String  
plan| String  
sub_plan| String  
group| String  
sub_group| String  
employer| String  
coverage_start_date| Date  
coverage_end_date| Date  
coverage_rank| Integer  
state| CoverageState  
plan_type| CoverageType  
coverage_type| TransactorCoverageType  
issuer_address| TransactorAddress  
issuer_phone| TransactorPhone  
comments| Text  
stack| CoverageStack  
eligibility_summary| EligibilitySummary  
###  Transactor #
Field Name| Type  
---|---  
dbid| Integer  
payer_id| String  
name| String  
type| String  
transactor_type| TransactorType  
clearinghouse_payer| Boolean  
institutional| Boolean  
institutional_enrollment_req| Boolean  
professional| Boolean  
professional_enrollment_req| Boolean  
era| Boolean  
era_enrollment_req| Boolean  
eligibility| Boolean  
eligibility_enrollment_req| Boolean  
workers_comp| Boolean  
secondary_support| Boolean  
claim_fee| Boolean  
remit_fee| Boolean  
state| String  
description| String  
active| Boolean  
use_provider_for_eligibility| Boolean  
use_for_submission| Transactor  
used_for_submission_by| Transactor[]  
coverage_types| TransactorCoverageType[]  
addresses| TransactorAddress[]  
coverages| Coverage[]  
phones| TransactorPhone[]  
###  TransactorAddress #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
line1| String  
line2| String  
city| String  
district| String  
state_code| String  
postal_code| String  
use| [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type| [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude| Float  
latitude| Float  
start| Date  
end| Date  
country| String  
state| [AddressState](/sdk/data-enumeration-types/#addressstate)  
transactor| Transactor  
coverages| [Coverage](/sdk/data-coverage/#coverage)[]  
###  TransactorPhone #
Field Name| Type  
---|---  
id| UUIDField  
dbid| Integer  
created| DateTime  
modified| DateTime  
system| String  
value| String  
use| [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes| String  
rank| Integer  
state| [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
transactor| Transactor  
coverages| [Coverage](/sdk/data-coverage/#coverage)[]  
###  EligibilitySummary #
Field Name| Type  
---|---  
id| UUIDField  
dbid| Integer  
created| DateTime  
modified| DateTime  
coverage| [Coverage](/sdk/data-coverage/#coverage)  
copay_cents| Integer  
coinsurance| Integer  
##  Enumeration types #
###  CoverageStack #
Value| Label  
---|---  
IN_USE| In use  
OTHER| Other  
REMOVED| Removed  
###  CoverageState #
Value| Label  
---|---  
active| Active  
deleted| Deleted  
###  CoverageType #
Value| Label  
---|---  
commercial| Commercial  
workerscomp| Workers Comp  
bcbs| Blue Cross Blue Shield  
champus| Tricare/Champus  
medicaid| Medicaid  
medicare| Medicare  
other| Other  
tpa| Third Party Administrator  
motorvehicle| Motor Vehicle  
lien| Attorney/Lien  
pip| Personal Injury  
###  CoverageRelationshipCode #
Value| Label  
---|---  
18| Self  
01| Spouse  
19| Natural Child, insured has financial responsibility  
43| Natural Child, insured does not have financial responsibility  
17| Step Child  
10| Foster Child  
15| Ward of the Court  
20| Employee  
21| Unknown  
22| Handicapped Dependent  
39| Organ donor  
40| Cadaver donor  
05| Grandchild  
07| Niece/Nephew  
41| Injured Plaintiff  
23| Sponsored Dependent  
24| Minor Dependent of a Minor Dependent  
32| Mother  
33| Father  
04| Grandparent  
53| Life Partner  
29| Significant Other  
G8| Other  
###  TransactorCoverageType #
Value| Label  
---|---  
ANNU| annuity policy  
AUTOPOL| automobile  
CHAR| charity program  
COL| collision coverage policy  
CRIME| crime victim program  
DENTAL| dental care policy  
DENTPRG| dental program  
DIS| disability insurance policy  
DISEASE| disease specific policy  
DRUGPOL| drug policy  
EAP| employee assistance program  
EWB| employee welfare benefit plan policy  
ENDRENAL| end renal program  
EHCPOL| extended healthcare  
FLEXP| flexible benefit plan policy  
GOVEMP| government employee health program  
HIP| health insurance plan policy  
HMO| health maintenance organization policy  
HSAPOL| health spending account  
HIRISK| high risk pool program  
HIVAIDS| HIV-AIDS program  
IND| indigenous peoples health program  
LIFE| life insurance policy  
LTC| long term care policy  
MCPOL| managed care policy  
MANDPOL| mandatory health program  
MENTPOL| mental health policy  
MENTPRG| mental health program  
MILITARY| military health program  
pay| Pay  
POS| point of service policy  
PPO| preferred provider organization policy  
PNC| property and casualty insurance policy  
DISEASEPRG| public health program  
PUBLICPOL| public healthcare  
REI| reinsurance policy  
RETIRE| retiree health program  
SAFNET| safety net clinic program  
SOCIAL| social service program  
SUBSIDIZ| subsidized health program  
SUBSIDMC| subsidized managed care program  
SUBSUPP| subsidized supplemental health program  
SUBPOL| substance use policy  
SUBPRG| substance use program  
SURPL| surplus line insurance policy  
TLIFE| term life insurance policy  
UMBRL| umbrella liability insurance policy  
UNINSMOT| uninsured motorist policy  
ULIFE| universal life insurance policy  
VET| veteran health program  
VISPOL| vision care policy  
CANPRG| womenâs cancer detection program  
WCBPOL| workerâs compensation  
###  TransactorType #
Value| Label  
---|---  
commercial| Commercial  
workerscomp| Workers Comp  
champus| Tricare/Champus  
medicaid| Medicaid  
medicare| Medicare  
medicare_advantage| Medicare Advantage  
CHIP| CHIP  
automobile| Automobile  
employer| Employer  
direct_care| Direct Care  
bcbs| Blue Cross Blue Shield
----- END PAGE https://docs.canvasmedical.com/sdk/data-coverage/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-detected-issue/
# DetectedIssue
Last updated: 8 Sep 2025
##  Introduction #
The `DetectedIssue` model represents an actual or potential clinical issue
with or between one or more active or proposed clinical actions for a patient.
##  Basic usage #
To get a detected issue by identifier, use the `get` method on the
`DetectedIssue` model manager:
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    detected_issue = DetectedIssue.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the detected issues for a patient can be
accessed with the `detected_issues` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    detected_issues = patient.detected_issues.all()
##  Evidence #
The codings for the evidence of a detected issue can be accessed with the
`evidence` attribute on a `DetectedIssue` object:
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    from logger import log
    detected_issue = DetectedIssue.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in detected_issue.evidence.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
##  Filtering #
Detected issues can be filtered by any attribute that exists on the model.
Filtering for detected issues is done with the `filter` method on the
`DetectedIssue` model manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    detected_issues = DetectedIssue.objects.filter(status="active")
##  Attributes #
###  DetectedIssue #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
identified| DateTime  
deleted| Boolean  
originator| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
code| String  
status| String  
severity| String  
reference| String  
issue_identifier| String  
issue_identifier_system| String  
detail| String  
evidence| DetectedIssueEvidence[]  
###  DetectedIssueEvidence #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
detected_issue| [DetectedIssue](/sdk/data-detected-issue/#detectedissue)  
----- END PAGE https://docs.canvasmedical.com/sdk/data-detected-issue/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-device/
# Device
Last updated: 24 Sep 2025
##  Introduction #
The `Device` model represents a type of a manufactured item that is used in
the provision of healthcare without being substantially changed through that
activity. The device may be a medical or non-medical device.
##  Basic usage #
To get a device by identifier, use the `get` method on the `Device` model
manager:
    from canvas_sdk.v1.data.device import Device
    device = Device.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the devices for a patient can be accessed with
the `devices` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    devices = patient.devices.all()
##  Filtering #
Devices can be filtered by any attribute that exists on the model.
Filtering for devices is done with the `filter` method on the `Device` model
manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.device import Device
    devices = Device.objects.filter(manufacturer="ACME Biomedical", lot_number="M320")
##  Attributes #
###  Device #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
note_id| Integer  
deleted| Boolean  
labeled_contains_NRL| Boolean  
assigning_authority| String  
scoping_entity| String  
udi| String  
di| String  
issuing_agency| String  
lot_number| String  
brand_name| String  
mri_safety_status| String  
version_model_number| String  
company_name| String  
gmdnPTName| String  
status| String  
expiration_date| Date  
expiration_date_original| String  
serial_number| String  
manufacturing_date_original| String  
manufacturing_date| Date  
manufacturer| String  
procedure_id| Integer  
----- END PAGE https://docs.canvasmedical.com/sdk/data-device/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-imaging/
# Imaging
Last updated: 18 Aug 2025
##  Introduction #
The `ImagingOrder`, `ImagingReview` and `ImagingReport` models represent
imaging results.
##  Basic Usage #
To retrieve an `ImagingOrder`, `ImagingReview`, or `ImagingReport` by
identifier, use the `get` method on the model manager:
    from canvas_sdk.v1.data.imaging import ImagingOrder, ImagingReview, ImagingReport
    imaging_order = ImagingOrder.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    imaging_review = ImagingReview.objects.get(id="c02c6b02-2581-46bf-819c-b5aacad2134c")
    imaging_report = ImagingReport.objects.get(id="c1a5a35a-4ee2-4a0e-85c0-21739dc8c4a8")
If you have a patient object, the orders, reviews, and reports can be accessed
with the `imaging_orders`, `imaging_reviews`, and `imaging_results`
attributes, respectively on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    orders = patient.imaging_orders.all()
    reviews = patient.imaging_reviews.all()
    reports = patient.imaging_results.all()
##  Filtering #
Imaging orders, reviews, and reports can be filtered by any attribute that
exists on the models.
Filtering is done with the `filter` method on the `ImagingOrder`,
`ImagingReview`, and `ImagingReport` model managers.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.imaging import ImagingOrder, ImagingReview, ImagingReport
    orders = ImagingOrder.objects.filter(status="completed")
    reviews = ImagingReview.objects.filter(is_released_to_patient=False)
    reports = ImagingReport.objects.filter(requires_signature=True)
##  Related Tasks #
To retrieve an Imaging Orderâs related tasks, use the `get_task_objects`
method on the ImagingOrder object.
    from canvas_sdk.v1.data.imaging import ImagingOrder
    imaging_order = ImagingOrder.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    tasks = imaging_order.get_task_objects().all()
##  Attributes #
###  ImagingOrder #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
note| [Note](/sdk/data-note/#note)  
imaging| String  
imaging_center| [ServiceProvider](/sdk/data-serviceprovider/#service-provider)  
note_to_radiologist| String  
internal_comment| String  
status| [OrderStatus](/sdk/data-enumeration-types/#orderstatus)  
date_time_ordered| DateTime  
ordering_provider| [Staff](/sdk/data-staff/#staff)  
priority| String  
delegated| Boolean  
task_ids| String  
###  ImagingReview #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
patient_communication_method| [ReviewPatientCommunicationMethod](/sdk/data-
enumeration-types/#reviewpatientcommunicationmethod)  
internal_comment| String  
message_to_patient| String  
is_released_to_patient| Boolean  
status| [ReviewStatus](/sdk/data-enumeration-types/#reviewstatus)  
patient| [Patient](/sdk/data-patient/#patient)  
###  ImagingReport #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
review_mode| [DocumentReviewMode](/sdk/data-enumeration-
types/#documentreviewmode)  
junked| Boolean  
requires_signature| Boolean  
assigned_date| DateTime  
patient| [Patient](/sdk/data-patient/#patient)  
order| ImagingOrder  
source| ImagingReportSource  
name| String  
result_date| Date  
original_date| Date  
review| ImagingReview  
##  Enumeration types #
###  ImagingReportSource #
Value| Label  
---|---  
RADIOLOGY_PATIENT| Radiology Report From Patient  
VERBAL_PATIENT| Verbal Report From Patient  
DIRECTLY_RADIOLOGY| Directly Radiology Report  
----- END PAGE https://docs.canvasmedical.com/sdk/data-imaging/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-labs/
# Labs
Last updated: 7 Nov 2025
##  Introduction #
The Canvas SDK provides comprehensive models for working with laboratory data
throughout the entire lab workflowâfrom ordering tests to reviewing results.
The primary models include:
  * **`LabOrder`** : Represents a lab order placed for a patient, including order details, transmission type, and associated tests
  * **`LabTest`** : Individual tests within a lab order, tracking status from creation through processing
  * **`LabReport`** : Contains the results returned from the lab, including all values and associated metadata
  * **`LabValue`** : Individual test results within a lab report, including values, units, and reference ranges
  * **`LabReview`** : Tracks the clinical review process for lab results, including provider comments and patient communication
##  Basic Usage #
To retrieve a `LabReport` model by id, use the `objects.get` method on the
model. For example:
    from canvas_sdk.v1.data.lab import LabReport
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
##  Filtering #
To retrieve the `LabValue` instances that are associated with the `LabReport`,
you can either call the `values` on the `LabReport` instance:
    from canvas_sdk.v1.data.lab import LabReport
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = lab_report.values.all()
Or query the `LabValue` model and pass the `report` argument:
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
Additionally, codings for lab values can be attained by querying the
`LabValueCoding` model. To retrieve the codings associated with a `LabValue`,
you can call `codings` on the `LabValue` instance:
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
    for value in lab_values:
        log.info(value.codings.all())
Or query the `LabValueCoding` model directly:
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport, LabValue, LabValueCoding
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
    for value in lab_values:
        lab_value_codings = LabValueCoding.objects.filter(value=value)
        log.info(lab_value_codings)
To query all lab reports for a particular patient, the `patient` argument can
be used:
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    lab_report = LabReport.objects.filter(patient=patient)
##  Example #
The following plugin code will run every time a new Lab Report is created and
log the patient it is for, along with the values and codings from the
reportâs results:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.LAB_REPORT_CREATED)
        def compute(self):
            lab_report = LabReport.objects.select_related("patient").get(id=self.target)
            if lab_report.patient:
                log.info(f"{lab_report.patient.first_name} {lab_report.patient.last_name}")
            for value in lab_report.values.all():
                log.info(f"{value.value} {value.units}")
                for coding in value.codings.all():
                    log.info(coding.system)
                    log.info(coding.name)
                    log.info(coding.code)
            return []
For complete field documentation on all lab models, see the Attributes section
below.
###  Working with Lab Orders and Tests #
You can also work with lab orders and their associated tests. Hereâs an
example of querying a lab order and checking the status of its tests:
    from canvas_sdk.v1.data.lab import LabOrder, LabTest
    # Get a lab order by ID
    lab_order = LabOrder.objects.get(id="abc123...")
    # Access all tests in the order
    for test in lab_order.tests.all():
        print(f"Test: {test.ontology_test_name}")
        print(f"Status: {test.status}")
        print(f"Code: {test.ontology_test_code}")
        # Check if results have been received
        if test.report:
            print(f"Report available with {test.report.values.count()} values")
###  Navigating Between Lab Orders and Reports #
Lab orders and lab reports are connected through the `LabTest` model. Hereâs
how to navigate between them:
####  Getting the LabOrder from a LabReport #
    from canvas_sdk.v1.data.lab import LabReport
    # Get a lab report
    lab_report = LabReport.objects.get(id="report-id")
    # Direct access to all orders via the reverse many-to-many relationship
    for lab_order in lab_report.laborder_set.all():
        print(f"Order ID: {lab_order.id}")
        print(f"Ordered by: {lab_order.ordering_provider.full_name if lab_order.ordering_provider else 'N/A'}")
        print(f"Date ordered: {lab_order.date_ordered}")
    # Alternatively, access the order through the tests
    for test in lab_report.tests.all():
        lab_order = test.order
        print(f"Order ID: {lab_order.id}")
        break  # Usually all tests in a report share the same order
####  Getting LabReports from a LabOrder #
    from canvas_sdk.v1.data.lab import LabOrder
    # Get a lab order
    lab_order = LabOrder.objects.get(id="order-id")
    # Direct access to all reports via the many-to-many relationship
    for report in lab_order.reports.all():
        print(f"Report ID: {report.id}")
        print(f"Date performed: {report.date_performed}")
        print(f"Number of values: {report.values.count()}")
    # Alternatively, access reports through the tests if you need test-level details
    for test in lab_order.tests.all():
        if test.report:
            print(f"Test: {test.ontology_test_name}")
            print(f"Report ID: {test.report.id}")
###  Working with Lab Reviews #
Lab reviews track the clinical review process for lab results, including
provider comments and patient communication. Hereâs how to work with the
LabReport and LabReview relationship:
####  Accessing the Review from a LabReport #
    from canvas_sdk.v1.data.lab import LabReport
    # Get a lab report
    lab_report = LabReport.objects.get(id="report-id")
    # Check if the report has been reviewed
    if lab_report.review:
        lab_review = lab_report.review
        print(f"Review status: {lab_review.status}")
        print(f"Internal comment: {lab_review.internal_comment}")
        print(f"Message to patient: {lab_review.message_to_patient}")
        # Access the provider who reviewed it
        if lab_review.originator:
            print(f"Reviewed by: {lab_review.originator.full_name}")
    else:
        print("Report has not been reviewed yet")
####  Accessing Reports from a LabReview #
    from canvas_sdk.v1.data.lab import LabReview
    # Get a lab review
    lab_review = LabReview.objects.get(id="review-id")
    # Access all reports in this review batch
    for report in lab_review.reports.all():
        print(f"Report ID: {report.id}")
        print(f"Date performed: {report.date_performed}")
        print(f"Number of values: {report.values.count()}")
        # Check if this report requires signature
        if report.requires_signature:
            print("  â ï¸  Requires provider signature")
####  Finding Unreviewed Lab Reports #
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.patient import Patient
    # Get all unreviewed lab reports for a patient
    patient = Patient.objects.get(id="patient-id")
    unreviewed_reports = LabReport.objects.filter(
        patient=patient,
        review__isnull=True,
        deleted=False
    )
    print(f"Found {unreviewed_reports.count()} unreviewed reports")
    for report in unreviewed_reports:
        print(f"Report from {report.date_performed} - {report.values.count()} values")
###  Filtering Lab Results by Abnormal Values #
A common use case is to identify abnormal lab values that may require clinical
attention:
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    from canvas_sdk.v1.data.patient import Patient
    # Get all lab reports for a patient
    patient = Patient.objects.get(id="patient-id")
    lab_reports = LabReport.objects.filter(patient=patient)
    # Find all abnormal values
    for report in lab_reports:
        abnormal_values = report.values.filter(abnormal_flag__isnull=False).exclude(abnormal_flag="")
        if abnormal_values.exists():
            print(f"Report from {report.date_performed}:")
            for value in abnormal_values:
                for coding in value.codings.all():
                    print(f"  {coding.name}: {value.value} {value.units} (Flag: {value.abnormal_flag})")
##  Attributes #
###  LabReport #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
review_mode| String  
junked| Boolean  
requires_signature| Boolean  
assigned_date| DateTime  
patient| [Patient](/sdk/data-patient/#patient)  
transmission_type| TransmissionType  
for_test_only| Boolean  
external_id| String  
version| Integer  
requisition_number| String  
review| LabReview  
original_date| DateTime  
date_performed| DateTime  
custom_document_name| String  
originator| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
values| LabValue[]  
###  LabReview #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
internal_comment| String  
message_to_patient| String  
status| String  
patient| [Patient](/sdk/data-patient/#patient)  
patient_communication_method| String  
reports| LabReport[]  
tests| LabTest[]  
###  LabValue #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
report| LabReport  
value| String  
units| String  
abnormal_flag| String  
reference_range| String  
low_threshold| String  
high_threshold| String  
comment| String  
observation_status| String  
codings| LabValueCoding[]  
###  LabValueCoding #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
value| LabValue  
code| String  
name| String  
system| String  
###  LabOrder #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
note| [Note](/sdk/data-note/#note)  
ontology_lab_partner| String  
ordering_provider| [Staff](/sdk/data-staff/#staff)  
comment| String  
requisition_number| String  
is_patient_bill| Boolean  
date_ordered| DateTime  
fasting_status| Boolean  
specimen_collection_type| SpecimenCollectionType  
transmission_type| TransmissionType  
courtesy_copy_type| CourtesyCopyType  
courtesy_copy_number| String  
courtesy_copy_text| String  
parent_order| LabOrder  
healthgorilla_id| String  
manual_processing_status| ManualProcessingStatus  
manual_processing_comment| String  
labcorp_abn_url| URL  
reasons| LabOrderReason[]  
tests| LabTest[]  
reports| LabReport[]  
###  LabOrderReason #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
order| LabOrder  
mode| LabReasonMode  
reason_conditions| LabOrderReasonCondition[]  
###  LabOrderReasonCondition #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
reason| LabOrderReason  
condition| [Condition](/sdk/data-condition)  
###  LabTest #
Represents an individual test within a lab order. Each `LabTest` tracks the
lifecycle of a specific test from order creation through processing and result
receipt.
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
ontology_test_name| String  
ontology_test_code| String  
status| LabTestOrderStatus  
report| LabReport  
specimen_type| String  
specimen_source_code| String  
specimen_source_description| String  
specimen_source_coding_system| String  
order| LabOrder  
aoe_code| String  
procedure_class| String  
##  Enumeration types #
###  TransmissionType #
Value| Label  
---|---  
F| fax  
H| hl7  
M| manual  
###  SpecimenCollectionType #
Value| Label  
---|---  
L| on location  
P| patient service center  
O| other  
###  CourtesyCopyType #
Value| Label  
---|---  
A| account  
F| fax  
P| patient  
###  ManualProcessingStatus #
Value| Label  
---|---  
NEEDS_REVIEW| Needs Review  
IN_PROGRESS| In Progress  
PROCESSED| Processed  
FLAGGED| Flagged  
###  LabReasonMode #
Value| Label  
---|---  
MO| monitor  
IN| investigate  
SF| screen for  
UNK| unknown  
###  LabTestOrderStatus #
Value| Label  
---|---  
NE| new  
SR| staged for requisition  
SE| sending  
SF| sending failed  
PR| processing  
PF| processing failed  
RE| received  
RV| reviewed  
IN| inactive  
----- END PAGE https://docs.canvasmedical.com/sdk/data-labs/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-lab-partner-and-test/
# LabPartner & LabPartnerTest
Last updated: 24 Sep 2025
##  Introduction #
The **LabPartner** and **LabPartnerTest** models represent external lab
partners and the tests they offer within Canvas.
* * *
##  LabPartner #
The `LabPartner` model stores information about a lab partner
###  Basic Usage #
To retrieve a lab partner by its unique identifier:
    from canvas_sdk.v1.data.lab import LabPartner
    lab_partner = LabPartner.objects.get(id="your-uuid-here")
You can also filter lab partners by attributes. For example, to list all
active lab partners:
    from canvas_sdk.v1.data.lab import LabPartner
    active_lab_partners = LabPartner.objects.filter(active=True)
##  LabPartnerTest #
The `LabPartnerTest` model represents a test offered by a lab partner. Each
test is linked to a lab partner via a foreign key.
###  Basic Usage #
To retrieve tests for a given lab partner, you can access the related tests
using the reverse relationship:
    from canvas_sdk.v1.data.lab import LabPartner
    lab_partner = LabPartner.objects.get(id="your-uuid-here")
    tests = lab_partner.available_tests.all()
Alternatively, you can directly filter tests by attributes:
    from canvas_sdk.v1.data.lab import LabPartnerTest
    tests_with_code = LabPartnerTest.objects.filter(order_code="XYZ123")
##  Attributes #
###  LabPartner #
Field Name| Type| Description  
---|---|---  
id| UUID| The universally unique identifier for the lab partner.  
dbid| Integer| The internal database identifier (primary key) for the lab
partner.  
name| String| The name of the lab partner.  
active| Boolean| Indicates whether the lab partner is currently active.  
electronic_ordering_enabled| Boolean| Indicates if electronic ordering is
enabled for this lab partner.  
keywords| Text| Keywords associated with the lab partner.  
default_lab_account_number| String| The default lab account number used for
orders.  
###  LabPartnerTest Attributes #
Field Name| Type| Description  
---|---|---  
id| UUID| The universally unique identifier for the test record.  
dbid| Integer| The internal database identifier (primary key) for the test
record.  
lab_partner| ForeignKey| A reference to the related `LabPartner` (accessible
via the related name `available_tests`).  
order_code| String| A code used to identify the test order. May be blank.  
order_name| Text| The name of the test order.  
keywords| Text| Keywords associated with the test. May be blank.  
cpt_code| String| The CPT code for the test, if available. Can be blank or
null.  
----- END PAGE https://docs.canvasmedical.com/sdk/data-lab-partner-and-test/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-medication/
# Medication
Last updated: 24 Sep 2025
##  Introduction #
The `Medication` model represents a record of a medication that is being
consumed by a patient, either now, in the past, or in the future. `Medication`
records can represent both prescriptions and medication statements for a
patient.
##  Basic usage #
To get a medication by identifier, use the `get` method on the `Medication`
model manager:
    from canvas_sdk.v1.data.medication import Medication
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the medications for a patient can be accessed
with the `medications` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    medications = patient.medications.all()
If you have a patient ID, you can get the medications for the patient with the
`for_patient` method on the `Medication` model manager:
    from canvas_sdk.v1.data.medication import Medication
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    medication = Medication.objects.for_patient(patient_id)
#  Codings #
The codings for a medication can be accessed with the `codings` attribute on
an `Medication` object:
    from canvas_sdk.v1.data.medication import Medication
    from logger import log
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in medication.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
##  Filtering #
Medications can be filtered by any attribute that exists on the model.
Filtering for medications is done with the `filter` method on the `Medication`
model manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.medication import Medication
    medications = Medication.objects.filter(status="active")
###  By ValueSet #
Filtering by ValueSet works a little differently. The `find` method on the
model manager is used to perform `ValueSet` filtering:
    from canvas_sdk.v1.data.medication import Medication
    from canvas_sdk.value_set.v2022.medication import AdhdMedications
    medications = Medication.objects.find(AdhdMedications)
##  Attributes #
###  Medication #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
patient| [Patient](/sdk/data-patient/#patient)  
deleted| Boolean  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
status| String  
start_date| Date  
end_date| Date  
quantity_qualifier_description| String  
clinical_quantity_description| String  
potency_unit_code| String  
national_drug_code| String  
erx_quantity| String  
codings| MedicationCoding[]  
medication_statements| [MedicationStatement](/sdk/data-medication-statement)[]  
stopmedicationevent_set| [StopMedicationEvent](/sdk/data-stop-medication-
event)[]  
###  MedicationCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
medication| Medication  
----- END PAGE https://docs.canvasmedical.com/sdk/data-medication/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-message/
# Message
Last updated: 16 Oct 2025
#  Message Models #
The Canvas SDK defines messaging-related data models for sending, receiving,
and tracking messages.
##  TransmissionChannel #
A `TextChoices` enum representing the available channels for transmitting
messages.
Member| Value| Description  
---|---|---  
`MANUAL`| `manual`| Manual  
`TEXT_MESSAGE`| `sms`| Text Message  
`EMAIL`| `email`| Email  
`NOOP`| `noop`| No-op  
##  Message #
Represents an individual message record.
###  Fields #
Name| Type| Description  
---|---|---  
`id`| `UUIDField`| Unique identifier for the message.  
`dbid`| `BigIntegerField`| Database primary key.  
`created`| `DateTimeField`| Timestamp when the message was created.  
`modified`| `DateTimeField`| Timestamp when the message was last modified.  
`content`| `TextField`| The body text of the message.  
`sender`| `ForeignKey(CanvasUser)`| The user who sent the message. May be
null.  
`recipient`| `ForeignKey(CanvasUser)`| The user who received the message. May
be null.  
`note`| `ForeignKey(Note)`| Associated note (if any) for contextual linkage.
May be null.  
`read`| `DateTimeField`| Timestamp when the recipient read the message. Null
if unread.  
##  MessageAttachment #
Represents a file attachment linked to a message.
###  Fields #
Name| Type| Description  
---|---|---  
`id`| `UUIDField`| Unique identifier for the attachment.  
`dbid`| `BigIntegerField`| Database primary key.  
`file`| `TextField`| Storage path or identifier for the file.  
`content_type`| `CharField(max_length=255)`| MIME type of the attachment.  
`message`| `ForeignKey(Message)`| The parent message to which this belongs.  
##  MessageTransmission #
Tracks delivery attempts and status for a message.
###  Fields #
Name| Type| Description  
---|---|---  
`id`| `UUIDField`| Unique identifier for the transmission record.  
`dbid`| `BigIntegerField`| Database primary key.  
`created`| `DateTimeField`| Timestamp when the transmission was created.  
`modified`| `DateTimeField`| Timestamp when the transmission was last
modified.  
`message`| `ForeignKey(Message)`| The message associated with this
transmission.  
`delivered`| `BooleanField`| Whether delivery was successful.  
`failed`| `BooleanField`| Whether delivery failed.  
`contact_point_system`| `CharField(choices=TransmissionChannel)`| The channel
used for delivery.  
`contact_point_value`| `CharField(max_length=255)`| The destination address or
identifier (e.g., phone, email).  
`comment`| `TextField`| Optional comments or error details.  
`delivered_by`| `ForeignKey(Staff)`| The staff member who processed the
delivery. May be null.
----- END PAGE https://docs.canvasmedical.com/sdk/data-message/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-note/
# Note
Last updated: 7 Nov 2025
##  Introduction #
The `Note` model represents clinical notes that appear on a patientâs chart.
A `Note` can contain multiple [commands](/sdk/data-command).
##  Basic usage #
###  Retrieve a specific note #
To get a note by identifier, use the `get` method on the `Note` model manager:
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
###  Find all notes for a patient #
If you have a patient object, the notes for a patient can be found using the
`notes` attribute on the `Patient` instance:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    patient_notes = patient.notes.all()
###  Retrieve the content of commands in a note #
If you have a note object, the [commands](/sdk/data-command) for that note can
be found using the `commands` attribute on the `Note` instance:
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    note_commands = note.commands.all()
You can also filter commands by their state or other attributes:
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Get only committed commands
    committed_commands = note.commands.filter(state="committed")
    # Get commands by schema_key (e.g., prescriptions)
    prescriptions = note.commands.filter(schema_key="prescribe")
To access the content of a command, use the `data` attribute which contains a
JSON object with the commandâs data:
    import json
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    for command in note.commands.all():
        # Get the command type
        command_type = command.schema_key
        # Get the command data as a dictionary
        command_data = command.data
        # Pretty print the command data
        print(f"Command Type: {command_type}")
        print(json.dumps(command_data, indent=2))
For more information about command types and their data structure, see the
[Command](/sdk/data-command/) documentation.
###  Understanding the note body structure #
The `body` field of a note contains a JSON array that represents the structure
and layout of the note. It intermixes text content with references to
commands:
    import json
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # The body is an array of objects
    print(json.dumps(note.body, indent=2))
The body array contains objects of two types:
  1. **Text objects** : Represent free-form text content
         {"type": "text", "value": "Patient reports feeling better"}
  2. **Command objects** : Reference commands with their metadata
         {
           "type": "command",
           "value": "reasonForVisit",
           "data": {
             "id": 1095,
             "command_uuid": "691123c4-6c7d-415b-880b-2beefab9f64a"
           }
         }
The `command_uuid` in a command object corresponds to the `id` field of the
[Command](/sdk/data-command/) model, allowing you to retrieve the full command
data:
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.command import Command
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Find all command references in the note body
    for item in note.body:
        if item.get("type") == "command":
            command_uuid = item["data"]["command_uuid"]
            command = Command.objects.get(id=command_uuid)
            print(f"Command type: {command.schema_key}")
            print(f"Command data: {command.data}")
###  Retrieve the audit history for a note #
The audit history for a note can be found using the
[`NoteStateChangeEvent`](/sdk/data-note/#notestatechangeevent) model. You can
access this model directly or through the `state_history` relation on the note
object.
    from canvas_sdk.v1.data.note import Note, NoteStateChangeEvent
    note = Note.objects.first()
    # Use the state_history relation
    option_1 = note.state_history.all()
    # Use the note object to filter the QuerySet
    option_2 = NoteStateChangeEvent.objects.filter(note=note)
    # Use the note's UUID to filter the QuerySet, which joins to the note table
    # where the note's dbid column is equal to the note_id column of the note
    # state change event and the note's id column is equal to the note's UUID.
    option_3 = NoteStateChangeEvent.objects.filter(note__id=note.id)
    # Use the note's auto-increment database id to filter the QuerySet by the
    # foreign key column without joining to the notes table.
    option_4 = NoteStateChangeEvent.objects.filter(note_id=note.dbid)
In the above code sample, options 1, 2, and 4 produce identical SQL queries.
###  Determine if a note is locked #
To see if a note is presently locked, you can use the
[`CurrentNoteStateEvent`](/sdk/data-note/#currentnotestateevent) model to
check if the current note state is âLockedâ. (See: [NoteState](/sdk/data-
note/#notestates) for an explanation of the different note states you might
encounter)
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent, NoteStates
    note = Note.objects.first()
    # You can retrieve the CurrentNoteStateEvent record for the note and check its
    # state attribute.
    if CurrentNoteStateEvent.objects.get(note=note).state == NoteStates.LOCKED:
        # This note is locked!
        pass
    # You can skip retrieving the record by just checking if a
    # CurrentNoteStateEvent record exists for that note with the state 'Locked'.
    if CurrentNoteStateEvent.objects.filter(note=note, state=NoteStates.LOCKED).exists():
        # This note is locked!
        pass
###  Find all open notes #
You can find all open notes by retrieving the note records with a current
state which indicates it can be edited. (See list below)
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent, NoteStates
    open_note_states = [
        NoteStates.NEW,
        NoteStates.PUSHED,
        NoteStates.CONVERTED,
        NoteStates.UNLOCKED,
        NoteStates.RESTORED,
        NoteStates.UNDELETED,
    ]
    # This will execute one query per CurrentNoteStateEvent object returned
    open_notes_via_list_comprehension = [event.note for event in CurrentNoteStateEvent.objects.filter(state__in=open_note_states)]
    # This will always execute two queries: one to find the note ids of open
    # notes, and a second query to fetch the note records by the ids returned in the
    # first query
    open_note_ids = CurrentNoteStateEvent.objects.filter(state__in=open_note_states).values_list('note_id', flat=True)
    open_notes_via_multiple_queries = Note.objects.filter(dbid__in=open_note_ids)
###  Get the current state of a given note #
To get a noteâs current state, retrieve its
[`CurrentNoteStateEvent`](/sdk/data-note/#currentnotestateevent) and check the
`state` attribute. If you are trying to assess if the current note state
represents that note as being editable, you can call the `editable()` method
on the `CurrentNoteStateEvent` object.
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent
    note = Note.objects.first()
    current_note_state = CurrentNoteStateEvent.objects.get(note=note).state
    is_editable = current_note_state.editable()
###  Get the current claim of a given note #
You can retrieve the current claim using the method `get_claim()` presented in
the Note object.
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.first()
    claim = note.get_claim()
###  Get the NoteType of a given note #
To get the note type for a specific note, use the `note_type_version`
attribute which provides access to the related `NoteType` object:
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Get the note type name (e.g., "Office Visit")
    note_type_name = note.note_type_version.name
    # Access other note type attributes
    note_type_display = note.note_type_version.display
    note_type_code = note.note_type_version.code
    note_type_system = note.note_type_version.system
##  Filtering #
###  By attribute #
Notes can also be filtered by attribute. For example, to get all notes for a
patient where the `datetime_of_service` is after a certain date, the following
code can be used:
    import arrow
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    recent_notes = Note.objects.filter(
        patient=patient,
        datetime_of_service__gte=arrow.now().shift(weeks=-3).datetime
    )
The `NoteType` model can also be used to find notes by type.
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.note import NoteType
    from canvas_sdk.v1.data.patient import Patient
    note_type = NoteType.objects.get(name="Office visit")
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    patient_office_visits = Note.objects.filter(patient=patient, note_type_version=note_type)
##  Attributes #
###  Note #
Field Name| Type| Notes  
---|---|---  
id| UUID| Â  
dbid| Integer| Â  
created| DateTime| Â  
modified| DateTime| Â  
patient| [Patient](/sdk/data-patient/#patient)| Â  
note_type_version| NoteType| Â  
title| String| Â  
body| JSON| Array of objects representing the note structure. Each object has
a `type` (either `"text"` or `"command"`) and a `value`. Command objects also
include a `data` field with `id` and `command_uuid`.  
originator| [CanvasUser](/sdk/data-canvasuser)| Â  
provider| [Staff](/sdk/data-staff/#staff)| Â  
checksum| String| Â  
billing_note| String| Â  
related_data| JSON| Can contain one key, `roomNumber`, if the Note is an
inpatient stay.  
datetime_of_service| DateTime| Â  
place_of_service| String| Â  
encounter| [Encounter](/sdk/data-encounter)| Â  
commands| QuerySet[[Command](/sdk/data-command)]| All commands associated with
this note  
###  NoteType #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
name| String  
icon| String  
category| NoteTypeCategories  
rank| Integer  
is_default_appointment_type| Boolean  
is_scheduleable| Boolean  
is_telehealth| Boolean  
is_billable| Boolean  
defer_place_of_service_to_practice_location| Boolean  
available_places_of_service| Array[PracticeLocationPOS]  
default_place_of_service| PracticeLocationPOS  
is_system_managed| Boolean  
is_visible| Boolean  
is_active| Boolean  
unique_identifier| UUID  
deprecated_at| DateTime  
is_patient_required| Boolean  
allow_custom_title| Boolean  
###  NoteStateChangeEvent #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
note| [Note](/sdk/data-note/)  
originator| [CanvasUser](/sdk/data-canvasuser)  
state| [NoteState](/sdk/data-note/#notestates)  
note_state_document| String  
note_state_html| String  
###  CurrentNoteStateEvent #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
state| [NoteState](/sdk/data-note/#notestates)  
note| [Note](/sdk/data-note/)  
##  Enumeration types #
###  NoteStates #
Value| Description| Notes  
---|---|---  
NEW| Created| Â  
PSH| Pushed the charges for| Â  
LKD| Locked| Â  
ULK| Unlocked| Â  
DLT| Deleted| Â  
RLK| Relocked| Â  
RST| Restored| Â  
RCL| Recalled| Â  
UND| Undeleted| Â  
DSC| Discharged| Â  
SCH| Scheduling| Used in appointment notes  
BKD| Booked| Used in appointment notes  
CVD| Converted| Used in appointment notes  
CLD| Canceled| Used in appointment notes  
NSW| No show| Used in appointment notes  
RVT| Reverted| Used in appointment notes  
CNF| Confirmed| Used for CCDA import notes  
###  NoteTypeCategories #
Value| Description  
---|---  
message| Message  
letter| Letter  
inpatient| Inpatient Visit Note  
review| Chart Review Note  
encounter| Encounter Note  
appointment| Appointment Note  
task| Task  
data| Data  
ccda| C-CDA  
schedule_event| Schedule Event  
###  PracticeLocationPOS #
Value| Description  
---|---  
01| Pharmacy  
02| Telehealth  
03| Education Facility  
04| Homeless Shelter  
09| Prison  
10| Telehealth in Patientâs Home  
11| Office  
12| Home  
13| Asssisted Living Facility  
14| Group Home  
15| Mobile Unit  
17| Walk-In Retail Health Clinic  
19| Off-Campus Outpatient Hospital  
20| Urgent Care Facility  
21| Inpatient Hospital  
22| On-Campus Outpatient Hospital  
23| Emergency Room Hospital  
24| Ambulatory Surgery Center  
25| Birthing Center  
26| Military Treatment Facility  
27| Outreach Site / Street  
31| Skilled Nursing Facility  
32| Nursing Facility  
33| Custodial Care Facility  
34| Hospice  
41| Ambulance Land  
42| Ambulance Air or Water  
49| Independent Clinic  
50| Federally Qualified Health Center  
51| Inpatient Psychiatric Facility  
52| Inpatient Psychiatric Facility - Partial Hospitalization  
53| Community Mental Health Center  
54| Intermediate Care Facility for Mentally Retarded  
55| Residential Substance Abuse Treatment Facility  
56| Psychiatric Residential Treatment Center  
57| Non-Residential Substance Abuse Treatment Facility  
60| Mass Immunization Center  
61| Inpatient Rehabilitation Facility  
62| Outpatient Rehabilitation Facility  
65| End-Stage Renal Disease Treatment Facility  
71| State or Local Public Health Clinic  
72| Rural Health Clinic  
81| Independent Laboratory  
99| Other Place of Service
----- END PAGE https://docs.canvasmedical.com/sdk/data-note/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-observation/
# Observation
Last updated: 8 Apr 2025
##  Introduction #
The `Observation` model represents measurements or assertions made about a
patient, such as vital signs, lab results, or other clinical findings.
##  Basic usage #
To get an observation by identifier, use the `get` method on the `Observation`
model manager:
    from canvas_sdk.v1.data.observation import Observation
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the observations for a patient can be accessed
with the `observations` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    observations = patient.observations.all()
If you have a patient ID, you can get the observations for the patient with
the `for_patient` method on the `Observation` model manager:
    from canvas_sdk.v1.data.observation import Observation
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    observations = Observation.objects.for_patient(patient_id)
##  Codings #
The codings for an observation can be accessed with the `codings` attribute on
an `Observation` object:
    from canvas_sdk.v1.data.observation import Observation
    from logger import log
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in observation.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
##  Components #
The components for an observation can be accessed with the `components`
attribute on an `Observation` object:
    from canvas_sdk.v1.data.observation import Observation
    from logger import log
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for component in observation.components.all():
        log.info(f"name: {component.name}")
        log.info(f"value: {component.value_quantity}")
        log.info(f"unit: {component.value_quantity_unit}")
###  Component codings #
Component codings can be accessed similarly to codings on the observation, by
using the `codings` attribute on an `ObservationComponent` object.
##  Filtering #
Observations can be filtered by any attribute that exists on the model.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.observation import Observation
    observations = Observation.objects.filter(effective_datetime__gte="2024-11-20")
###  By ValueSet #
Filtering by ValueSet works a little differently. The `find` method on the
model manager is used to perform `ValueSet` filtering:
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.value_set.v2022.physical_exam import Weight
    observations = Observation.objects.find(Weight)
##  Attributes #
###  Observation #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
originator| [CanvasUser](/sdk/data-canvasuser)  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
deleted| Boolean  
patient| [Patient](/sdk/data-patient/#patient)  
is_member_of| Observation  
category| String  
units| String  
value| String  
note_id| Integer  
name| String  
effective_datetime| DateTime  
codings| ObservationCoding[]  
members| Observation[]  
components| ObservationComponent[]  
value_codings| ObservationValueCoding[]  
###  ObservationCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
observation| Observation  
###  ObservationComponent #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
observation| Observation  
value_quantity| String  
value_quantity_unit| String  
name| String  
codings| ObservationComponentCoding[]  
###  ObservationComponentCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
observation_component| ObservationComponent  
###  ObservationValueCoding #
Field Name| Type  
---|---  
dbid| Integer  
system| String  
version| String  
code| String  
display| String  
user_selected| Boolean  
observation| Observation  
----- END PAGE https://docs.canvasmedical.com/sdk/data-observation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-organization/
# Organization
Last updated: 24 Sep 2025
##  Introduction #
The `Organization` model represents the overall Organization in a Canvas EMR
instance. An `Organization` can have multiple related [Practice
Locations](/sdk/data-practicelocation).
##  Basic usage #
Canvas instances can contain only a single `Organization` entry. To retrieve
the `Organization` entry, you can either query by the organizationâs name:
    from canvas_sdk.v1.data.organization import Organization
    organization = Organization.objects.get(full_name="Medical Organization")
Or since there will only be one `Organization` in an instance, it can also be
fetched by using the `first` method:
    from canvas_sdk.v1.data.organization import Organization
    organization = Organization.objects.first()
##  Attributes #
###  Organization #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
full_name| String  
short_name| String  
subdomain| String  
logo_url| String  
background_image_url| String  
background_gradient| String  
active| Boolean  
tax_id| String  
tax_id_type| [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
group_npi_number| String  
group_taxonomy_number| String  
include_zz_qualifier| Boolean  
----- END PAGE https://docs.canvasmedical.com/sdk/data-organization/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-patient/
# Patient
Last updated: 13 Nov 2025
##  Introduction #
The `Patient` model represents an individual receiving care or other health-
related services.
##  Basic usage #
To get a patient by identifier, use the `get` method on the `Patient` model
manager:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="b80b1cdc2e6a4aca90ccebc02e683f35")
##  Filtering #
Patients can be filtered by any attribute that exists on the model.
Filtering for patients is done with the `filter` method on the `Patient` model
manager.
###  By attribute #
Specify attributes with `filter` to filter by those attributes:
    from canvas_sdk.v1.data.patient import Patient
    patients = Patient.objects.filter(first_name="Bob", last_name="Loblaw", birth_date="1960-09-22")
##  Attributes #
###  Patient #
Field Name| Type  
---|---  
id| String  
dbid| Integer  
first_name| String  
last_name| String  
birth_date| Date  
sex_at_birth| SexAtBirth  
created| DateTime  
modified| DateTime  
prefix| String  
suffix| String  
middle_name| String  
maiden_name| String  
nickname| String  
sexual_orientation_term| String  
sexual_orientation_code| String  
gender_identity_term| String  
gender_identity_code| String  
preferred_pronouns| String  
biological_race_codes| Array[String]  
cultural_ethnicity_codes| Array[String]  
last_known_timezone| String  
mrn| String  
active| Boolean  
deceased| Boolean  
deceased_datetime| DateTime  
deceased_cause| String  
deceased_comment| String  
other_gender_description| String  
social_security_number| String  
administrative_note| String  
clinical_note| String  
mothers_maiden_name| String  
multiple_birth_indicator| Boolean  
birth_order| Integer  
default_location_id| Integer  
default_provider_id| Integer  
addresses| PatientAddress[]  
allergy_intolerances| [AllergyIntolerance](/sdk/data-allergy-
intolerance/#allergyintolerance)[]  
billing_line_items| [BillingLineItem](/sdk/data-billing-line-item/)  
business_line| [BusinessLine](/sdk/data-business-line/)  
care_team_memberships| [CareTeamMembership](/sdk/data-care-
team/#careteammembership)[]  
conditions| [Condition](/sdk/data-condition/#condition)[]  
coverages| [Coverage](/sdk/data-coverage/#coverage)[]  
dependent_coverages| [Coverage](/sdk/data-coverage/#coverage)[]  
detected_issues| [DetectedIssue](/sdk/data-detected-issue/#detectedissue)[]  
devices| [Device](/sdk/data-device/#device)[]  
external_identifiers| PatientExternalIdentifier[]  
imaging_orders| [ImagingOrder](/sdk/data-imaging/#imagingorder)[]  
imaging_reports| [ImagingReport](/sdk/data-imaging/#imagingreport)[]  
imaging_reviews| [ImagingReview](/sdk/data-imaging/#imagingreview)[]  
interviews| [Interview](/sdk/data-questionnaire/#interview)[]  
lab_orders| [LabOrder](/sdk/data-labs/#laborder)[]  
lab_reports| [LabReport](/sdk/data-labs/#labreport)[]  
lab_reviews| [LabReview](/sdk/data-labs/#labreview)[]  
medications| [Medication](/sdk/data-medication/#medication)[]  
metadata| PatientMetadata[]  
observations| [Observation](/sdk/data-observation/#observation)[]  
preferred_pharmacy| JSON  
protocol_overrides| [ProtocolOverride](/sdk/data-protocol-
override/#protocoloverride)[]  
settings| PatientSetting  
subscribed_coverages| [Coverage](/sdk/data-coverage/#coverage)[]  
tasks| [Task](/sdk/data-task/#task)[]  
telecom| PatientContactPoint[]  
user| [CanvasUser](/sdk/data-canvasuser/)[]  
###  PatientAddress #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
line1| String  
line2| String  
city| String  
district| String  
state_code| String  
postal_code| String  
use| [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type| [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude| Float  
latitude| Float  
start| Date  
end| Date  
country| String  
state| String  
patient| Patient  
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_addresses = patient.addresses.all()
    for addr in patient_addresses:
      log.info(f"Patient address: {addr.city}, {addr.state_code}, {addr.postal_code}") # Seattle, WA, 98118
###  PatientContactPoint #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
system| [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value| String  
use| String  
use_notes| String  
rank| Integer  
state| [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
patient| Patient  
has_consent| Boolean  
last_verified| DateTime  
verification_token| String  
opted_out| Boolean  
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_contacts = patient.telecom.all()
    for contact in patient_contacts:
       log.info(f"Patient contact: {contact.system} - {contact.value}") # phone - 5555555555
###  PatientExternalIdentifier #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
patient| Patient  
use| String  
identifier_type| String  
system| String  
value| String  
issued_date| Date  
expiration_date| Date  
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_external_identifiers = patient.external_identifiers.all()
    for identifier in patient_external_identifiers:
       log.info(f"Patient external identifier: {identifier.system}, {identifier.value}")  # https://www.example.com - abc123
###  PatientSetting #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
patient| Patient  
name| String  
value| JSON  
###  PatientMetadata #
Field Name| Type  
---|---  
dbid| Integer  
patient| Patient  
key| String  
value| String  
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_metadata = patient.metadata.all()
    for metadata in patient_metadata:
       log.info(f"Patient metadata: {metadata.key}, {metadata.value}") # favorite_color - red
###  PatientFacilityAddress #
Field Name| Type  
---|---  
patientaddress| PatientAddress  
facility| Facility  
room_number| String  
##  Enumeration types #
###  SexAtBirth #
Value| Label  
---|---  
F| female  
M| male  
O| other  
UNK| unknown  
ââ (empty string)| ââ  
##  Computed Properties #
###  Patient #
  * `full_name`: The full name of the patient, combining first, middle, and last names.
  * `preferred_pharmacy`: The patientâs preferred pharmacy for medication fulfillment.
  * `preferred_full_name`: The patientâs preferred full name, if different from the legal name.
  * `preferred_first_name`: The patientâs preferred first name, if different from the legal first name.
  * `primary_phone_number`: The patientâs primary contact number.
----- END PAGE https://docs.canvasmedical.com/sdk/data-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-practicelocation/
# Practice Location
Last updated: 24 Sep 2025
##  Introduction #
The `PracticeLocation` model lists all the clinical practice locations that
fall under an [Organization](/sdk/data-organization).
##  Basic usage #
To query a `PracticeLocation` by name, the `filter` method can be used like
so:
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.filter(full_name__icontains="downtown")
To retrieve a list of all practice locations:
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_locations = PracticeLocation.objects.all()
Each `PracticeLocation` has location-specific settings that control certain
behavior within the EMR application. To retrieve the available settings for a
`PracticeLocation` instance, the `settings` attribute can be used to retrieve
a list of names:
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.first()
    available_settings = practice_location.settings.values_list('name', flat=True)
Additionally, a settingâs value can be found by accessing the `value`
attribute on the `PracticeLocationSetting`:
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.first()
    preferred_lab_partner_text = practice_location.settings.get(name="preferredLabPartner").value
Please note that the content of each `value` field can contain any value that
is JSON-serializable, which includes string values. This means that `value`
could be any of the Python types `string`, `list` or `dict`.
##  Attributes #
###  PracticeLocation #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
organization| [Organization](/sdk/data-organization/#organization)  
place_of_service_code| String  
full_name| String  
short_name| String  
background_image_url| String  
background_gradient| String  
active| Boolean  
npi_number| String  
bill_through_organization| Boolean  
tax_id| String  
tax_id_type| [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
billing_location_name| String  
group_npi_number| String  
taxonomy_number| String  
include_zz_qualifier| Boolean  
###  PracticeLocationSetting #
Field Name| Type  
---|---  
dbid| Integer  
practice_location| PracticeLocation  
name| String  
value| JSON
----- END PAGE https://docs.canvasmedical.com/sdk/data-practicelocation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-protocol-override/
# ProtocolOverride
Last updated: 8 Sep 2025
##  Introduction #
The `ProtocolOverride` model represents an instance of a protocol being
snoozed for a patient.
##  Basic usage #
To get a protocol override by identifier, use the `get` method on the
`ProtocolOverride` model manager:
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    protocol_override = ProtocolOverride.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a patient object, the protocol overrides for a patient can be
accessed with the `protocol_overrides` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    overrides = patient.protocol_overrides.all()
If you have a patient ID, you can get the protocol overrides for the patient
with the `for_patient` method on the `ProtocolOverride` model manager:
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    override = ProtocolOverride.objects.for_patient(patient_id)
##  Filtering #
Protocol overrides can be filtered by any attribute that exists on the model.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    overrides = ProtocolOverride.objects.filter(status="active")
##  Attributes #
###  ProtocolOverride #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
patient| [Patient](/sdk/data-patient/#patient)  
protocol_key| String  
is_adjustment| Boolean  
reference_date| DateTime  
cycle_in_days| Integer  
is_snooze| Boolean  
snooze_date| Date  
snoozed_days| Integer  
snooze_comment| String  
narrative| String  
cycle_quantity| Integer  
cycle_unit| IntervalUnit  
status| Status  
##  Enumeration types #
###  IntervalUnit #
Value| Label  
---|---  
days| days  
months| months  
years| years  
###  Status #
Value| Label  
---|---  
active| active  
inactive| inactive  
----- END PAGE https://docs.canvasmedical.com/sdk/data-protocol-override/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-questionnaire
# Questionnaire
Last updated: 21 Oct 2025
##  Introduction #
The `Questionnaire` model represents a structured set of questions intended to
guide the collection of answers from end-users.
The `Interview` model represents answers to a structured set of questions
represented by a `Questionnaire`.
##  Basic usage #
To get a questionnaire or interview by identifier, use the `get` method on the
`Questionnaire` or `Interview` model managers:
    from canvas_sdk.v1.data.questionnaire import Interview, Questionnaire
    questionnaire = Questionnaire.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    interview = Interview.objects.get(id="75df6d7f-d58d-443b-9fa0-ce43b4d7b2a0")
If you have a patient object, the interviews for a patient can be accessed
with the `interviews` attribute on a `Patient` object:
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    interviews = patient.interviews.all()
If you have a patient ID, you can get the interviews for the patient with the
`for_patient` method on the `Interview` model manager:
    from canvas_sdk.v1.data.questionnaire import Interview
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    interviews = Interview.objects.for_patient(patient_id)
##  Questionnaire questions #
The questions for a questionnaire can be accessed with the `questions`
attribute on an `Questionnaire` object:
    from canvas_sdk.v1.data.questionnaire import Questionnaire
    from logger import log
    questionnaire = Questionnaire.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for question in questionnaire.questions.all():
        log.info(f"system: {question.code_system}")
        log.info(f"code: {question.code}")
        log.info(f"name: {question.name}")
##  Interview responses #
The interview responses for an interview can be accessed with the
`interview_responses` attribute on an `Interview` object:
    from canvas_sdk.v1.data.questionnaire import Interview
    from logger import log
    interview = Interview.objects.get(id="75df6d7f-d58d-443b-9fa0-ce43b4d7b2a0")
    for interview_response in interview.interview_responses.all():
        log.info(f"response option: {interview_response.response_option_value}")
##  Filtering #
Questionnaires and interviews can be filtered by any attribute that exists on
the models.
Filtering for questionnaires and interviews is done with the `filter` method
on the `Questionnaire` and `Interview` model managers.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.questionnaire import Interview, Questionnaire
    questionnaires = Questionnaire.objects.filter(name="Tobacco")
    interviews = Interview.objects.filter(progress_status="F")
###  By ValueSet #
Filtering by ValueSet works a little differently. The `find` method on the
model manager is used to perform `ValueSet` filtering:
    from canvas_sdk.v1.data.questionnaire import Questionnaire
    from canvas_sdk.value_set.v2022.assessment import TobaccoUseScreening
    questionnaires = Questionnaire.objects.find(TobaccoUseScreening)
##  Attributes #
###  ResponseOptionSet #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
name| String  
code_system| String  
code| String  
type| String  
use_in_shx| Boolean  
options| ResponseOption[]  
questions| Question[]  
###  ResponseOption #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
name| String  
code| String  
code_description| String  
value| String  
response_option_set| ResponseOptionSet  
ordering| Integer  
interview_responses| InterviewQuestionResponse[]  
###  Question #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
name| String  
response_option_set| ResponseOptionSet  
acknowledge_only| Boolean  
show_prologue| Boolean  
code_system| String  
code| String  
interview_responses| InterviewQuestionResponse[]  
###  Questionnaire #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
name| String  
expected_completion_time| Float  
can_originate_in_charting| Boolean  
use_case_in_charting| String  
scoring_function_name| String  
scoring_code_system| String  
scoring_code| String  
code_system| String  
code| String  
search_tags| String  
questions| Question[]  
use_in_shx| Boolean  
carry_forward| String  
interview_responses| InterviewQuestionResponse[]  
###  QuestionnaireQuestionMap #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
questionnaire| Questionnaire  
question| Question  
###  Interview #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
deleted| Boolean  
committer| [CanvasUser](/sdk/data-canvasuser)  
entered_in_error| [CanvasUser](/sdk/data-canvasuser)  
status| String  
name| String  
language_id| Integer  
use_case_in_charting| String  
patient| [Patient](/sdk/data-patient/#patient)  
note_id| Integer  
appointment_id| Integer  
questionnaires| Questionnaire[]  
progress_status| String  
created| DateTime  
modified| DateTime  
interview_responses| InterviewQuestionResponse[]  
###  InterviewQuestionResponse #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
status| String  
interview| Interview  
questionnaire| Questionnaire  
question| Question  
response_option| ResponseOption  
response_option_value| String  
questionnaire_state| String  
interview_state| String  
comment| String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-questionnaire


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-reason-for-visit/
# ReasonForVisit
Last updated: 24 Sep 2025
##  Introduction #
The `ReasonForVisitSettingCoding` model represents the coding information used
to populate the coding field within a Reason For Visit in Canvas.
##  Basic Usage #
To retrieve a specific coding record by its identifier, use the model
managerâs `get` method:
    from canvas_sdk.v1.data import ReasonForVisitSettingCoding
    rfv_coding = ReasonForVisitSettingCoding.objects.get(id="e2b1e1e3-3f52-4a0a-bb3a-123456789abc")
You can also filter records by attributes. For example, to get all codings
from a specific coding system:
    from canvas_sdk.v1.data import ReasonForVisitSettingCoding
    codings = ReasonForVisitSettingCoding.objects.filter(system="http://snomed.info/sct")
##  Attributes #
###  ReasonForVisitSettingCoding #
Field Name| Type| Description  
---|---|---  
id| UUID| The universally unique identifier for this coding record.  
dbid| Integer| The database identifier for this coding record.  
code| String| The code representing the concept.  
display| String| The human-readable display name for the concept.  
system| String| The coding system (e.g., `http://snomed.info/sct`).  
version| String| The version of the coding system.  
duration| Array of Duration| An array of durations (as Python `timedelta`
objects) associated with the coding.  
----- END PAGE https://docs.canvasmedical.com/sdk/data-reason-for-visit/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-staff
# Staff
Last updated: 8 Sep 2025
##  Introduction #
The `Staff` model represents a staff member in a Canvas instance.
To get a `Staff` object by itâs identifier, use the `get` method:
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
`Staff` objects are commonly used in related models, for example the `Task`
model. To see all of a staff memberâs assigned or created tasks, the
following code can be used:
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.assignee_tasks.all()
    # <QuerySet [<Task: Task object (3)>]>
    staff.creator_tasks.all()
    # <QuerySet [<Task: Task object (7)>]>
To show a Staff memberâs contact points (email, phone, etc.), the `telecom`
attribute can be used. For example:
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    [(t.system, t.value,) for t in staff.telecom.all()]
    # [('phone', '8005551416'), ('email', 'support@canvasmedical.com')]
To show a `Staff` full name, credentialed name, the topmost clinical role or
top role abbreviation use the properties `full_name`, `credentialed_name`,
`top_clinical_role` or `top_role_abbreviation`.
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.full_name
    # Larry Weed
    staff.credentialed_name
    # Larry Weed MD
    staff.top_clinical_role.name
    # Physician
    staff.top_role_abbreviation
    # MD
To get `Staff` licenses.
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.licenses.all()
    # <QuerySet [<StaffLicense: CA License for Larry Weed>]>
##  Attributes #
###  Staff #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
prefix| String  
suffix| String  
first_name| String  
middle_name| String  
last_name| String  
maiden_name| String  
nickname| String  
previous_names| JSON  
birth_date| Date  
sex_at_birth| [PersonSex](/sdk/data-enumeration-types/#personsex)  
sexual_orientation_term| String  
sexual_orientation_code| String  
gender_identity_term| String  
gender_identity_code| String  
preferred_pronouns| String  
biological_race_codes| Array[String]  
biological_race_terms| Array[String]  
cultural_ethnicity_codes| Array[String]  
cultural_ethnicity_terms| Array[String]  
last_known_timezone| TimeZone  
active| Boolean  
primary_practice_location| [PracticeLocation](/sdk/data-practicelocation/)  
npi_number| String  
nadean_number| String  
group_npi_number| String  
bill_through_organization| Boolean  
tax_id| String  
tax_id_type| [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
spi_number| String  
personal_meeting_room_link| URL  
state| JSON  
user| [CanvasUser](/sdk/data-canvasuser)  
supervising_team| Staff[]  
notes| Note[]  
creator_tasks| [Task](/sdk/data-task/#task)[]  
assignee_tasks| [Task](/sdk/data-task/#task)[]  
comments| [TaskComment](/sdk/data-task/#taskcomment)[]  
care_team_memberships| [CareTeamMembership](/sdk/data-care-
team/#careteammembership)[]  
teams| [Team](/sdk/data-team/#team)[]  
telecom| StaffContactPoint[]  
###  StaffContactPoint #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
system| [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value| String  
use| String  
use_notes| String  
rank| Integer  
state| [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
staff| Staff  
###  StaffAddress #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
line1| String  
line2| String  
city| String  
district| String  
state_code| String  
postal_code| String  
use| [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type| [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude| Float  
latitude| Float  
start| Date  
end| Date  
country| String  
state| String  
staff| Staff  
###  StaffLicense #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
staff| Staff  
issuing_authority_long_name| String  
issuing_authority_url| URL  
license_or_certification_identifier| String  
issuance_date| Date  
expiration_date| Date  
license_type| LicenseType  
primary| Boolean  
state| String  
###  StaffPhoto #
Field Name| Type  
---|---  
dbid| Integer  
created| DateTime  
modified| DateTime  
staff| Staff  
url| String  
title| String  
###  StaffRole #
Field Name| Type  
---|---  
dbid| Integer  
staff| Staff  
internal_code| String  
public_abbreviation| String  
domain| RoleDomain  
name| String  
domain_privilege_level| Integer  
permissions| JSON  
role_type| RoleType  
##  Enumeration types #
###  License Type #
Value| Description  
---|---  
CLIA| CLIA  
DEA| DEA  
PTAN| PTAN  
STATE_LICENSE| State License  
TAXONOMY| Taxonomy  
SPI| SPI  
OTHER| Other  
###  Role Domain #
Value| Abbreviation| Description  
---|---|---  
CLINICAL| CLI| Clinical  
ADMINISTRATIVE| ADM| Administrative  
HYBRID| HYB| Hybrid  
###  Role Type #
Value| Description  
---|---  
NON_LICENSED| Non-Licensed  
LICENSED| Licensed  
PROVIDER| Provider  
##  Computed Properties #
  * `photo_url`: The URL of the staff memberâs photo, if available, or a placeholder image URL.
----- END PAGE https://docs.canvasmedical.com/sdk/data-staff


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-task
# Task
Last updated: 4 Nov 2025
##  Introduction #
A `Task` represents a to-do item to be addressed. Tasks can be assigned to
individual staff members and can also have associated comments and labels.
##  Basic usage #
To get a task by itâs identifier, use the `get` method on the `Task` model
manager:
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
From a `Patient` object, tasks for the patient can be accessed with the
`tasks` attribute:
    import arrow
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.v1.data.task import TaskStatus
    patient = Patient.objects.get(id="36950971cb3e4174ad8b9d365abfd6d0")
    # All tasks for the patient
    tasks_for_patient = patient.tasks.all()
    # Tasks for the patient that are overdue
    tasks_for_patient_overdue = patient.tasks.filter(due__lte=arrow.utcnow().datetime, status=TaskStatus.OPEN)
`Task` objects are also able to have associated `TaskLabel` objects.
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    [(label.name, label.color,) for label in task.labels.all()]
    # [('Emergent', 'red')]
`Staff` members are able to leave comments on tasks. These are stored as
associated `TaskComment` objects. For example:
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    [(comment.creator, comment.body,) for comment in task.comments.all()]
    # [(<Staff: Sam Jones>, "Please call patient.")]
##  Attributes #
###  Task #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
creator| [Staff](/sdk/data-staff/#staff)  
assignee| [Staff](/sdk/data-staff/#staff)  
patient| [Patient](/sdk/data-patient/#patient)  
task_type| TaskType  
tag| String  
title| String  
due| DateTime  
due_event| EventType  
status| TaskStatus  
comments| TaskComment[]  
labels| TaskLabel[]  
metadata| TaskMetadata[]  
###  TaskComment #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
creator| [Staff](/sdk/data-staff/#staff)  
task| [Task](/sdk/data-task/#task)  
body| String  
###  TaskLabel #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
tasks| M2M  
position| Integer  
color| [ColorEnum](/sdk/data-enumeration-types/#colorenum)  
task_association| [Origin](/sdk/data-enumeration-types/#origin)  
name| String  
active| Boolean  
modules| TaskLabelModule  
claims| [Claim](/sdk/data-claim)[]  
###  TaskMetadata #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
task| Task  
key| String  
value| String  
    from canvas_sdk.v1.data.task import Task
    from logger import log
    task_id = "7895e1db-f8de-4660-a0a3-9e5b43a475c6"
    task = Task.objects.get(id=task_id)
    task_metadata = task.metadata.all()
    for metadata in task_metadata:
       log.info(f"Task metadata: {metadata.key}, {metadata.value}") # external_system_id - EXT-12345
##  Enumeration types #
###  TaskType #
Value| Label  
---|---  
Task| Task  
Reminder| Reminder  
###  EventType #
Value| Label  
---|---  
Chart Open| Chart Open  
###  TaskStatus #
Value| Label  
---|---  
COMPLETED| Completed  
CLOSED| Closed  
OPEN| Open  
###  TaskLabelModule #
Value| Label  
---|---  
claims| Claims  
tasks| Tasks  
----- END PAGE https://docs.canvasmedical.com/sdk/data-task


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-team
# Team
Last updated: 30 Jan 2025
##  Introduction #
The `Team` model represents a team of staff members in a Canvas instance.
##  Basic usage #
To get an team by identifier, use the `get` method on the `Team` model
manager:
    from canvas_sdk.v1.data.team import Team
    team = Team.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
If you have a staff object, the teams that a staff is a member of can be
accessed with the `teams` attribute on a `Staff` object:
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    teams = staff.teams.all()
##  Team Members #
The members of a team can be access with the `members` attribute on a `Team`
object:
    from canvas_sdk.v1.data.team import Team
    from logger import log
    team = Team.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for member in team.members.all():
        log.info(f"first_name: {member.first_name}")
        log.info(f"last_name: {member.last_name}")
##  Filtering #
Teams can be filtered by any attribute that exists on the model.
Filtering for teams is done with the `filter` method on the `Team` model
manager.
###  By attribute #
Specify an attribute with `filter` to filter by that attribute:
    from canvas_sdk.v1.data.team import Team
    teams = Team.objects.filter(created__gt="2025-01-01")
##  Attributes #
###  Team #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
created| DateTime  
modified| DateTime  
name| String  
responsibilities| Array[TeamResponsibility]  
members| [Staff](/sdk/data-staff/#staff)[]  
###  TeamContactPoint #
Field Name| Type  
---|---  
id| UUID  
dbid| Integer  
system| [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value| String  
use| [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes| String  
rank| Integer  
state| [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
team| Team  
##  Enumeration types #
###  TeamResponsibility #
Field Name| Type  
---|---  
COLLECT_SPECIMENS_FROM_PATIENT| Collect specimens from a patient  
COMMUNICATE_DIAGNOSTIC_RESULTS_TO_PATIENT| Communicate diagnostic results to
patient  
COORDINATE_REFERRALS_FOR_PATIENT| Coordinate referrals for a patient  
PROCESS_REFILL_REQUESTS| Process refill requests from a pharmacy  
PROCESS_CHANGE_REQUESTS| Process change requests from a pharmacy  
SCHEDULE_LAB_VISITS_FOR_PATIENT| Schedule lab visits for a patient  
POPULATION_HEALTH_CAMPAIGN_OUTREACH| Population health campaign outreach  
COLLECT_PATIENT_PAYMENTS| Collect patient payments  
COMPLETE_OPEN_LAB_ORDERS| Complete open lab orders  
REVIEW_ERA_POSTING_EXCEPTIONS| Review electronic remittance posting exceptions  
REVIEW_COVERAGES| Review incomplete patient coverages  
----- END PAGE https://docs.canvasmedical.com/sdk/data-team


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-value-sets/
# ValueSets
Last updated: 24 Sep 2025
##  Introduction #
The Canvas SDK includes a library of built-in Value Sets that can be used
within plugins to assist with finding conditions or medications related to
Electronic Clinical Quality Measures. Plugin developers can also create their
own Value Sets and use them in the same manner as the Canvas built-in
`ValueSet` classes.
Built-in Value Sets that can be imported into plugins can be found in the
Canvas SDK open source repo [here](https://github.com/canvas-medical/canvas-
plugins/tree/main/canvas_sdk/value_set/).
##  Usage #
**Filtering Conditions by Value Set**
Value Set classes can be used directly in the data module to query for
conditions that are included within them. For example, to find if a patient
has been diagnosed with a condition whose coding falls under a particular
Value Set, the `find` method can be used as follows:
    from logger import log
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.condition import EssentialHypertension
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_essential_hypertension_conditions = patient.conditions.find(EssentialHypertension)
    # The patient has been diagnosed with one or more conditions that match a coding within the EssentialHypertension value set
    if patient_essential_hypertension_conditions:
        for condition in patient_essential_hypertension_conditions:
            log.info(condition.codings.all().values())
**Filtering Medications by Value Set**
Similar to the `Condition` example above, the `find` method can also utilize
Value Set classes to filter `Medication` records that fall under a value set:
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.medication import DementiaMedications
    from logger import log
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_dementia_medications = patient.medications.find(DementiaMedications)
    if patient_dementia_medications:
        for medication in patient_dementia_medications:
            log.info(medication.codings.all().values())
**Filtering with more than one Value Set**
Sometimes it may be desirable to filter using more than one Value Set. For
example, finding all of a patientâs conditions that belong within
`EssentialHypertension` _or_ `DiagnosisOfHypertension`. In this case, the
`find` supports the pipe (`|`) operator to filter conditions that match the
codings in either Value Set:
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.condition import EssentialHypertension, DiagnosisOfHypertension
    from logger import log
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_hypertension_conditions = patient.conditions.find(EssentialHypertension | DiagnosisOfHypertension)
    if patient_hypertension_conditions:
        for condition in patient_hypertension_conditions:
            log.info(condition.codings.all().values())
##  Creating Custom Value Sets #
The Canvas SDK allows plugin developers to create their own ValueSet classes
that can be used in the same manner as the examples above. To do so, one can
import and inherit the base `ValueSet` class:
    from canvas_sdk.value_set.value_set import ValueSet
A new class containing Python sets of coding values can be defined like so:
    from canvas_sdk.value_set.value_set import ValueSet
    class MyCustomValueSet(ValueSet):
        VALUE_SET_NAME = "My Custom Value Set"
        ICD10CM = {
            "T2601XA",  # Burn of right eyelid and periocular area, initial encounter
        }
        SNOMEDCT = {
            "284537006",  # Eyelid burn (disorder)
        }
The valid code system constants that can be used to define sets of codes in
Value Sets are:
Name| URL  
---|---  
`CPT`| `http://www.ama-assn.org/go/cpt`  
`HCPCSLEVELII`| `https://coder.aapc.com/hcpcs-codes`  
`CVX`| `http://hl7.org/fhir/sid/cvx`  
`LOINC`| `http://loinc.org`  
`SNOMEDCT`| `http://snomed.info/sct`  
`FDB`| `http://www.fdbhealth.com/`  
`RXNORM`| `http://www.nlm.nih.gov/research/umls/rxnorm`  
`ICD10`| `ICD-10`  
`NUCC`| `http://www.nucc.org/`  
`CANVAS`| `CANVAS`  
`INTERNAL`| `INTERNAL`  
`NDC`| `http://hl7.org/fhir/sid/ndc`  
The following code is an example of a custom `ValueSet` in use within a
plugin:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.value_set import ValueSet
    class MyCustomValueSet(ValueSet):
        VALUE_SET_NAME = "My Custom Value Set"
        ICD10CM = {
            "T2601XA",  # Burn of right eyelid and periocular area, initial encounter
        }
        SNOMEDCT = {
            "284537006",  # Eyelid burn (disorder)
        }
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
            custom_value_set_conditions = patient.conditions.find(MyCustomValueSet)
            for vs in custom_value_set_conditions:
                log.info(vs)
            return []
----- END PAGE https://docs.canvasmedical.com/sdk/data-value-sets/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effects/
# Effects
Last updated: 11 Nov 2025
Effects are instructions that plugins can return in order to perform an action
in the Canvas EMR. This makes it possible to define workflows that create
commands, show notifications, modify search results, etc.
Effects have a `type` and a `payload`. The `type` determines the action that
will be performed with the data provided in the `payload`.
##  Using Effects #
###  Basic Usage #
Effects are returned as a list from the `compute` method of a plugin that
inherits from `BaseHandler`. For example:
    import json
    from canvas_sdk.events import EventType
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
            post_processed_results = []
            ## custom results-modifying code here
            ...
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
In the above example, the `Effect` object is constructed manually, with the
`type` and `payload` set directly.
Some effects have helper classes that assist you by providing payload
validation and constructing the effect object for you. The example below shows
the [`PatientChartSummaryConfiguration`](/sdk/layout-effect/#patient-summary)
class in use:
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    class CustomChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section and hides those
        not used by the installation's organization.
        """
        # This event fires when a patient's chart summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.VITALS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.IMMUNIZATIONS,
            ])
            return [layout.apply()]
###  Disallowed Effect/Event Combinations #
Canvas prevents certain combinations of events and effects to avoid infinite
loops that could occur when an effect triggers the same event that generated
it. The following combinations are specifically disallowed:
Event Type| Disallowed Effect Types  
---|---  
`PATIENT_CHART__CONDITIONS`| `ADD_BANNER_ALERT`  
`ADD_OR_UPDATE_PROTOCOL_CARD`  
`PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION`| `ADD_BANNER_ALERT`  
`ADD_OR_UPDATE_PROTOCOL_CARD`  
For example, if you have a plugin that responds to `PATIENT_CHART__CONDITIONS`
events, you cannot return `ADD_BANNER_ALERT` or `ADD_OR_UPDATE_PROTOCOL_CARD`
effects from that plugin, as this could create an infinite loop where the
effect triggers another conditions event.
##  Effect Classes #
[ AppointmentsCreate, update, and cancel patient appointments. ](/sdk/effect-
notes/#appointment-effect)[ Appointment MetadataInteract with appointment
metadata. ](/sdk/effect-appointment-metadata/)[ Appointment Metadata Create
FormEffect for dynamically displaying forms when scheduling an appointment.
](/sdk/appointment-metadata-create-form-effect)[ Banner AlertsContextual
information in a patient's chart. ](/sdk/effect-banner-alerts/)[ Billing Line
ItemsAdd, modify, or remove billing codes on a note. ](/sdk/effect-billing-
line-items/)[ Compound MedicationsCreate or update compound medications.
](/sdk/effect-compound-medication/)[ Custom HTML and Django TemplatesRender
custom HTML using Django templates. ](/sdk/layout-effect/#custom-html-and-
django-templates)[ Form ResultEffect for dynamically displaying forms in the
Patient Portal. ](/sdk/form-result-effect)[ Layout EffectsModify or interact
with the layout in Canvas. ](/sdk/layout-effect/)[ MessagesInteract with
messages in Canvas. ](/sdk/effect-messages/)[ NotesInteract with notes in
Canvas. ](/sdk/effect-notes/)[ PatientInteract with patient data.
](/sdk/effect-patient/)[ Patient Chart GroupEffect for grouping items on a
patient chart section. ](/sdk/patient-chart-group-effect/)[ Patient External
IDCreate a new external identifier for a patient. ](/sdk/effect-create-
patient-external-identifier/)[ Patient MetadataInteract with patient metadata.
](/sdk/effect-patient-metadata/)[ Patient Metadata Create FormEffect for
dynamically displaying forms in the Patient profile. ](/sdk/patient-metadata-
create-form-effect)[ Patient PortalCustomize your Patient Portal.
](/sdk/patient-portal/)[ Protocol CardsCalls to action in a patient's chart,
commonly used for decision support intervention. ](/sdk/effect-protocol-
cards/)[ QuestionnairesInteract with questionnaires and interviews.
](/sdk/effect-questionnaires/)[ TasksCreate or update tasks. ](/sdk/effect-
tasks/)[ Task MetadataInteract with Task metadata. ](/sdk/effect-task-
metadata/)[ CommandsThe building blocks of many end-user workflows in Canvas,
including nearly all clinical workflows for documentation. ](/sdk/commands/)
##  Effect Types #
The following effects are available to be applied in Canvas.
Effect| Description  
---|---  
ADD_BANNER_ALERT| Can be used to [add a banner alert](/sdk/effect-banner-
alerts/#adding-a-banner-alert) to a patientâs chart.  
REMOVE_BANNER_ALERT| Can be used to [remove a banner alert](/sdk/effect-
banner-alerts/#removing-a-banner-alert) from a patientâs chart.  
SHOW_PATIENT_CHART_SUMMARY_SECTIONS| Can be used to reorder or hide the
summary sections in a patient chart. Check out [this effect
class](/sdk/layout-effect/#patient-summary/).  
PATIENT_CHART__GROUP_ITEMS| Can be used to group items within a specific
patient chart section.  
SHOW_ACTION_BUTTON| Can be used to show an action button. Check out [Action
Buttons](/sdk/handlers-action-buttons/).  
LAUNCH_MODAL| Can be used to launch a modal window. Check out
[Modals](/sdk/layout-effect/#modals).  
PORTAL_WIDGET| Can be used to add widgets to patient portal landing page.
Check out [Portal Landing Page Widgets](/sdk/layout-effect/#portal-landing-
page-widgets)  
ADD_OR_UPDATE_PROTOCOL_CARD| Can be used to generate a ProtocolCard in the
Canvas UI. Use the [ProtocolCard](/sdk/effect-protocol-cards/) class in the
effects module.  
ADD_BILLING_LINE_ITEM| Can be used to generate a Billing Line Item in a note
footer. Use the [AddBillingLineItem](/sdk/effect-billing-line-items/) class in
the effects module.  
UPDATE_BILLING_LINE_ITEM| Can be used to update an existing Billing Line Item
in a note footer. Use the [UpdateBillingLineItem](/sdk/effect-billing-line-
items/) class in the effects module.  
REMOVE_BILLING_LINE_ITEM| Can be used to remove a Billing Line Item in a note
footer. Use the [RemoveBillingLineItem](/sdk/effect-billing-line-items/) class
in the effects module.  
ANNOTATE_CLAIM_CONDITION_RESULTS| Can be used to add annotations to the
conditions appearing in a claimâs detail view.  
ANNOTATE_PATIENT_CHART_CONDITION_RESULTS| Add an annotation to a condition
within the patient summary.  
ANNOTATE_PATIENT_CHART_DETECTED_ISSUE_RESULTS| Add an annotation to a detected
issue within the patient summary.  
AUTOCOMPLETE_SEARCH_RESULTS| Can be used to modify search results by re-
ordering or adding text annotations to individual result records. To see how
you can put this to use, check out [this guide](/guides/customize-search-
results/).  
PATIENT_PROFILE__ADD_PHARMACY__POST_SEARCH_RESULTS| Can be used to modify
pharmacy results when adding pharmacies in the patient profile.  
CREATE_TASK| Cause a task you define in a plugin to be created.  
UPDATE_TASK| Cause a task to be updated.  
CREATE_TASK_COMMENT| Add a comment to an existing task.  
COMMAND_AVAILABLE_ACTIONS_RESULTS| Can be used to sort or filter command
available actions. Checkout command available [actions](sdk/commands/#command-
actions)  
ORIGINATE_ALLERGY_COMMAND| Can be used to originate an allergy command in a
note.  
EDIT_ALLERGY_COMMAND| Can be used to edit an allergy command in a note.  
COMMIT_ALLERGY_COMMAND| Can be used to commit an allergy command in a note.  
ORIGINATE_REMOVE_ALLERGY_COMMAND| Can be used to originate a remove allergy
command in a note.  
EDIT_REMOVE_ALLERGY_COMMAND| Can be used to edit a remove allergy command in a
note.  
COMMIT_REMOVE_ALLERGY_COMMAND| Can be used to commit a remove allergy command
in a note.  
ORIGINATE_GOAL_COMMAND| Can be used to originate a goal command in a note.  
EDIT_GOAL_COMMAND| Can be used to edit a goal command in a note.  
COMMIT_GOAL_COMMAND| Can be used to commit a goal command in a note.  
ORIGINATE_UPDATE_GOAL_COMMAND| Can be used to originate an update goal command
in a note.  
EDIT_UPDATE_GOAL_COMMAND| Can be used to edit an update goal command in a
note.  
COMMIT_UPDATE_GOAL_COMMAND| Can be used to commit an update goal command in a
note.  
ORIGINATE_CLOSE_GOAL_COMMAND| Can be used to originate a close goal command in
a note.  
EDIT_CLOSE_GOAL_COMMAND| Can be used to edit a close goal command in a note.  
COMMIT_CLOSE_GOAL_COMMAND| Can be used to commit a close goal command in a
note.  
ORIGINATE_DIAGNOSE_COMMAND| Can be used to originate a diagnose command in a
note.  
EDIT_DIAGNOSE_COMMAND| Can be used to edit a diagnose command in a note.  
COMMIT_DIAGNOSE_COMMAND| Can be used to commit a diagnose command in a note.  
ORIGINATE_UPDATE_DIAGNOSIS_COMMAND| Can be used to originate an update
diagnosis command in a note.  
EDIT_UPDATE_DIAGNOSIS_COMMAND| Can be used to edit an update diagnosis command
in a note.  
COMMIT_UPDATE_DIAGNOSIS_COMMAND| Can be used to commit an update diagnosis
command in a note.  
ORIGINATE_CHANGE_MEDICATION_COMMAND| Can be used to originate a change
medication command in a note.  
EDIT_CHANGE_MEDICATION_COMMAND| Can be used to edit a change medication
command in a note.  
COMMIT_CHANGE_MEDICATION_COMMAND| Can be used to commit a change medication
command in a note.  
ORIGINATE_ASSESS_COMMAND| Can be used to originate an assess command in a
note.  
EDIT_ASSESS_COMMAND| Can be used to edit an assess command in a note.  
COMMIT_ASSESS_COMMAND| Can be used to commit an assess command in a note.  
ORIGINATE_PRESCRIBE_COMMAND| Can be used to originate a prescribe command in a
note.  
EDIT_PRESCRIBE_COMMAND| Can be used to edit a prescribe command in a note.  
SEND_PRESCRIBE_COMMAND| Can be used to send a committed prescribe command in a
note.  
REVIEW_PRESCRIBE_COMMAND| Can be used to set a prescribe command in review.  
ORIGINATE_REFILL_COMMAND| Can be used to originate a refill command in a note.  
EDIT_REFILL_COMMAND| Can be used to edit a refill command in a note.  
SEND_REFILL_COMMAND| Can be used to send a committed refill command in a note.  
REVIEW_REFILL_COMMAND| Can be used to set a refill command in review.  
ORIGINATE_MEDICATION_STATEMENT_COMMAND| Can be used to originate a medication
statement command in a note.  
EDIT_MEDICATION_STATEMENT_COMMAND| Can be used to edit a medication statement
command in a note.  
COMMIT_MEDICATION_STATEMENT_COMMAND| Can be used to commit a medication
statement command in a note.  
ORIGINATE_STOP_MEDICATION_COMMAND| Can be used to originate a stop medication
command in a note.  
EDIT_STOP_MEDICATION_COMMAND| Can be used to edit a stop medication command in
a note.  
COMMIT_STOP_MEDICATION_COMMAND| Can be used to commit a stop medication
command in a note.  
ORIGINATE_PLAN_COMMAND| Can be used to originate a plan command in a note.  
EDIT_PLAN_COMMAND| Can be used to edit a plan command in a note.  
COMMIT_PLAN_COMMAND| Can be used to commit a plan command in a note.  
ORIGINATE_HPI_COMMAND| Can be used to originate a history of present illness
command in a note.  
EDIT_HPI_COMMAND| Can be used to edit a history of present illness command in
a note.  
COMMIT_HPI_COMMAND| Can be used to commit a history of present illness command
in a note.  
ORIGINATE_FAMILY_HISTORY_COMMAND| Can be used to originate a family history
command in a note.  
EDIT_FAMILY_HISTORY_COMMAND| Can be used to edit a family history command in a
note.  
COMMIT_FAMILY_HISTORY_COMMAND| Can be used to commit a family history command
in a note.  
ORIGINATE_MEDICAL_HISTORY_COMMAND| Can be used to originate a medical history
command in a note.  
EDIT_MEDICAL_HISTORY_COMMAND| Can be used to edit a medical history command in
a note.  
COMMIT_MEDICAL_HISTORY_COMMAND| Can be used to commit a medical history
command in a note.  
ORIGINATE_SURGICAL_HISTORY_COMMAND| Can be used to originate a surgical
history command in a note.  
EDIT_SURGICAL_HISTORY_COMMAND| Can be used to edit a surgical history command
in a note.  
COMMIT_SURGICAL_HISTORY_COMMAND| Can be used to commit a surgical history
command in a note.  
ORIGINATE_INSTRUCT_COMMAND| Can be used to originate an instruct command in a
note.  
EDIT_INSTRUCT_COMMAND| Can be used to edit an instruct command in a note.  
COMMIT_INSTRUCT_COMMAND| Can be used to commit an instruct command in a note.  
ORIGINATE_LAB_ORDER_COMMAND| Can be used to originate a lab order command in a
note.  
EDIT_LAB_ORDER_COMMAND| Can be used to edit a lab order command in a note.  
COMMIT_LAB_ORDER_COMMAND| Can be used to commit a lab order command in a note.  
SEND_LAB_ORDER_COMMAND| Can be used to send a committed lab order command in a
note.  
ORIGINATE_PERFORM_COMMAND| Can be used to originate a perform command in a
note.  
EDIT_PERFORM_COMMAND| Can be used to edit a perform command in a note.  
COMMIT_PERFORM_COMMAND| Can be used to commit a perform command in a note.  
ORIGINATE_QUESTIONNAIRE_COMMAND| Can be used to originate a questionnaire
command in a note.  
EDIT_QUESTIONNAIRE_COMMAND| Can be used to edit a questionnaire command in a
note.  
COMMIT_QUESTIONNAIRE_COMMAND| Can be used to commit a questionnaire command in
a note.  
ORIGINATE_REASON_FOR_VISIT_COMMAND| Can be used to originate a reason for
visit command in a note.  
EDIT_REASON_FOR_VISIT_COMMAND| Can be used to edit a reason for visit command
in a note.  
COMMIT_REASON_FOR_VISIT_COMMAND| Can be used to commit a reason for visit
command in a note.  
ORIGINATE_TASK_COMMAND| Can be used to originate a task command in a note.  
EDIT_TASK_COMMAND| Can be used to edit a task command in a note.  
COMMIT_TASK_COMMAND| Can be used to commit a task command in a note.  
ORIGINATE_VITALS_COMMAND| Can be used to originate a vitals command in a note.  
EDIT_VITALS_COMMAND| Can be used to edit a vitals command in a note.  
COMMIT_VITALS_COMMAND| Can be used to commit a vitals command in a note.  
ORIGINATE_FOLLOW_UP_COMMAND| Can be used to originate a follow up command in a
note.  
EDIT_FOLLOW_UP_COMMAND| Can be used to edit a follow up command in a note.  
COMMIT_FOLLOW_UP_COMMAND| Can be used to commit a follow up command in a note.  
ORIGINATE_IMAGING_ORDER_COMMAND| Can be used to originate a imaging order
command in a note.  
EDIT_IMAGING_ORDER_COMMAND| Can be used to edit a imaging order command in a
note.  
COMMIT_IMAGING_ORDER_COMMAND| Can be used to commit a imaging order command in
a note.  
ORIGINATE_REFER_COMMAND| Can be used to originate a refer command in a note.  
EDIT_REFER_COMMAND| Can be used to edit a refer command in a note.  
COMMIT_REFER_COMMAND| Can be used to commit a refer command in a note.  
ORIGINATE_ADJUST_PRESCRIPTION_COMMAND| Can be used to originate an adjust
prescription command in a note.  
EDIT_ADJUST_PRESCRIPTION_COMMAND| Can be used to edit an adjust prescription
command in a note.  
SEND_ADJUST_PRESCRIPTION_COMMAND| Can be used to send a adjust prescription
command in a note.  
REVIEW_ADJUST_PRESCRIPTION_COMMAND| Can be used to set an adjust prescription
command in review.  
ORIGINATE_RESOLVE_CONDITION_COMMAND| Can be used to originate a resolve
condition command in a note.  
EDIT_RESOLVE_CONDITION_COMMAND| Can be used to edit a resolve condition
command in a note.  
COMMIT_RESOLVE_CONDITION_COMMAND| Can be used to commit a resolve condition
command in a note.  
PATIENT_PORTAL__APPOINTMENT_SHOW_MEETING_LINK| Can be used to show the
âjoinâ button on the telehealth appointment card, allowing patients to
easily join their appointments.  
PATIENT_PORTAL__APPOINTMENT_IS_CANCELABLE| Can be used to show the
âcancelâ button on the appointment card, allowing patients to easily
cancel their appointments  
PATIENT_PORTAL__APPOINTMENT_IS_RESCHEDULABLE| Can be used to show the
ârescheduleâ button on the appointment card, allowing patients to easily
reschedule their appointments  
UPDATE_USER| Can be used to update a user  
PATIENT_PORTAL__SEND_INVITE| Can be used to trigger a portal invitation for a
user  
PATIENT_METADATA__CREATE_ADDITIONAL_FIELDS| Can be used to show additional
fields on the patient profile section  
APPOINTMENT__FORM__PROVIDERS__PRE_SEARCH_RESULTS| Can be used to modify the
list of providers shown in the appointment scheduling form before a search is
performed  
APPOINTMENT__FORM__LOCATIONS__PRE_SEARCH_RESULTS| Can be used to modify the
list of locations shown in the appointment scheduling form before a search is
performed  
APPOINTMENT__FORM__VISIT_TYPES__PRE_SEARCH_RESULTS| Can be used to modify the
list of visit types shown in the appointment scheduling form before a search
is performed  
APPOINTMENT__FORM__DURATIONS__PRE_SEARCH_RESULTS| Can be used to modify the
list of durations shown in the appointment scheduling form before a search is
performed  
APPOINTMENT__FORM__REASON_FOR_VISIT__PRE_SEARCH_RESULTS| Can be used to modify
the reason for visit field in the appointment scheduling form before a search
is performed  
APPOINTMENT__FORM__PROVIDERS__POST_SEARCH_RESULTS| Can be used to modify the
list of providers shown in the appointment scheduling form after a search is
performed  
APPOINTMENT__FORM__LOCATIONS__POST_SEARCH_RESULTS| Can be used to modify the
list of locations shown in the appointment scheduling form after a search is
performed  
APPOINTMENT__FORM__VISIT_TYPES__POST_SEARCH_RESULTS| Can be used to modify the
list of visit types shown in the appointment scheduling form after a search is
performed  
APPOINTMENT__FORM__DURATIONS__POST_SEARCH_RESULTS| Can be used to modify the
list of durations shown in the appointment scheduling form after a search is
performed  
APPOINTMENT__FORM__REASON_FOR_VISIT__POST_SEARCH_RESULTS| Can be used to
modify the reason for visit field in the appointment scheduling form after a
search is performed  
APPOINTMENT__FORM__CREATE_ADDITIONAL_FIELDS| Can be used to show additional
fields on the appointment scheduling form  
UPSERT_APPOINTMENT_METADATA| Can be used to add additional metadata when
creating or updating an appointment  
RESCHEDULE_APPOINTMENT| Can be used to reschedule an appointment. Check out
[Appointment Effects](/sdk/effect-notes/#reschedule-appointment).  
RESCHEDULE_SCHEDULE_EVENT| Can be used to reschedule a schedule event. Check
out [Schedule Event Effects](/sdk/effect-notes/#reschedule-schedule-event).  
APPOINTMENT__SLOTS__POST_SEARCH_RESULTS| Can be used to modify slot
availability when scheduling an appointment  
----- END PAGE https://docs.canvasmedical.com/sdk/effects/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-protocol-cards/
# Protocol Card
Last updated: 7 Nov 2025
Protocol cards appear on the right-hand-side of a patientâs chart, and can
be accessed by clicking on the Protocols filter button in the filter menu.
![protocol card](/assets/images/protocol-card.png)
A Protocol card consists of three main parts:
  * A title, which appears at the top in bold
  * A narrative, which appears just below the title to add any additional clarifying information
  * A list of recommendations, which each have a title and optionally a button that can either:
    * open a new tab and navigate to another site
    * insert a command into a note
Name| Type| Required| Description  
---|---|---|---  
`patient_id`|  _string_| `true` (if `patient_filter` is not included)| The id
of the [patient](/sdk/data-patient/)  
`patient_filter`|  _dict_| `true` (if `patient_id` is not included)| Patient
queryset filters to apply the effect to multiple patients. For example,
`{"active": True}` will apply to the effect to all active patients  
`key`|  _string_| `true`| A unique identifier for the protocol card  
`title`|  _string_| `true`| The title for the protocol card, which appears at
the top in bold  
`narrative`|  _string_| `false`| The narrative for the protocol card, which
appears just below the title  
`can_be_snoozed`|  _boolean_| `false`| Whether the protocol card can be
snoozed, defaults to `false`  
`status`| Status| `false`| The status of the protocol card, defaults to
`Status.DUE`  
`recommendations`| list[Recommendation]| `false`| The recommendations to
appear in the protocol card  
`feedback_enabled`|  _boolean_| `false`| Whether users can provide feedback
for the protocol card in Settings, defaults to `false`  
`due_in`|  _integer_| `false`| The number of days until the protocol card will
be considered due for the patient, defaults to `-1` for already due  
Â | Â | Â | Â   
###  Recommendation #
Attribute| Type| Required| Description  
---|---|---|---  
`title`|  _string_| `true`| The description of the recommendation  
`button`|  _string_| `false`| The text to appear on the button  
`href`|  _string_| `false`| The url for the button to navigate to  
Â | Â | Â | Â   
###  Status #
Enum| Value  
---|---  
`DUE`| due  
`SATISFIED`| satisfied  
`NOT_APPLICABLE`| not_applicable  
`PENDING`| pending  
`NOT_RELEVANT`| not_relevant  
Â | Â   
To include a command recommendation, we recommend you import the command from the [commands module](/sdk/commands/), instantiate the command with all the values you wish to populate, and then call `.recommend(title: str = "", button: str | None)` on the command to generate the recommendation that you can append to the protocol cardâs recommendations. Keep in mind that, at the moment, not all commands are supported for command insertion. See below for the list of supported commands.
</br> </br>
For non-command recommendations, you can either use the `Recommendation` class, or the `.add_recommendation(title: str = "", button: str = "", href: str | None)` method on the protocol card.
**Example** :
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from datetime import date
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.commands import DiagnoseCommand
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            p = ProtocolCard(
                patient_id=self.target,
                key="testing-protocol-cards",
                title="This is a ProtocolCard title",
                narrative="this is the narrative",
                status=ProtocolCard.Status.DUE,
                recommendations=[Recommendation(title="this recommendation has no action, just words!")]
            )
            p.add_recommendation(
                title="this is a recommendation", button="go here", href="https://canvasmedical.com/"
            )
            diagnose = DiagnoseCommand(
                icd10_code="I10",
                background="feeling bad for many years",
                approximate_date_of_onset=date(2020, 1, 1),
                today_assessment="still not great",
            )
            p.recommendations.append(diagnose.recommend(title="this inserts a diagnose command"))
            return [p.apply()]
To apply the effect to all active patients on plugin create and plugin update,
you would include the plugin create and update events in `RESPONDS_TO`. And
when responding to one of the plugin events you would use `patient_filter`
instead of `patient_id` for the ProtocolCard.
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from datetime import date
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.commands import DiagnoseCommand
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PATIENT_UPDATED),
            EventType.Name(EventType.PLUGIN_CREATED),
            EventType.Name(EventType.PLUGIN_UPDATED),
        ]
        def compute(self):
            p = ProtocolCard(
                key="testing-protocol-cards",
                title="This is a ProtocolCard title",
                narrative="this is the narrative",
                can_be_snoozed=True,
                recommendations=[
                    Recommendation(title="this recommendation has no action, just words!")
                ],
            )
            p.add_recommendation(
                title="this is a recommendation", button="go here", href="https://canvasmedical.com/"
            )
            diagnose = DiagnoseCommand(
                icd10_code="I10",
                background="feeling bad for many years",
                approximate_date_of_onset=date(2020, 1, 1),
                today_assessment="still not great",
            )
            p.recommendations.append(diagnose.recommend(title="this inserts a diagnose command"))
            if self.event.type in [EventType.PLUGIN_CREATED, EventType.PLUGIN_UPDATED]:
                p.patient_filter = {"active": True}
            else:
                p.patient_id = self.target
            return [p.apply()]
###  Supported Commands #
The following commands from the [commands module](/sdk/commands/) are
currently supported for insertion from Protocol Cards:
  * Allergy
  * Assess
  * Diagnose
  * FollowUp
  * Goal
  * HistoryOfPresentIllness
  * Image
  * Immunize
  * Instruct
  * LabOrder
  * MedicationStatement
  * Perform
  * Plan
  * Prescribe
  * Questionnaire
  * ReasonForVisit
  * Refer
  * StructuredAssessment
  * Task
  * ValidateCodingGap
  * Vitals
----- END PAGE https://docs.canvasmedical.com/sdk/effect-protocol-cards/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-banner-alerts/
# Banner Alerts
Last updated: 7 Oct 2025
The Canvas SDK allows you to place Banners on the Canvas UI.
##  Adding a Banner Alert #
To add a banner alert, import the `AddBannerAlert` class and create an
instance of it.
Attribute| Â | Type| Description  
---|---|---|---  
patient_id| required (if patient_filter is not provided)| String| The id of
the [patient](/sdk/data-patient/) the alert should be associated with.  
patient_filter| required (if patient_id is not provided)| String| Patient
queryset filters to apply the effect to multiple patients. For example,
`{"active": True}` will apply to the effect to all active patients  
key| required| String| An identifier that categorizes the alert.  
narrative| required| String| The content of the alert. Maximum 90 characters.  
placement| required| list[Placement]| List of areas the alert should show.  
intent| optional| Intent| Affects the styling of the alert.  
href| optional| String| If given, the alert will appear as a link to this URL.  
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.banner_alert import AddBannerAlert
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            banner = AddBannerAlert(
                patient_id=self.target,
                key="test-alert",
                narrative="This is only a test.",
                placement=[
                    AddBannerAlert.Placement.CHART,
                    AddBannerAlert.Placement.APPOINTMENT_CARD,
                    AddBannerAlert.Placement.SCHEDULING_CARD,
                ],
                intent=AddBannerAlert.Intent.INFO,
                href="https://docs.canvasmedical.com",
            )
            return [banner.apply()]
To apply the effect to all active patients when a plugin is created or
updated, include the `PLUGIN_CREATED` and/or `PLUGIN_UPDATED` events in the
`RESPONDS_TO` list. Additionally, `patient_filter` can be used (instead of
`patient_id`) on the `AddBannerAlert` class.
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.banner_alert import AddBannerAlert
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PATIENT_UPDATED),
            EventType.Name(EventType.PLUGIN_CREATED),
            EventType.Name(EventType.PLUGIN_UPDATED),
        ]
        def compute(self):
            banner = AddBannerAlert(
                key="test-alert",
                narrative="This is only a test.",
                placement=[
                    AddBannerAlert.Placement.CHART,
                    AddBannerAlert.Placement.APPOINTMENT_CARD,
                    AddBannerAlert.Placement.SCHEDULING_CARD,
                ],
                intent=AddBannerAlert.Intent.INFO,
                href="https://docs.canvasmedical.com",
            )
            if self.event.type in [EventType.PLUGIN_CREATED, EventType.PLUGIN_UPDATED]:
                banner.patient_filter = {"active": True}
            else:
                banner.patient_id = self.target
            return [banner.apply()]
###  Placement #
This determines where the banner alert appears.
####  `Placement.CHART` #
This will place the banner under the patientâs name on their chart
![](/assets/images/sdk/banner-alerts/banner_alert_placement_chart.png)
####  `Placement.TIMELINE` #
This will place the banner on the top of the patientâs timeline of notes in
their chart
![](/assets/images/sdk/banner-alerts/banner_alert_placement_timeline.png)
####  `Placement.APPOINTMENT_CARD` #
This will appear when you click an appointment on the calendar view
![](/assets/images/sdk/banner-
alerts/banner_alert_placement_appointment_card.png)
####  `Placement.SCHEDULING_CARD` #
This will appear when you select a patient during the scheduling of an
appointment on the calendar view
![](/assets/images/sdk/banner-
alerts/banner_alert_placement_scheduling_card.png)
####  `Placement.PROFILE` #
This will place the banner under the patientâs name on their patient
registration page
![](/assets/images/sdk/banner-alerts/banner_alert_placement_profile.png)
###  Intent #
The type or severity of an alert. This will change the appearance of the
banner alert.
####  `Intent.INFO` #
![](/assets/images/sdk/banner-alerts/banner_alert_intent_info.png)
####  `Intent.WARNING` #
![](/assets/images/sdk/banner-alerts/banner_alert_intent_warning.png)
####  `Intent.ALERT` #
![](/assets/images/sdk/banner-alerts/banner_alert_intent_alert.png)
##  Removing a Banner Alert #
Removing a banner alert is done wih the `RemoveBannerAlert` class. Create an
instance of the class, identifying the key of the alert and the patient id.
Return the Effect by calling the `.apply()` method. Both the `key` and
`patient_id` attributes are required.
    from canvas_sdk.effects.banner_alert import RemoveBannerAlert
    banner_alert = RemoveBannerAlert(
        key='test-alert',
        patient_id="d4c933fe8f6948f6a7d2a42a2641b13b",
    )
    banner_alert.apply()
----- END PAGE https://docs.canvasmedical.com/sdk/effect-banner-alerts/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-billing-line-items/
# Billing Line Items
Last updated: 7 Nov 2025
The Canvas SDK allows you to create, update, and remove Billing Line Items
from the footer of a note.
##  Adding a Billing Line Item #
To add a billing line item to a note, import the `AddBillingLineItem` class,
create an instance of it, and return the `.apply()` method from compute.
Attribute| Â | Type| Description  
---|---|---|---  
note_id| required| String| The id of the [Note](/sdk/data-note/) where the
line item should be associated.  
cpt| required| String| The billing code to use for the line item.  
units| optional| Integer| The number of units to bill for the code. Defaults
to `1` if not provided.  
assessment_ids| optional| list[String]| List of Assessment ids from the note
that are relevant to the code, also referred to as âdiagnosis pointersâ.  
modifiers| optional| list[Coding]| The modifiers to create with the billing
code.  
**Example:**
     from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Command, Assessment
    from canvas_sdk.effects.billing_line_item import AddBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_ORIGINATE)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            note = command.note
            assessments = [
                str(i)
                for i in Assessment.objects.filter(note_id=note.dbid).values_list(
                    "id", flat=True
                )
            ]
            b = AddBillingLineItem(
                note_id=str(note.id),
                cpt="99213",
                units=1,
                assessment_ids=assessments,
                modifiers=[
                    {"code": "25", "system": "http://www.ama-assn.org/go/cpt"},
                    {"code": "59", "system": "http://www.ama-assn.org/go/cpt"},
                ],
            )
            return [b.apply()]
##  Updating a Billing Line Item #
To update a billing line item to a note, import the `UpdateBillingLineItem`
class, create an instance of it, and return the `.apply()` method from
compute.
Attribute| Â | Type| Description  
---|---|---|---  
billing_line_item_id| required| String| The id of the
[BillingLineItem](/sdk/data-billing-line-item/) to update.  
cpt| optional| String| The billing code to use for the line item.  
units| optional| Integer| The number of units to bill for the code.  
assessment_ids| optional| list[String]| List of Assessment ids from the note
that are relevant to the code, also referred to as âdiagnosis pointersâ.  
modifiers| optional| list[Coding]| The modifiers to create with the billing
code.  
**Example:**
     from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Assessment, Command, BillingLineItem
    from canvas_sdk.effects.billing_line_item import UpdateBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_COMMIT)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            note = command.note
            cpt = command.data["perform"]["value"]
            b_ids = BillingLineItem.objects.filter(cpt="99213", note=note).values_list(
                "id", flat=True
            )
            assessment = Assessment.objects.filter(note_id=note.dbid).first()
            updates = [
                UpdateBillingLineItem(
                    billing_line_item_id=str(b_id),
                    cpt=cpt,
                    units=1,
                    assessment_ids=[str(assessment.id)],
                    modifiers=[{"code": "47", "system": "http://www.ama-assn.org/go/cpt"}],
                )
                for b_id in b_ids
            ]
            return [update.apply() for update in updates]
##  Removing a Billing Line Item #
To remove a billing line item to a note, import the `RemoveBillingLineItem`
class, create an instance of it, and return the `.apply()` method from
compute.
Attribute| Â | Type| Description  
---|---|---|---  
billing_line_item_id| required| String| The id of the
[BillingLineItem](/sdk/data-billing-line-item/) to update.  
Â | Â | Â | Â   
**Example:**
     from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Command, BillingLineItem
    from canvas_sdk.effects.billing_line_item import RemoveBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_ENTER_IN_ERROR)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            cpt = command.data["perform"]["value"]
            note_id = command.note.dbid
            b_ids = BillingLineItem.objects.filter(cpt=cpt, note_id=note_id).values_list(
                "id", flat=True
            )
            return [
                RemoveBillingLineItem(billing_line_item_id=str(b_id)).apply()
                for b_id in b_ids
            ]
For more information about the BillingLineItem data class, check out [this
page](/sdk/data-billing-line-item).
----- END PAGE https://docs.canvasmedical.com/sdk/effect-billing-line-items/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/form-result-effect
# Form Result
Last updated: 7 Nov 2025
##  Overview #
Forms are a key part of the Patient Portal experience. They allow developers
to dynamically display questionnaires to patients based on various criteria
and optionally create a Questionnaire Command within a Note. Since these
effects are evaluated on every page load, itâs essential to ensure that only
the appropriate forms are shown.
##  Structure #
A Form Result effect consists of the following properties:
  * **questionnaire_id** : The unique identifier for the Questionnaire.
  * **create_command** : A boolean flag that, when set to `True`, creates a Questionnaire Command within a Note.
  * **note_id** : Optionally associates the effect with an existing Note.
These properties ensure that the effect integrates seamlessly with the rest of
the Canvas SDK.
###  **Attributes** #
Attribute| Type| Description  
---|---|---  
`questionnaire_id`| `str | UUID`| The unique ID of the Questionnaire.  
`create_command`| `bool`| If `True`, a Questionnaire Command is created inside
a Note.  
`note_id`| `str | UUID | None`| Associates the response with an existing Note if applicable.  
----- END PAGE https://docs.canvasmedical.com/sdk/form-result-effect


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/patient-metadata-create-form-effect
# Patient Metadata Create form
Last updated: 7 Nov 2025
##  Overview #
This allows developers to dynamically display additional fields in the patient
profile. For more guidance please reference [âHow to add additional profile
fieldsâ guide](https://docs.canvasmedical.com/guides/profile-additional-
fields/).
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    PatientMetadataCreateFormEffect(form_fields=[
        FormField(
            key='status',
            label='Status',
            type=InputType.SELECT,
            required=False,
            editable=True,
            options=["open", "close"]
        ),
    ])
##  Structure #
###  **FormField** #
A FormField consists of the following properties:
####  Attributes #
Attribute| Type| Description  
---|---|---  
`key`| `str`| unique identifier of the field - patient metadata key  
`label`| `str`| the label that will be displayed on the field  
`type`| `InputType`| the type of the input - TEXT, SELECT, DATE.  
`required`| `bool`| if the input is required.  
`editable`| `bool`| if the input can be editabled.  
`options`| `list[str]`| possible options for when the input type is set to
âSELECTâ  
###  **PatientMetadataCreateFormEffect** #
A PatientMetadataCreateFormEffect consists of the following properties:
####  Attributes #
Attribute| Type| Description  
---|---|---  
`form_fields`| `list[FormField]`| list of fields.  
----- END PAGE https://docs.canvasmedical.com/sdk/patient-metadata-create-form-effect


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/layout-effect/
# Layout Effects
Last updated: 11 Nov 2025
##  Patient Summary #
There are many summary sections in a patientâs chart, organized by data
type. While there is a default ordering, you can use an Effect to reorder them
or hide some of them entirely. The `PatientChartSummaryConfiguration` class
helps you craft the effect to do so.
![Before and after](/assets/images/sdk/summary-section-modified.png)
The example below shows reordering and hiding or omitting some of the
sections:
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    class SummarySectionLayout(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.CARE_TEAMS,
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.VITALS,
            ])
            return [layout.apply()]
The `PatientChartSummaryConfiguration` takes a single argument, `sections`,
which is expected to be a list at least one element long, filled with choices
from the `PatientChartSummaryConfiguration.Section` enum. The `.apply()`
method returns a well-formed `Effect` object.
This effect is only used in response to the
`PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event. It does nothing in any
other context.
Values in the `PatientChartSummaryConfiguration.Section` enum are:
Constant| Description  
---|---  
SOCIAL_DETERMINANTS| social_determinants  
GOALS| goals  
CONDITIONS| conditions  
MEDICATIONS| medications  
ALLERGIES| allergies  
CARE_TEAMS| care_teams  
VITALS| vitals  
IMMUNIZATIONS| immunizations  
SURGICAL_HISTORY| surgical_history  
FAMILY_HISTORY| family_history  
CODING_GAPS| coding_gaps  
###  Action Buttons #
Each section of the patient chart can also be customized with action buttons.
Please refer to the [Action Buttons](/sdk/handlers-action-buttons/)
documentation for more information.
##  Patient Profile #
The `PatientProfileConfiguration` class allows you to reorder, hide, and/or
specificy whether sections load expanded or collapsed.
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.effects.patient_profile_configuration import PatientProfileConfiguration
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        """This protocol is used to configure which sections appear in the Patient Profile section.
        The SHOW_PATIENT_PROFILE_SECTIONS payload expects a list of sections where each section is a dict like { "type": str, "start_expanded": bool }
        The accepted values for the "type" are:
        "demographics", "preferences", "preferred_pharmacies", "patient_consents",
        "care_team", "parent_guardian", "addresses", "phone_numbers", "emails", "contacts"
        """
        # Name the event type you wish to run in response to
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PROFILE__SECTION_CONFIGURATION)
        def compute(self) -> list[Effect]:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            sections = [
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PREFERENCES,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.DEMOGRAPHICS,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(
                    type=PatientProfileConfiguration.Section.PREFERRED_PHARMACIES, start_expanded=True),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PARENT_GUARDIAN,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.CONTACTS,
                                                    start_expanded=True),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.CARE_TEAM,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.TELECOM,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.ADDRESSES,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PATIENT_CONSENTS,
                                                    start_expanded=False),
            ]
            effect = PatientProfileConfiguration(sections=sections).apply()
            return [effect]
The `PatientProfileConfiguration` takes a single argument, `sections`, which
is expected to be a list at least one element long, filled with
`PatientProfileConfiguration.Payload` objects. These are python typed
dictionaries that expect a `PatientProfileConfiguration.Section` choice, which
describes a section of the patient profile, and a `start_expanded` boolean,
which determines if the fields in that section should be exposed by default.
The `.apply()` method returns a well-formed `Effect` object.
This effect is only used in response to the
`PATIENT_PROFILE__SECTION_CONFIGURATION` event. It does nothing in any other
context.
Values in the `PatientProfileConfiguration.Section` enum are:
Constant| Description  
---|---  
DEMOGRAPHICS| demographics  
PREFERENCES| preferences  
PREFERRED_PHARMACIES| preferred_pharmacies  
PATIENT_CONSENTS| patient_consents  
CARE_TEAM| care_team  
PARENT_GUARDIAN| parent_guardian  
ADDRESSES| addresses  
TELECOM| telecom  
CONTACTS| contacts  
##  Panel Configuration #
This effect allows you to define which panel buttons should be displayed on
the main page or the patient page.
The order of the buttons in the array will determine their order on the panel.
![Before and after](/assets/images/sdk/panel-configuration-before-
after.png)(width:70%)
    from canvas_sdk.effects.panel_configuration import PanelConfiguration
    PanelConfiguration(
      sections=[
        PanelConfiguration.PanelPatientSection.REFILL_REQUEST,
        PanelConfiguration.PanelPatientSection.LAB_REPORT,
        PanelConfiguration.PanelPatientSection.CHANGE_REQUEST,
        PanelConfiguration.PanelPatientSection.TASK,
    ], page=PanelConfiguration.Page.PATIENT).apply()
A PanelConfiguration effect consists of the following properties:
###  Attributes #
Attribute| Type| Description  
---|---|---  
`sections`| `list[PanelPatientSection] or list[PanelGlobalSection]`| list of
section items.  
`page`| `Page`| PATIENT or GLOBAL.  
Values in the `PanelGlobalSection` enum are:
Constant| Description  
---|---  
APPOINTMENT| appointment  
CHANGE_REQUEST| changeRequest  
IMAGING_REPORT| imagingReport  
INPATIENT_STAY| inpatientStay  
LAB_REPORT| labReport  
MESSAGE| message  
OUTSTANDING_REFERRAL| outstandingReferral  
PRESCRIPTION_ALERT| prescriptionAlert  
RECALL_APPOINTMENT| recallAppointment  
REFERRAL_REPORT| referralReport  
REFILL_REQUEST| refillRequest  
TASK| task  
UNCATEGORIZED_DOCUMENT| uncategorizedDocument  
Values in the `PanelPatientSection` enum are:
Constant| Description  
---|---  
CHANGE_REQUEST| changeRequest  
COMMAND| command  
IMAGING_REPORT| imagingReport  
INPATIENT_STAY| inpatientStay  
LAB_REPORT| labReport  
PRESCRIPTION_ALERT| prescriptionAlert  
REFERRAL_REPORT| referralReport  
REFILL_REQUEST| refillRequest  
TASK| task  
UNCATEGORIZED_DOCUMENT| uncategorizedDocument  
##  Modals #
The `LaunchModalEffect` class allows you to launch modals in Canvas, providing
a flexible way to display content or navigate to external resources.
###  Example Usage #
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    class ModalEffectHandler:
        def compute(self):
            modal_effect = LaunchModalEffect(
                url="https://example.com/info",
                content=None,
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL,
                title="Example Info"
            )
            return [modal_effect.apply()]
The `LaunchModalEffect` class has the following properties:
  * **url** : A string containing the URL to load within the modal. If `content` is also specified, an error will be raised.
  * **content** : A string containing the content to be displayed directly within the modal. If `url` is also provided, an error will be raised.
  * **target** : Defines where the modal should be launched. Options include:
    * `DEFAULT_MODAL`: Opens the URL in a modal centered on the screen.
    * `NEW_WINDOW`: Opens the content in a new browser window.
    * `RIGHT_CHART_PANE`: Opens the URL in the right-hand pane of the patient chart.
    * `RIGHT_CHART_PANE_LARGE`: Like above, but a bit wider.
  * **title** : A string containing the title of the modal and will be displayed when minimized. Defaults to `Untitled`
###  Closing Modals from Applications #
When building applications with the Canvas SDK, you may encounter scenarios
where you need to programmatically dismiss modals. This can be particularly
useful in automated testing or when creating user flows that require closing
modals based on certain conditions.
Hereâs a simple example of how to dismiss modals from your applications
using JavaScript.
    <script>
        let messagePort = null;
        // Listen for the port transfer from the Canvas Application
        window.addEventListener('message', (event) => {
          // Check if this is the INIT_CHANNEL message with a port
          if (event.data?.type === 'INIT_CHANNEL' && event.ports[0]) {
            // Store the port for later use
            messagePort = event.ports[0];
            messagePort.start();
            messagePort.postMessage({ type: 'CLOSE_MODAL' });
          }
        });
    </script>
And thatâs it! This script establishes a communication channel with the
Canvas Application by listening for the `INIT_CHANNEL` event, capturing the
message port, and then sending a `CLOSE_MODAL` message through that port to
close any open modals when the application loads. You can customize the event
listener to trigger the modal dismissal based on your specific requirements.
While developers might find odd to be sending a message to themselves, this is
the current method supported by the Canvas SDK for dismissing modals, in order
to avoid potential security issues with cross-origin messaging and flooding
the main application with messages.
This twist on the _Holywood Principle_ ensures that your application remains
secure while still providing the functionality needed to manage modals
effectively.
##  Portal Landing Page Widgets #
The `PortalWidget` class allows you to add widgets of various sizes to the
patient portal landing page. You can fully customize your widgets or leverage
ready-made widgets provided by Canvas, such as Appointments and Messaging.
###  Example Usage #
    from canvas_sdk.effects.widgets import PortalWidget
    class PortalWidgetHandler:
        def compute(self):
            portal_widget = PortalWidget(
                url="https://example.com/info",
                size=PortalWidget.Size.COMPACT,
                priority=25
            )
            return [portal_widget.apply()]
The `PortalWidget` class has the following properties:
  * **url** : A string containing the URL to load within the widget. If either `content` or `component` is specified, an error will be raised.
  * **content** : A string containing the content to be displayed directly within the widget. If either `url` or `component` is provided, an error will be raised.
  * **component** : Choose one of ready-made widgets made by Canvas. If either `url` or `content` is provided, an error will be raised. The available ready-made widgets include:
    * `APPOINTMENTS`: Displays upcoming appointments.
    * `MESSAGING`: Enables quick messaging.
  * **Size** : Determines the widgetâs layout on the frontend grid:
    * `EXPANDED`: Fills an entire row (12 columns).
    * `MEDIUM`: Occupies 8 columns.
    * `COMPACT`: Occupies 4 columns.
    * **Note: All sizes have a fixed height of 300px.**
  * **priority** : This value is used to order the widgets within the patient portal. A lower number indicates a higher priority.
##  Custom HTML and Django Templates #
To facilitate the use of custom HTML, you can utilize the `render_to_string`
utility from `canvas_sdk.templates` to render Django templates with a
specified context. This allows for dynamic rendering of HTML that can be
passed to a `LaunchModalEffect` or `PortalWidget`.
    from typing import Any
    def render_to_string(template_name: str, context: dict[str, Any] | None = None) -> str | None:
        """Load a template and render it with the given context.
        Args:
            template_name (str): The path to the template file, relative to the plugin package.
                If the path starts with a forward slash ("/"), it will be stripped during resolution.
            context (dict[str, Any] | None): A dictionary of variables to pass to the template
                for rendering. Defaults to None, which uses an empty context.
        Returns:
            str: The rendered template as a string.
        Raises:
            FileNotFoundError: If the template file does not exist within the plugin's directory
                or if the resolved path is invalid.
        """
####  Example Template #
Consider a simple HTML file named `templates/custom_content.html`:
    <!DOCTYPE html>
    <html>
      <head>
        <title>{{ title }}</title>
      </head>
      <body>
        <h1>{{ heading }}</h1>
        <p>{{ message }}</p>
      </body>
    </html>
This template uses Django template placeholders like `{{ title }}`, `{{
heading }}`, and `{{ message }}` to dynamically render content based on the
provided context.
####  Rendering the Template in Python #
Hereâs how you can use the `render_to_string` utility to render the template
and pass the resulting HTML to a `LaunchModalEffect` or `PortalWidget`:
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.templates import render_to_string
    class ModalEffectHandler:
        def compute(self):
            # Define the context for the template
            context = {
                "title": "Welcome Modal",
                "heading": "Hello, User!",
                "message": "This is a dynamically rendered modal using Django templates."
            }
            # Render the HTML content using the template and context
            rendered_html = render_to_string("templates/custom_content.html", context)
            # Create a LaunchModalEffect with the rendered content
            modal_effect = LaunchModalEffect(
                content=rendered_html,
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL
            )
            return [modal_effect.apply()]
    class PortalWidgetHandler:
        def compute(self):
            # Define the context for the template
            context = {
                "title": "Welcome Modal",
                "heading": "Hello, User!",
                "message": "This is a dynamically rendered modal using Django templates."
            }
            # Render the HTML content using the template and context
            rendered_html = render_to_string("templates/custom_content.html", context)
            # Create a PortalWidget with the rendered content
            portal_widget = PortalWidget(
                content=rendered_html,
                size=PortalWidget.Size.COMPACT,
                priority=25
            )
            return [portal_widget.apply()]
##  Additional Configuration #
To use URLs or custom scripts within the `LaunchModalEffect` or
`PortalWidget`, additional security configurations must be specified in the
`CANVAS_MANIFEST.json` file of your plugin.
  * **Allowing URLs** : URLs specified in the **url** property must be added to the `url_permissions` section of the `CANVAS_MANIFEST.json` in order for the URL to load properly.
  * **Allowing custom scripts** : If you need to load scripts from an external source, the URL for the script must be added to the `url_permissions` section of the `CANVAS_MANIFEST.json` and `'SCRIPTS'` must be in the permissions list.
  * **Requesting microphone access** : If the site in your modal or widget needs microphone access, `'MICROPHONE'` must be in the URLâs permissions list.
  * **Requesting camera access** : If the site in your modal or widget needs camera access, `'CAMERA'` must be in the URLâs permissions list.
  * **Allowing browser access to cookies from the iframeâs origin** : If you want the loaded URL to access cookies for its domain, `'ALLOW_SAME_ORIGIN'` must be in the URLâs permissions list. If the URL youâre loading requires authentication, this will prevent your user from having to log in each time the modal is launched.
The URLs must match the format available
[here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-
Security-Policy#host-source).
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "custom_html",
      "description": "...",
      "url_permissions": [
        {
          "url": "https://example.com/info",
          "permissions": ["ALLOW_SAME_ORIGIN", "MICROPHONE", "CAMERA"]
        },
        {
          "url": "https://d3js.org/d3.v4.js",
          "permissions": ["SCRIPTS"]
        }
      ]
    }
----- END PAGE https://docs.canvasmedical.com/sdk/layout-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-questionnaires/
# Questionnaires
Last updated: 7 Nov 2025
The Canvas SDK includes functionality for handling questionnaire-related
events.
##  Creating a Questionnaire #
Creating a questionnaire via the SDK requires current requires defining a YAML
template and referencing it in your `CANVAS_MANIFEST.json` file. Read more
[here](/sdk/questionnaires/).
##  Creating a Questionnaire Result #
The `CreateQuestionnaireResult` effect causes a new entry to appear in the
Social Determinants section of the left side of the chart.
This effect enables custom scoring of questionnaires in Canvas.
###  Example #
**Note:** This example assumes that an M-CHAT questionnaire created and loaded
into the Canvas instance.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.questionnaire_result import CreateQuestionnaireResult
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.command import Command
    class MChatQuestionnaireResult(BaseProtocol):
        """
        Return a CreateQuestionnaireResult effect in response to a committed Questionnaire Command that
        contains questions coded for the M-CHAT questionnaire.
        """
        RESPONDS_TO = [EventType.Name(EventType.QUESTIONNAIRE_COMMAND__POST_COMMIT)]
        MCHAT_CODE_SYSTEM = "INTERNAL"
        MCHAT_CODE = "mchat"
        def compute(self) -> list[Effect]:
            # Get the interview object, which will be the anchor object on the Questionnaire command.
            command = Command.objects.get(id=self.event.target.id)
            interview = command.anchor_object
            if not interview.committer:
                return []
            # Return no effects if the interview has no questions that are coded as M-CHAT questions
            if not any(
                q.code == self.MCHAT_CODE and q.code_system == self.MCHAT_CODE_SYSTEM
                for q in interview.questionnaires.all()
            ):
                return []
            # sum up the numerical value of each answered questionnaire
            score = 0
            for response in interview.interview_responses.all():
                score = score + int(response.response_option.value)
            # Determine the narrative and whether the result is abnormal
            if score >= 0 and score <= 2:
                abnormal = False
                narrative = (
                    "The score is LOW risk. Child has screened negative. No immediate follow-up is "
                    "needed. However, the child should be rescreened at 24 months or after 3 months "
                    "have passed if they are younger than 2 years. Monitoring the child's "
                    "development remains important."
                )
            elif score >= 3 and score <= 7:
                abnormal = True
                narrative = (
                    "The score is MODERATE risk. Administer the M-CHAT-R Follow-Up items that "
                    "correspond to the at-risk responses. Only those items which were scored at risk "
                    "need to be completed. If 2 or more items continue to be at-risk, refer the "
                    "child immediately for (a) early intervention and (b) diagnostic evaluation."
                )
            elif score >= 8 and score <= 20:
                abnormal = True
                narrative = (
                    "The score is HIGH risk. It is not necessary to complete the M-CHAT-R Follow-Up "
                    "at this time. Bypass Follow-Up, and refer immediately for (a) early "
                    "intervention and (b) diagnostic evaluation."
                )
            else:
                abnormal = True
                narrative = "Error occurred trying to score questionnaire."
            # Create and return the effect
            effect = CreateQuestionnaireResult(
                interview_id=str(interview.id),
                score=score,
                abnormal=abnormal,
                narrative=narrative,
                code_system=self.MCHAT_CODE_SYSTEM,
                code=self.MCHAT_CODE,
            )
            return [effect.apply()]
----- END PAGE https://docs.canvasmedical.com/sdk/effect-questionnaires/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-tasks/
# Tasks
Last updated: 7 Nov 2025
The Canvas SDK includes functionality to create, update and add comments to
tasks in Canvas.
##  Adding a Task #
To add a task, import the `AddTask` class and create an instance of it.
Attribute| Â | Type| Description  
---|---|---|---  
id| optional| string or UUID| Task unique UUID. If none one will be generated
automatically.  
assignee_id| optional| string| The id of the [staff](/sdk/data-staff/) the
task should be assigned to.  
team_id| optional| string| The id of the [team](/sdk/data-team/) the task
should be assigned to.  
patient_id| optional| string| The id of the [patient](/sdk/data-patient/) the
task is associated with.  
title| required| string| The title of the task. This is displayed at the top
of a task card in the Canvas UI.  
due| optional| datetime| A date/time when the task is due.  
status| optional| TaskStatus| A status of OPEN, CLOSED or COMPLETED. Defaults
to OPEN if not supplied.  
labels| optional| list[string]| A list of labels that will be added at the
bottom of a task card in the Canvas UI.  
author_id| optional| string or UUID| Authorâs id to set task creator,
defaults to CanvasBot.  
linked_object_id| optional| string or UUID| Linked object id of linked object.  
linked_object_type| optional| LinkableObjectType| Type of the LinkedObject  
###  Enumeration Type #
####  Linked Object Type #
Value| Description  
---|---  
REFERRAL| REFERRAL  
IMAGING| IMAGING  
An example of adding a task:
    import arrow
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.task import AddTask, AddTaskComment, UpdateTask, TaskStatus
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.staff import Staff
    from canvas_sdk.v1.data.team import Team
    from canvas_sdk.v1.data.referral import Referral
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.LAB_REPORT_CREATED),
        ]
        def compute(self) -> list[Effect]:
            lab_report = LabReport.objects.get(id=self.target)
            staff_assignee = Staff.objects.get(last_name="Weed")
            team = Team.objects.get(name="Labs")
            linked_task_type = AddTask.LinkableObjectType.REFERRAL
            referral = Referral.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
            if lab_report.patient:
                add_task = AddTask(
                    assignee_id=staff_assignee.id,
                    author_id=staff_assignee.id,
                    team_id = team.id,
                    patient_id=lab_report.patient.id,
                    title="Please call the patient with their test results.",
                    due=arrow.utcnow().shift(days=5).datetime,
                    status=TaskStatus.OPEN,
                    labels=["call"],
                    linked_object_id=referral.id,
                    linked_object_type=linked_task_type,
                )
                return [add_task.apply()]
            return []
##  Updating a Task #
To update an existing task, import the `UpdateTask` class and create an
instance of it.
Attribute| Â | Type| Description  
---|---|---|---  
id| required| string| The id of the task being updated.  
assignee_id| optional| string| The id of the [staff](/sdk/data-staff/) the
task should be assigned to.  
team_id| optional| string| The id of the [team](/sdk/data-team/) the task
should be assigned to.  
patient_id| optional| string| The id of the [patient](/sdk/data-patient/) the
task is associated with.  
title| optional| string| The title of the task. This is displayed at the top
of a task card in the Canvas UI.  
due| optional| datetime| A date/time when the task is due.  
status| optional| TaskStatus| A status of `OPEN`, `CLOSED` or `COMPLETED`.
Defaults to `OPEN` if not supplied.  
labels| optional| list[string]| A list of labels that will be added at the
bottom of a task card in the Canvas UI.  
An example of updating a task to a status of `COMPLETED`:
    from canvas_sdk.effects.task import UpdateTask, TaskStatus
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            update_task = UpdateTask(
                id="d06276ba-85c5-471b-87c0-9c9805f4ca6f",
                status=TaskStatus.COMPLETED,
            )
            return [update_task.apply()]
##  Adding a comment to a task #
To add a comment to a task, import the `AddTaskComment` class and create an
instance of it.
Attribute| Â | Type| Description  
---|---|---|---  
task_id| required| string| The id of the task being updated.  
body| required| string| The comment body.  
author_id| optional| string or UUID| Authorâs id to set task comment
creator, defaults to CanvasBot.  
    from canvas_sdk.effects.task import AddTaskComment
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.staff import Staff
    class Protocol(BaseHandler):
        def compute(self):
            author = Staff.objects.get(last_name="Weed")
            add_task_comment = AddTaskComment(
                task_id="d06276ba-85c5-471b-87c0-9c9805f4ca6f",
                body="I tried to call the patient but did not get an answer.",
                author_id=author.id
            )
            return [add_task_comment.apply()]
----- END PAGE https://docs.canvasmedical.com/sdk/effect-tasks/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/patient-portal/
# Patient Portal
Last updated: 7 Nov 2025
The Canvas SDK allows you to configure the patient portal.
##  Configuring the Patient Portal #
To configure the patient portal, you can use the
`PatientPortalApplicationConfiguration` effect
Attribute| Type| Description  
---|---|---  
can_schedule_appointments| bool| If the patient is allowed to book or
reschedule appointments  
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient_portal.application_configuration import PatientPortalApplicationConfiguration
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__GET_APPLICATION_CONFIGURATION)
        def compute(self) -> list[Effect]:
            return [
              PatientPortalApplicationConfiguration(
                can_schedule_appointments=True
              ).apply()
            ]
##  Customize Landing Page (Portal Widgets) #
To customize the landing page you can leverage the [Portal
Widgets](/sdk/layout-effect/#portal-landing-page-widgets) effect.
Visit our guide [Tailoring Portal Landing Page](/guides/custom-landing-page/)
for examples.
##  Customize Appointment Cards #
Customize your patient appointment cards so patients can easily join their
telehealth appointments, cancel or reschedule appointments. Each appointment
can be customized individually, allowing each one to have its own unique
settings.
###  Hide âCancelâ button #
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_BE_CANCELED)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_IS_CANCELABLE,
                payload=json.dumps({"result": False}))
            ]
###  Hide âRescheduleâ button #
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_BE_RESCHEDULED)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_IS_RESCHEDULABLE,
                payload=json.dumps({"result": False}))
            ]
###  Hide âJoinâ button #
This button shows on telehealth appointments
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_SHOW_MEETING_LINK)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_SHOW_MEETING_LINK,
                payload=json.dumps({"result": True}))
            ]
##  Update User #
This effect is intended for updating a userâs phone number or email. In the
future, we may expand its capabilities to support additional attributes, but
for now, only these two are supported.
Attribute| Type| Description  
---|---|---  
`user_dbid`| `str | UUID`| The unique ID of the User.  
`phone_number`| `str`| Specifies the phone number to be stored.  
`email`| `str`| Specifies the email to be stored.  
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.update_user import UpdateUserEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import PatientContactPoint
    class ContactPoint(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.PATIENT_CONTACT_POINT_UPDATED)]
        def compute(self) -> list[Effect]:
            contact_point = PatientContactPoint.objects.get(id=self.target)
            patient = contact_point.patient
            return [
                UpdateUserEffect(user_dbid=patient.user.dbid, email="test@email.com", phone_number="1234567890").apply(),
            ]
##  Send Invite #
This effect triggers a portal invitation that allows the patient to register
or activate their account on the patient portal.
Attribute| Type| Description  
---|---|---  
`user_dbid`| `str | UUID`| The unique ID of the User.  
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.send_invite import SendInviteEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import PatientContactPoint
    class ContactPoint(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.PATIENT_CONTACT_POINT_UPDATED)]
        def compute(self) -> list[Effect]:
            contact_point = PatientContactPoint.objects.get(id=self.target)
            patient = contact_point.patient
            return [
                SendInviteEffect(user_dbid=patient.user.dbid).apply(),
            ]
##  Send Contact Verification #
The `SendContactVerification` effect instructs Canvas to send a verification
(for example, an email or SMS code) to a specific Patient Contact Point.
Typical uses are verifying a patientâs email address or phone number before
enabling patient-portal features that require a verified contact channel.
Attribute| Type| Description  
---|---|---  
`contact_point_id`| `str` or `UUID`| The id of the
[`PatientContactPoint`](/sdk/effect-patient/#patientcontactpoint) to verify.  
###  Validation & Errors #
When an effect is prepared, the model validates inputs and returns structured
error details if something is invalid.
  * **Contact Point Exists** â The effect verifies the provided `contact_point_id` maps to an existing `PatientContactPoint` record. If no matching record exists the effect will include an error detail with message: `Patient Contact Point does not exist`.
###  Caveats #
  * Emitting this effect will trigger a save to the associated `PatientContactPoint`. If your plugin sends `SendContactVerification` in direct response to a `PATIENT_CONTACT_POINT_UPDATED` event, the save triggered by the effect can cause the same event to fire again, producing an infinite event loop. To avoid this, debounce or detect origin (for example, ignore updates originating from the plugin runner or set a transient flag on the model) before emitting the effect in response to contact point update events.
###  Example Usage #
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.send_contact_verification import SendContactVerificationEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CONTACT_POINT_CREATED)
        def compute(self) -> list[Effect]:
            contact_point_id = self.event.target
            verification_effect = SendContactVerificationEffect(contact_point_id=contact_point_id)
            return [verification_effect.apply()]
###  Notes #
  * This effect only triggers a verification send for the contact point. It does not mark the contact as verified â verification completion is handled by the platform when the patient completes the challenge.
  * The effect relies on `PatientContactPoint` existing in the database. If your integration creates contact points in the same operation, ensure they are persisted before emitting this effect.
----- END PAGE https://docs.canvasmedical.com/sdk/patient-portal/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-patient/
# Patient Effect
Last updated: 7 Nov 2025
The `Patient` effect enables the creation and updating of patient records
within the Canvas system. This effect captures demographic information,
contact details, and clinical associations necessary for patient registration
and updates.
##  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`first_name`| `str`| Patientâs first name| Yes  
`last_name`| `str`| Patientâs last name| Yes  
`middle_name`| `str` or `None`| Patientâs middle name| No  
`birthdate`| `datetime.date` or `None`| Patientâs date of birth| No  
`prefix`| `str` or `None`| Name prefix (e.g., âDr.â, âMr.â)| No  
`suffix`| `str` or `None`| Name suffix (e.g., âJr.â, âIIIâ)| No  
`sex_at_birth`| `PersonSex` or `None`| Patientâs sex assigned at birth| No  
`nickname`| `str` or `None`| Patientâs preferred name or nickname| No  
`social_security_number`| `str` or `None`| Patientâs SSN| No  
`administrative_note`| `str` or `None`| Administrative notes about the
patient| No  
`clinical_note`| `str` or `None`| Clinical notes about the patient| No  
`default_location_id`| `str` or `None`| ID of patientâs default practice
location| No  
`default_provider_id`| `str` or `None`| ID of patientâs default healthcare
provider| No  
`previous_names`| `list[str]` or `None`| List of patientâs previous names|
No  
`contact_points`| `list[PatientContactPoint]` or `None`| Patientâs contact
information| No  
`external_identifiers`| `list[PatientExternalIdentifier]` or `None`|
Patientâs external identifiers| No  
`patient_id`| `str` or `None`| Patient ID (required for updates only)| No  
`addresses`| `list[PatientAddress]` or `None`| Patientâs addresses| No  
`preferred_pharmacies`| `list[PatientPreferredPharmacy]` or `None`|
Patientâs preferred pharmacies| No  
`preferred_pharmacies`| `list[PatientMetadata]` or `None`| Patient metadata|
No  
##  PatientContactPoint #
The `PatientContactPoint` dataclass represents various methods of contacting
the patient.
###  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`system`| `ContactPointSystem`| Type of contact (e.g., phone, email)| Yes  
`value`| `str`| The contact information value (e.g., phone number, email
address)| Yes  
`use`| `ContactPointUse`| Purpose of the contact point (e.g., home, work)| Yes  
`rank`| `int`| Priority order of contact methods| Yes  
`has_consent`| `bool` or `None`| Whether consent has been given to use this
contact method| No  
##  PatientExternalIdentifier #
The `PatientExternalIdentifier` dataclass represents an external identifier
(ID) associated with the patient. An example would be the unique patient ID
for a third party system integrated with Canvas EMR.
###  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`system`| `str`| URL of the system of origin for the external ID (e.g.,
`http://hl7.org/fhir/sid/us-ssn`)| Yes  
`value`| `str`| The external ID or membership number/value| Yes  
##  PatientAddress #
The `PatientAddress` dataclass represents a patientâs address information.
###  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`line1`| `str`| Street address line 1| Yes  
`line2`| `str` or `None`| Street address line 2| No  
`city`| `str`| City name| Yes  
`state_code`| `str`| State code (e.g., âCAâ, âNYâ)| Yes  
`postal_code`| `str`| Postal/ZIP code| Yes  
`country`| `str`| Country code| Yes  
`use`| `AddressUse`| Address type (e.g., home, work)| Yes  
Address updates are **replace-based**. When updating a patient's addresses,
the provided address list will completely replace all existing addresses. If
you provide an empty list, all existing addresses will be deleted.
##  PatientPreferredPharmacy #
The `PatientPreferredPharmacy` dataclass represents a patientâs preferred
pharmacy, and if itâs their default pharmacy.
Attribute| Type| Description| Required  
---|---|---|---  
`ncpdp_id`| `str`| The ncpdp ID of the pharmacy| Yes  
`default`| `bool`| True if itâs the default pharmacy| Yes  
##  PatientMetadata #
The `PatientMetadata` dataclass represents a custom key-value pair for a
patient.
Attribute| Type| Description| Required  
---|---|---|---  
`key`| `str`| The key of the metadata| Yes  
`value`| `str`| The value of the metadata| Yes  
##  Implementation Details #
  * **Creation** : Creates new patient records when `patient_id` is not provided
  * **Updates** : Updates existing patient records when `patient_id` is provided
  * Validates that referenced practice locations exist in the system
  * Verifies that referenced healthcare providers exist in the system
  * Structures contact information through the `PatientContactPoint` dataclass
  * Structures external identifier through the `PatientExternalIdentifier` dataclass
  * Structures address information through the `PatientAddress` dataclass
  * Structures metadata through the `PatientMetadata` dataclass
##  Example Usage #
    from canvas_sdk.effects.patient import Patient, PatientContactPoint, PatientExternalIdentifier, PatientMetadata
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.common import ContactPointSystem, ContactPointUse, PersonSex
    import datetime
    class Protocol(BaseHandler):
        def compute(self):
            patient = Patient(
                first_name="Jane",
                last_name="Doe",
                middle_name="Marie",
                birthdate=datetime.date(1980, 1, 15),
                sex_at_birth=PersonSex.SEX_FEMALE,
                nickname="Janie",
                default_location_id="location-uuid",
                default_provider_id="provider-uuid",
                contact_points=[
                    PatientContactPoint(
                        system=ContactPointSystem.PHONE,
                        value="555-123-4567",
                        use=ContactPointUse.MOBILE,
                        rank=1,
                        has_consent=True
                    ),
                    PatientContactPoint(
                        system=ContactPointSystem.EMAIL,
                        value="jane.doe@example.com",
                        use=ContactPointUse.WORK,
                        rank=2,
                        has_consent=True
                    )
                ],
                external_identifiers=[
                    PatientExternalIdentifier(
                        system="http://www.aaa.com",
                        value="pat_id_123456"
                    )
                ],
                metadata = [
                    PatientMetadata(key="source", value="plugin"),
                    PatientMetadata(key="created_on", value=datetime.datetime.now().isoformat())
                ]
            )
            return [patient.create()]
#  Patient Update Example #
    from canvas_sdk.effects.patient import Patient, PatientAddress, PatientExternalIdentifier
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.common import AddressUse
    class Protocol(BaseHandler):
        def compute(self):
            # Update an existing patient
            updated_patient = Patient(
                patient_id="existing-patient-uuid",
                first_name="Jane",
                last_name="Smith",  # Changed last name
                addresses=[
                    PatientAddress(
                        line1="456 Updated Street",
                        line2="Suite 200",
                        city="Updated City",
                        state_code="CA",
                        postal_code="90210",
                        country="US",
                        use=AddressUse.HOME
                    )
                ],
                external_identifiers=[
                    PatientExternalIdentifier(
                        system="http://www.updated-system.com",
                        value="new_patient_id_789"
                    )
                ]
            )
            return [updated_patient.update()]
##  Validation #
The effect performs validation before execution to ensure data integrity:
  1. **Required Fields** :
     * For creation: Validates that mandatory fields like `first_name` and `last_name` are provided
     * For updates: Requires `patient_id` to be provided and verifies the patient exists in the database
  2. **Referenced Entity Validation** : Confirms that any referenced entities exist in the system:
     * Verifies that the specified default practice location exists
     * Ensures that the specified default provider exists
  3. **Data Format Validation** : Ensures that provided values conform to expected formats:
     * Date fields must be valid dates
     * Enumerated types like `PersonSex`, `ContactPointSystem`, and `ContactPointUse` must contain valid values
  4. **Update-Specific Validation** :
     * Ensures `patient_id` is not provided during patient creation
     * Validates that the patient exists before attempting updates
----- END PAGE https://docs.canvasmedical.com/sdk/effect-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-notes/
# Note Effects
Last updated: 7 Nov 2025
The Canvas SDK provides effects to facilitate creating, updating, and managing
**visit notes** , **appointments** , and **schedule events**. Below youâll
find detailed documentation for each effect type and their operations.
##  Note Effect #
The `Note` effect facilitates the creation and updating of visit notes for
patients.
###  Create Note #
Creates a new note. Can be passed an optional UUID as `instance_id` from the
`uuid.uuid4` library, or will be assigned one if not present. Passing a user-
set UUID as the `instance_id` allows for [assigning commands to the
note](/sdk/commands/#chaining-methods-with-a-user-set-uuid) in the same plugin
action.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier for the note| No  
`note_type_id`| `UUID` or `str`| Identifier for the note type| Yes  
`datetime_of_service`| `datetime.datetime`| When the service was provided| Yes  
`patient_id`| `str`| Identifier for the patient| Yes  
`practice_location_id`| `UUID` or `str`| Identifier for the practice location|
Yes  
`provider_id`| `str`| Identifier for the provider| Yes  
`title`| `str` or `None`| Optional title for the note| No  
####  Implementation Details #
  * Validates that the note type exists and has an appropriate category
  * Ensures the patient exists in the system
  * Verifies that the practice location and provider are valid
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(
                note_type_id="note-type-uuid",
                datetime_of_service=datetime.datetime.now(),
                patient_id="patient-uuid",
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return [note_effect.create()]
###  Update Note #
Updates an existing note. Only certain fields can be modified after creation.
####  Attributes #
Attribute| Type| Description| Required| Updatable  
---|---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of the note to update| Yes| No  
`title`| `str` or `None`| Updated title for the note| No| Yes  
`datetime_of_service`| `datetime.datetime`| Updated service date/time| No| Yes  
`practice_location_id`| `UUID` or `str`| Updated practice location| No| Yes  
`provider_id`| `str`| Updated provider| No| Yes  
**Note** : `patient_id` and `note_type_id` cannot be updated after creation.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            note_effect.title = "Updated Consultation Notes"
            note_effect.datetime_of_service = datetime.datetime.now()
            return [note_effect.update()]
###  Fax Note #
Sends an existing note via fax to a specified recipient. This effect allows
you to transmit patient notes to external healthcare providers or facilities.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`note_id`| `UUID` or `str`| Identifier of the note to fax| Yes  
`recipient_name`| `str`| Name of the fax recipient| Yes  
`recipient_fax_number`| `str`| Fax number of the recipient. Should include the
country code| Yes  
`include_coversheet`| `bool`| Whether to include a coversheet with the fax| No  
`subject`| `str` or `None`| Subject line for the coversheet (required if
coversheet used)| No  
`comment`| `str` or `None`| Additional comments for coversheet (required if
coversheet used)| No  
`location_id`| `UUID` or `str` or `None`| Practice location ID (required if
coversheet used)| No  
####  Implementation Details #
  * Validates that the note exists in the system
  * If `include_coversheet` is `True`, the following fields become required:
    * `subject`: The subject line for the coversheet
    * `comment`: Additional comments to include on the coversheet
    * `location_id`: The practice location identifier (must exist in the system)
  * Validates that the practice location exists if provided
####  Example Usage #
    from canvas_sdk.effects.fax.note import FaxNoteEffect
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            # Basic fax without coversheet
            fax_effect = FaxNoteEffect(
                note_id="existing-note-uuid",
                recipient_name="Dr. Jane Smith",
                recipient_fax_number="15551234567"
            )
            return [fax_effect.apply()]
####  Example with Coversheet #
    from canvas_sdk.effects.fax.note import FaxNoteEffect
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            # Fax with coversheet
            fax_effect = FaxNoteEffect(
                note_id="existing-note-uuid",
                recipient_name="Dr. Jane Smith",
                recipient_fax_number="15551234567",
                include_coversheet=True,
                subject="Patient Referral - Follow-up Care",
                comment="Please review attached consultation notes for continuing care.",
                location_id="practice-location-uuid"
            )
            return [fax_effect.apply()]
###  Push Charges #
Pushes the charges from the Note to its associated Claim in the Revenue
module. Has the exact same effect as clicking on the `Push charges` button in
the Note footer.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of the note to update| Yes  
**Note** : `instance_id` must be a valid, existing Note, and its
NoteTypeVersion must have `is_billable` = True.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.push_charges()]
##  ScheduleEvent Effect #
The `ScheduleEvent` effect enables creating, updating, and deleting schedule
events for providers, with optional patient association.
###  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`note_type_id`| `UUID` or `str`| Identifier for the note type (must be of
category `SCHEDULE_EVENT`)| Yes  
`patient_id`| `str` or `None`| Identifier for the patient (if applicable)|
Conditional  
`description`| `str` or `None`| Custom description for the event| Conditional  
`start_time`| `datetime.datetime`| Start time of the event| Yes  
`duration_minutes`| `int`| Duration of the event in minutes| Yes  
`practice_location_id`| `UUID` or `str`| Identifier for the practice location|
Yes  
`provider_id`| `str`| Identifier for the provider| Yes  
`status`| `AppointmentProgressStatus` or `None`| Status of the event| No  
`external_identifiers`| `list[AppointmentIdentifier]` or `None`| External
system identifiers| No  
###  Implementation Details #
  * Validates that the note type exists and is of category `SCHEDULE_EVENT`
  * Ensures patient is provided if the note type requires it
  * Verifies that custom descriptions are only used for note types that allow them
  * Validates that the practice location and provider exist
###  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(
                note_type_id="schedule-event-note-type-uuid",
                patient_id="patient-uuid",  # Optional depending on note type
                description="Team meeting",  # Optional depending on note type
                start_time=datetime.datetime.now(),
                duration_minutes=30,
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return [schedule_event_effect.create()]
###  Update Schedule Event #
Updates an existing schedule event in place.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of the event to update| Yes  
`start_time`| `datetime.datetime`| New start time| No  
`duration_minutes`| `int`| New duration in minutes| No  
`description`| `str` or `None`| Updated description| No  
`practice_location_id`| `UUID` or `str`| New practice location| No  
`provider_id`| `str`| New provider| No  
`status`| `AppointmentProgressStatus` or `None`| Updated status| No  
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note import AppointmentIdentifier
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.effects.note.base import AppointmentIdentifier
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            schedule_event_effect.start_time = datetime.datetime.now() + datetime.timedelta(days=1)
            schedule_event_effect.duration_minutes = 60
            schedule_event_effect.description = "Rescheduled team meeting"
            schedule_event_effect.external_identifiers = [
                AppointmentIdentifier(system="test_system", value="123TEST")
            ]
            return [schedule_event_effect.update()]
###  Reschedule Schedule Event #
Reschedules an existing schedule event by creating a new event and cancelling
the original. This maintains the event history and ensures proper tracking of
rescheduled events.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of the event to reschedule| Yes  
`start_time`| `datetime.datetime`| New start time| No  
`duration_minutes`| `int`| New duration in minutes| No  
`description`| `str` or `None`| Updated description| No  
`practice_location_id`| `UUID` or `str`| New practice location| No  
`provider_id`| `str`| New provider| No  
`status`| `AppointmentProgressStatus` or `None`| Updated status| No  
`external_identifiers`| `list[AppointmentIdentifier]` or `None`| Updated
external identifiers| No  
**Note** : At least one field (besides `instance_id`) must be modified.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            schedule_event_effect.start_time = datetime.datetime.now() + datetime.timedelta(hours=3)
            schedule_event_effect.duration_minutes = 45
            return [schedule_event_effect.reschedule()]
###  Delete Schedule Event #
Marks a schedule event as cancelled.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            return [schedule_event_effect.delete()]
* * *
##  Appointment Effect #
The `Appointment` effect facilitates creating, updating, and cancelling
patient appointments with providers.
###  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`appointment_note_type_id`| `UUID` or `str`| Identifier for the appointment
note type (must be of category `ENCOUNTER` and scheduleable)| Yes  
`patient_id`| `str`| Identifier for the patient| Yes  
`meeting_link`| `str` or `None`| Link for virtual appointments| No  
`start_time`| `datetime.datetime`| Start time of the appointment| Yes  
`duration_minutes`| `int`| Duration of the appointment in minutes| Yes  
`practice_location_id`| `UUID` or `str`| Identifier for the practice location|
Yes  
`provider_id`| `str`| Identifier for the provider| Yes  
`status`| `AppointmentProgressStatus` or `None`| Status of the appointment| No  
`external_identifiers`| `list[AppointmentIdentifier]` or `None`| External
system identifiers| No  
###  Implementation Details #
  * Validates that the appointment note type exists, is of category `ENCOUNTER`, and is scheduleable
  * Ensures the patient exists in the system
  * Verifies that the practice location and provider exist
###  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(
                appointment_note_type_id="appointment-note-type-uuid",
                patient_id="patient-uuid",
                meeting_link="https://zoom.us/example-link",  # Optional
                start_time=datetime.datetime.now(),
                duration_minutes=60,
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return appointment_effect.create()
###  Update Appointment #
Updates an existing appointment in place.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of appointment to update| Yes  
`start_time`| `datetime.datetime`| New start time| No  
`duration_minutes`| `int`| New duration in minutes| No  
`meeting_link`| `str` or `None`| Updated meeting link| No  
`practice_location_id`| `UUID` or `str`| New practice location| No  
`provider_id`| `str`| New provider| No  
`status`| `AppointmentProgressStatus` or `None`| Updated status| No  
`external_identifiers`| `list[AppointmentIdentifier]` or `None`| Updated
external identifiers| No  
**Note** : `patient_id` cannot be updated after creation.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            appointment_effect.start_time = datetime.datetime.now() + datetime.timedelta(hours=2)
            appointment_effect.duration_minutes = 45
            appointment_effect.meeting_link = "https://new-meeting-link.com"
            return appointment_effect.update()
###  Reschedule Appointment #
Reschedules an existing appointment by creating a new appointment and
cancelling the original. This maintains the appointment history and ensures
proper tracking of rescheduled appointments.
####  Attributes #
Attribute| Type| Description| Required  
---|---|---|---  
`instance_id`| `UUID` or `str`| Identifier of appointment to reschedule| Yes  
`start_time`| `datetime.datetime`| New start time| No  
`duration_minutes`| `int`| New duration in minutes| No  
`meeting_link`| `str` or `None`| Updated meeting link| No  
`practice_location_id`| `UUID` or `str`| New practice location| No  
`provider_id`| `str`| New provider| No  
`status`| `AppointmentProgressStatus` or `None`| Updated status| No  
`external_identifiers`| `list[AppointmentIdentifier]` or `None`| Updated
external identifiers| No  
**Note** : At least one field (besides `instance_id`) must be modified.
`patient_id` cannot be updated after creation.
####  Example Usage #
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            appointment_effect.start_time = datetime.datetime.now() + datetime.timedelta(days=1)
            appointment_effect.duration_minutes = 60
            return appointment_effect.reschedule()
###  Cancel Appointment #
Cancels an existing appointment and updates its status.
####  Example Usage #
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            return appointment_effect.cancel()
* * *
##  Validation #
All effects perform comprehensive validation before execution:
  1. **Entity Existence** : Validates that referenced entities (patients, providers, practice locations, note types) exist in the system
  2. **Type Compatibility** : Ensures note types are appropriate for the intended operation:
     * Visit notes cannot use `APPOINTMENT`, `SCHEDULE_EVENT`, `MESSAGE`, or `LETTER` note types
     * Schedule events must use `SCHEDULE_EVENT` note types
     * Appointments must use `ENCOUNTER` note types that are scheduleable
  3. **Field Requirement Enforcement** : The system validates conditional field requirements based on note type configurations:
     * **Patient Association Requirements** : For note types with `is_patient_required=True`, the system enforces that a valid patient ID is provided. This is particularly important for schedule events that may or may not be associated with specific patients.
     * **Custom Description Validation** : When a note type has `allow_custom_title=False`, the system prevents custom descriptions from being added. This ensures adherence to standardized naming conventions for certain types of appointments and events.
     * **Required Field Validation** : All required fields are checked for proper values and formats before the effect is executed.
  4. **Update Restrictions** : Certain fields cannot be modified after creation:
     * **Notes** : `patient_id` and `note_type_id` are immutable
     * **Appointments** : `patient_id` is immutable
     * **All Effects** : At least one field must be modified for an update operation to succeed
----- END PAGE https://docs.canvasmedical.com/sdk/effect-notes/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-messages/
# Message Effect
Last updated: 7 Nov 2025
The `Message` effect provides a unified way to create, edit, and transmit
messages between users (patients or staff) within the Canvas platform. It
supports standalone creation, immediate send after creating, edits, and
dedicated send operations.
##  Attributes #
Name| Type| Description  
---|---|---  
`message_id`| `str` or `UUID` or `None`| Unique identifier of an existing
message. Must be unset when creating a new message; required when editing.  
`content`| `str` or `None`| The text body of the message. Required when
creating; cannot be empty.  
`sender_id`| `str` or `UUID`| ID of the user (Patient or Staff) who is sending
the message.  
`recipient_id`| `str` or `UUID`| ID of the user (Patient or Staff) who will
receive the message.  
`read`| `datetime` or `None`| Timestamp indicating when the message was read
by the recipient. Defaults to `None` (unread).  
##  Validation & Errors #
Before any effect is emitted, the model runs these checks:
  * **Sender and Recipient Exist** Verifies that both `sender_id` and `recipient_id` belong to either a `Patient` or a `Staff` record.
  * **Create vs. Edit Constraints**
    * **Create** and **Create-and-Send** must **not** include `message_id`.
    * **Create** and **Create-and-Send** must include non-empty `content` (content cannot be blank or whitespace-only).
    * **Edit** operations **must** include a valid `message_id` that already exists in the database.
##  Caveats #
  * **Role Constraints:** Sender and Recipient must always be one of Patient or Staff. Patient-to-Patient messaging is not allowed.
  * **UI Refresh Required:** Due to system constraints, editing a message requires a manual UI refresh for updated content to display.
  * **No Attachments Supported:** The Message effect does not yet support attachments.
  * **Immediate Post for Patient-to-Staff:** Messages created from a Patient to Staff cannot be drafted and will immediately appear in the timeline. This means that `CREATE_AND_SEND` and `SEND` effects will fail in these scenarios. You should only use the `CREATE` method for Patient-to-Staff messaging.
##  Effect Methods #
###  `create()` #
Originate a new message record without sending.
  * **Effect Type:** `CREATE_MESSAGE`
  * **Payload:** `{ "data": { content, sender_id, recipient_id } }`
###  `create_and_send()` #
Create the message and immediately send it in one operation.
  * **Effect Type:** `CREATE_AND_SEND_MESSAGE`
  * **Payload:** `{ "data": { content, sender_id, recipient_id } }`
###  `edit()` #
Modify an existing messageâs content.
  * **Effect Type:** `EDIT_MESSAGE`
  * **Payload:** `{ "data": { message_id, content?, sender_id?, recipient_id? } }`
  * Only fields marked dirty (modified on the model) are included; unchanged fields remain intact in the system.
###  `send()` #
Send an already-created message. Useful if you separated creation from
transmission.
  * **Effect Type:** `SEND_MESSAGE`
  * **Payload:** `{ "data": { message_id } }`
##  Example Usage #
    from canvas_sdk.v1.data.message import Message as MessageModel
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.v1.data.staff import Staff
    from canvas_sdk.effects.note.message import Message
    staff = Staff.objects.first()
    patient = Patient.objects.first()
###  Create (originate) only #
    m1 = Message(
        content="Your lab results are available.",
        sender_id=staff.id,
        recipient_id=patient.id
    )
    effect_create = m1.create()
###  Create and send in one step #
    m2 = Message(
        content="Your appointment is confirmed.",
        sender_id=staff.id,
        recipient_id=patient.id
    )
    effect_create_and_send = m2.create_and_send()
    m = MessageModel.objects.get(message_id="msg-1234")
###  Edit an existing message #
    m3 = Message(
        message_id=m.id,
        content="Updated: Your appointment has moved to 3pm."
    )
    effect_edit = m3.edit()
###  Send an existing message #
    m4 = Message(message_id=m.id)
    effect_send = m4.send()
----- END PAGE https://docs.canvasmedical.com/sdk/effect-messages/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/events/
# Events
Last updated: 13 Nov 2025
**What is an Event?**
An event is an occurrence of an action that happens within Canvas. For
example, a patient being prescribed a medication, a user searching for a
condition or an appointment being created are all examples of events.
**Why should I use them?**
By writing plugins that respond to events, plugin code is notified and can
react to events that occur in Canvas. This enables plugin authors to create
custom workflows whenever a relevant event takes place, such as making a POST
request to a webhook.
**How do I use them?**
To make plugin code react to an event, you can add the event types listed
below into the `RESPONDS_TO` list of a plugin that inherits from
`BaseProtocol`. For example:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = [EventType.Name(EventType.ALLERGY_INTOLERANCE_CREATED)]
        def compute(self):
            ...
The plugin author can enter custom workflow code into the `compute` method
that will execute every time an Allergy Intolerance is created in Canvas.
For more information on writing plugins, see the guide [here](/guides/your-
first-plugin/).
##  Event Types and Context #
The event `target` object can be accessed within the compute method of the
plugin by `self.event.target`. If `self.event.target.type` exists, it provides
the same type that would be imported from the Data module. For example, a type
of `Condition` would be the same as what you can import from
`canvas_sdk.v1.data.condition`.
The event `context` object can be accessed via `self.event.context`. The
content present in each eventâs context depends on the event type. The table
below shows what you can expect for each event type, or you could take a look
yourself by logging it out.
###  Common Context Patterns #
Many events include common contextual information to help you understand the
scope and origin of the event:
  * **Patient context** : Most patient-related events include `"patient": {"id": pt_id}` in the context, allowing you to identify which patient the event relates to.
  * **Note context** : Command lifecycle events (PRE_COMMIT, POST_COMMIT, etc.) include `"note": {"uuid": note_id}` in the context, indicating the note where the command was executed.
  * **User context** : All command-related PRE_SEARCH and POST_SEARCH events include `"user": {"staff": staff_key}` in the context, containing the staff key of the user performing the search. This allows you to customize search results based on user-specific preferences, roles, or permissions.
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        RESPONDS_TO = [EventType.Name(EventType.ALLERGY_INTOLERANCE_CREATED)]
        def compute(self):
            log.info(self.event.context)
            return []
###  Record lifecycle events #
These events fire as a result of records being created, updated, or deleted.
####  Patients #
PATIENT_CREATED  
---  
Occurs when a patient is created.  
Target object| Context object  
    "id": pt_id
    "type": [Patient](/sdk/data-patient/)
|
    empty  
PATIENT_UPDATED  
---  
Occurs when a patient's data is updated.  
Target object| Context object  
    "id": pt_id
    "type": [Patient](/sdk/data-patient/)
|
    empty  
CARE_TEAM_MEMBERSHIP_CREATED  
---  
Occurs when a new care team member is added for a patient.  
Target object| Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
|
    "patient":
        "id": pt_id  
CARE_TEAM_MEMBERSHIP_UPDATED  
---  
Occurs when a care team member is adjusted for a patient.  
Target object| Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
|
    "patient":
        "id": pt_id  
CARE_TEAM_MEMBERSHIP_DELETED  
---  
Occurs when a care team member is removed for a patient.  
Target object| Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
|
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_CREATED  
---  
Occurs when an address is added for a patient.  
Target object| Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
|
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_UPDATED  
---  
Occurs when one of a patient's addresses is updated.  
Target object| Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
|
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_DELETED  
---  
Occurs when one of a patient's addresses is removed.  
Target object| Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_CREATED  
---  
Occurs when a contact is added for a patient.  
Target object| Context object  
    "id": contact_person_id
    "type": None
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_UPDATED  
---  
Occurs when one of a patient's contacts is updated.  
Target object| Context object  
    "id": contact_person_id
    "type": None
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_DELETED  
---  
Occurs when one of a patient's contacts is removed.  
Target object| Context object  
    "id": contact_person_id
    "type": None
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_CREATED  
---  
Occurs when a contact method for a patient is added.  
Target object| Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_UPDATED  
---  
Occurs when a contact method for a patient is updated.  
Target object| Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
|
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_DELETED  
---  
Occurs when a contact method for a patient is removed.  
Target object| Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
|
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_CREATED  
---  
Occurs when an external identifier is created for a patient.  
Target object| Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
|
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_UPDATED  
---  
Occurs when an external identifier for a patient is updated.  
Target object| Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
|
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_DELETED  
---  
Occurs when an external identifier for a patient is deleted.  
Target object| Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
|
    "patient":
        "id": pt_id  
####  Patient Metadata #
PATIENT_METADATA_CREATED  
---  
Occurs when a patient's metadata is created.  
Target object| Context object  
    "id": patientmetadata_id
    "type": [PatientMetadata](/sdk/data-patient/#patientmetadata)
|
    "patient":
        "id": pt_id  
PATIENT_METADATA_UPDATED  
---  
Occurs when a patient's metadata is updated.  
Target object| Context object  
    "id": patientmetadata_id
    "type": [PatientMetadata](/sdk/data-patient/#patientmetadata)
|
    "patient":
        "id": pt_id  
####  Allergy Intolerances #
ALLERGY_INTOLERANCE_CREATED  
---  
Occurs when an allergy is created for a patient. Additional details for the
allergy may become available with subsequent ALLERGY_INTOLERANCE_UPDATED
events.  
Target object| Context object  
    "id": allergy_id
    "type": [AllergyIntolerance](/sdk/data-allergy-intolerance/#allergyintolerance)
|
    "patient":
        "id": pt_id  
ALLERGY_INTOLERANCE_UPDATED  
---  
Occurs when an allergy is updated for a patient.  
Target object| Context object  
    "id": allergy_id
    "type": [AllergyIntolerance](/sdk/data-allergy-intolerance/#allergyintolerance)
|
    "patient":
        "id": pt_id  
####  Appointments #
APPOINTMENT_CREATED  
---  
Occurs when an appointment is first created/booked.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT_UPDATED  
---  
Occurs when details of an appointment are updated.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT_CHECKED_IN  
---  
Occurs when a patient has arrived and been checked in for their appointment.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT_RESTORED  
---  
Occurs when a cancelled appointment is restored to a non-cancelled status.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT_CANCELED  
---  
Occurs when an appointment is cancelled.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT_NO_SHOWED  
---  
Occurs when an appointment is marked as a no-show.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "patient":
        "id": pt_id  
APPOINTMENT__SLOTS__POST_SEARCH  
---  
Occurs when requesting slot availability when scheduling an appointment.  
Target object| Context object  
|
    "slots_by_provider": list[dict]
    "selected_values": dict  
APPOINTMENT__FORM__PROVIDERS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__PROVIDERS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "providers": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__LOCATIONS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__LOCATIONS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "locations": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__VISIT_TYPES__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__VISIT_TYPES__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "visit_types": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__DURATIONS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__DURATIONS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "durations": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__REASON_FOR_VISIT__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__REASON_FOR_VISIT__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "reason_for_visit": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__GET_ADDITIONAL_FIELDS  
---  
Occurs when a schedule appointment form is loaded.  
Target object| Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
|
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
####  Appointment Metadata #
APPOINTMENT_METADATA_CREATED  
---  
Occurs when an appointment's metadata is created.  
Target object| Context object  
    "id": appointmentmetadata_id
    "type": [AppointmentMetadata](/sdk/data-appointment/#appointmentmetadata)
|
    empty  
APPOINTMENT_METADATA_UPDATED  
---  
Occurs when an appointment's metadata is updated.  
Target object| Context object  
    "id": appointmentmetadata_id
    "type": [AppointmentMetadata](/sdk/data-appointment/#appointmentmetadata)
|
    empty  
####  Claims #
CLAIM_CREATED  
---  
Occurs when a claim is created.  
Target object| Context object  
    "id": claim_id
    "type": [Claim](/sdk/data-claim/#claim)
|
    "patient":
      "id": pt_id
    "note":
      "uuid": note_id  
CLAIM_UPDATED  
---  
Occurs when a claim is updated.  
Target object| Context object  
    "id": claim_id
    "type": [Claim](/sdk/data-claim/#claim)
|
    "patient":
      "id": pt_id
    "note":
      "uuid": note_id  
####  Billing Line Items #
BILLING_LINE_ITEM_CREATED  
---  
Occurs when a billing line item is created from adding a CPT code to a note.  
Target object| Context object  
    "id": billing_line_item_id
    "type": [BillingLineItem](/sdk/data-billing-line-item/#billinglineitem)
|
    "patient":
        "id": pt_id  
BILLING_LINE_ITEM_UPDATED  
---  
Occurs when a billing line item is modified.  
Target object| Context object  
    "id": billing_line_item_id
    "type": [BillingLineItem](/sdk/data-billing-line-item/#billinglineitem)
|
    "patient":
        "id": pt_id  
####  Conditions #
CONDITION_ASSESSED  
---  
Occurs when a condition is assessed through the Assess Condition command.  
Target object| Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
|
    "patient":
        "id": pt_id  
CONDITION_CREATED  
---  
Occurs when a condition is diagnosed for a patient. Additional details for the
condition may become available with subsequent CONDITION_UPDATED events.  
Target object| Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
|
    "patient":
        "id": pt_id  
CONDITION_RESOLVED  
---  
Occurs when a condition is resolved through the Resolve Condition command.  
Target object| Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
|
    "patient":
        "id": pt_id  
CONDITION_UPDATED  
---  
Occurs when a condition is updated for a patient.  
Target object| Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
|
    "patient":
        "id": pt_id  
####  Consents #
CONSENT_CREATED  
---  
Occurs when a patient consent is created.  
Target object| Context object  
    "id": consent_id
    "type": None
|
    "patient":
       "id": pt_id  
CONSENT_DELETED  
---  
Occurs when a patient consent is removed/deleted.  
Target object| Context object  
    "id": consent_id
    "type": None
|
    "patient":
       "id": pt_id  
CONSENT_UPDATED  
---  
Occurs when a patient consent is updated.  
Target object| Context object  
    "id": consent_id
    "type": None
|
    "patient":
       "id": pt_id  
####  Coverages #
COVERAGE_CREATED  
---  
Occurs when a coverage for a patient is created.  
Target object| Context object  
    "id": coverage_id
    "type": [Coverage](/sdk/data-coverage/#coverage)
|
    "patient":
       "id": pt_id  
COVERAGE_UPDATED  
---  
Occurs when a coverage for a patient is updated.  
Target object| Context object  
    "id": coverage_id
    "type": [Coverage](/sdk/data-coverage/#coverage)
|
    "patient":
       "id": pt_id  
####  Detected Issues #
DETECTED_ISSUE_CREATED  
---  
Occurs when a detected issue is created.  
Target object| Context object  
    "id": detected_issue_id
    "type": [DetectedIssue](/sdk/data-detected-issue/#detectedissue)
|
    "patient":
       "id": pt_id  
DETECTED_ISSUE_UPDATED  
---  
Occurs when a detected issue is updated.  
Target object| Context object  
    "id": detected_issue_id
    "type": [DetectedIssue](/sdk/data-detected-issue/#detectedissue)
|
    "patient":
       "id": pt_id  
DETECTED_ISSUE_EVIDENCE_CREATED  
---  
Occurs when detected issue evidence is created.  
Target object| Context object  
    "id": detected_issue_evidence_id
    "type": [DetectedIssueEvidence](/sdk/data-detected-issue/#detectedissueevidence)
|
    empty  
DETECTED_ISSUE_EVIDENCE_UPDATED  
---  
Occurs when a detected issue evidence is updated.  
Target object| Context object  
    "id": detected_issue_evidence_id
    "type": [DetectedIssueEvidence](/sdk/data-detected-issue/#detectedissueevidence)
|
    empty  
####  Devices #
DEVICE_CREATED  
---  
Occurs when a device is created.  
Target object| Context object  
    "id": device_id
    "type": [Device](/sdk/data-device/#device)
|
    "patient":
       "id": pt_id  
DEVICE_UPDATED  
---  
Occurs when a device is updated.  
Target object| Context object  
    "id": device_id
    "type": [Device](/sdk/data-device/#device)
|
    "patient":
       "id": pt_id  
####  Document References #
DOCUMENT_REFERENCE_CREATED  
---  
Occurs when a document reference is created.  
Target object| Context object  
    "id": document_reference_id
    "type": None
|
    "patient":
       "id": pt_id  
DOCUMENT_REFERENCE_UPDATED  
---  
Occurs when a document reference is updated.  
Target object| Context object  
    "id": document_reference_id
    "type": None
|
    "patient":
       "id": pt_id  
DOCUMENT_REFERENCE_DELETED  
---  
Occurs when a document reference is deleted.  
Target object| Context object  
    "id": document_reference_id
    "type": None
|
    "patient":
       "id": pt_id  
####  Encounters #
ENCOUNTER_CREATED  
---  
Occurs when an encounter is created.  
Target object| Context object  
    "id": encounter_id
    "type": [Encounter](/sdk/data-encounter/#encounter)
|
    empty  
ENCOUNTER_UPDATED  
---  
Occurs when an encounter is updated.  
Target object| Context object  
    "id": encounter_id
    "type": [Encounter](/sdk/data-encounter/#encounter)
|
    empty  
####  Imaging Reports #
IMAGING_REPORT_CREATED  
---  
Occurs when an imaging report is entered into the data integration section of
canvas.  
Target object| Context object  
    "id": report_id
    "type": [ImagingReport](/sdk/data-imaging/#imagingreport)
|
    "patient":
       "id": pt_id  
IMAGING_REPORT_UPDATED  
---  
Occurs when an imaging report is updated.  
Target object| Context object  
    "id": report_id
    "type": [ImagingReport](/sdk/data-imaging/#imagingreport)
|
    "patient":
       "id": pt_id  
####  Immunizations #
IMMUNIZATION_CREATED  
---  
Occurs when an immunization is created. Additional details for the
immunization may become available with subsequent
IMMUNIZATION_STATEMENT_UPDATED events.  
Target object| Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
|
    "patient":
       "id": pt_id  
IMMUNIZATION_UPDATED  
---  
Occurs when an immunization is updated.  
Target object| Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
|
    "patient":
       "id": pt_id  
IMMUNIZATION_STATEMENT_CREATED  
---  
Occurs when an immunization statement is created. Additional details for the
immunization statement may become available with subsequent
IMMUNIZATION_STATEMENT_UPDATED events.  
Target object| Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
|
    "patient":
       "id": pt_id  
IMMUNIZATION_STATEMENT_UPDATED  
---  
Occurs when an immunization statement is updated.  
Target object| Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
|
    "patient":
       "id": pt_id  
####  Instructions #
INSTRUCTION_CREATED  
---  
Occurs when an instruction is created using the Instruct command. Additional
details for the instruction may become available with subsequent
INSTRUCTION_UPDATED events.  
Target object| Context object  
    "id": instruction_id
    "type": None
|
    "patient":
       "id": pt_id  
INSTRUCTION_UPDATED  
---  
Occurs when an instruction is updated.  
Target object| Context object  
    "id": instruction_id
    "type": None
|
    "patient":
       "id": pt_id  
####  Interviews #
INTERVIEW_CREATED  
---  
Occurs when an interview is created using the Questionnaire command or through
the Questionnaire endpoint in the FHIR API. Additional details for the
interview may become available with subsequent INTERVIEW_UPDATED events.  
Target object| Context object  
    "id": interview_id
    "type": [Interview](/sdk/data-questionnaire/#interview)
|
    "patient":
       "id": pt_id  
INTERVIEW_UPDATED  
---  
Occurs when an interview is updated.  
Target object| Context object  
    "id": interview_id
    "type": [Interview](/sdk/data-questionnaire/#interview)
|
    "patient":
       "id": pt_id  
####  Labs #
LAB_ORDER_CREATED  
---  
Occurs when a lab order is created via the Lab Order command. Additional
details for the lab order may become available with subsequent
LAB_ORDER_UPDATED events.  
Target object| Context object  
    "id": laborder_id
    "type": [LabOrder](/sdk/data-labs/#laborder)
|
    "patient":
       "id": pt_id  
LAB_ORDER_UPDATED  
---  
Occurs when a lab order is updated.  
Target object| Context object  
    "id": laborder_id
    "type": [LabOrder](/sdk/data-labs/#laborder)
|
    "patient":
       "id": pt_id  
LAB_REPORT_CREATED  
---  
Occurs when a lab report is created either through Data Integration,
electronic ingestion or the FHIR API.  
Target object| Context object  
    "id": labreport_id
    "type": [LabReport](/sdk/data-labs/#labreport)
|
    "patient":
       "id": pt_id  
LAB_REPORT_UPDATED  
---  
Occurs when a lab report is updated.  
Target object| Context object  
    "id": labreport_id
    "type": [LabReport](/sdk/data-labs/#labreport)
|
    "patient":
       "id": pt_id  
####  Medications #
MEDICATION_LIST_ITEM_CREATED  
---  
Occurs when a medication is added for a patient.  
Target object| Context object  
    "id": medication_id
    "type": [Medication](/sdk/data-medication/#medication)
|
    "patient":
       "id": pt_id  
MEDICATION_LIST_ITEM_UPDATED  
---  
Occurs when a medication is updated for a patient.  
Target object| Context object  
    "id": medication_id
    "type": [Medication](/sdk/data-medication/#medication)
|
    "patient":
       "id": pt_id  
PRESCRIPTION_UPDATED  
---  
Occurs when a prescription is updated.  
Target object| Context object  
    "id": prescription_id
    "type": [Medication](/sdk/data-medication/#medication)
|
    "patient":
       "id": pt_id  
PRESCRIPTION_CREATED  
---  
Occurs when a prescription is created for a patient using the Prescribe
command. Additional details for the prescription become available with
subsequent PRESCRIPTION_UPDATED events.  
Target object| Context object  
    "id": prescription_id
    "type": [Medication](/sdk/data-medication/#medication)
|
    "patient":
       "id": pt_id  
####  Messaging #
MESSAGE_CREATED  
---  
Occurs when a message (patient/practitioner communication) is created.  
Target object| Context object  
    "id": message_id
    "type": [Message](/sdk/data-message/#message)
|
    "patient":
       "id": pt_id  
MESSAGE_TRANSMISSION_CREATED  
---  
Occurs when a message transmission record is created. Message transmissions
track delivery attempts and status for messages sent through various channels
(SMS, email, etc.).  
Target object| Context object  
    "id": message_transmission_id
    "type": [MessageTransmission](/sdk/data-message/#messagetransmission)
|
    empty  
MESSAGE_TRANSMISSION_UPDATED  
---  
Occurs when a message transmission record is updated (e.g., when delivery
status changes).  
Target object| Context object  
    "id": message_transmission_id
    "type": [MessageTransmission](/sdk/data-message/#messagetransmission)
|
    empty  
####  Notes #
NOTE_STATE_CHANGE_EVENT_CREATED  
---  
Occurs as a note traverses through its state machine. This event can be used
when looking at any changes to the [note state](/sdk/data-note/#notestates),
including locking and unlocking.  
Target object| Context object  
    "id": nsce_id
    "type": NoteStateChangeEvent
|
    "note_id": note_id,
    "patient_id": pt_id,
    "state": [str](/sdk/data-note/#notestates)  
NOTE_STATE_CHANGE_EVENT_UPDATED  
---  
Occurs if a note state change event is updated. Locking and unlocking both
trigger an update event, and there is an *additional* update event when an
archived PDF copy of the note finishes generating; this is done
asynchronously.  
Target object| Context object  
    "id": nsce_id
    "type": NoteStateChangeEvent
|
    "note_id": note_id,
    "patient_id": pt_id,
    "state": [str](/sdk/data-note/#notestates)  
####  Observations #
OBSERVATION_CREATED  
---  
Occurs when an observation is created.  
Target object| Context object  
    "id": observation_id
    "type": [Observation](/sdk/data-observation/#observation)
|
    "patient":
       "id": pt_id  
OBSERVATION_UPDATED  
---  
Occurs when an observation is updated.  
Target object| Context object  
    "id": observation_id
    "type": [Observation](/sdk/data-observation/#observation)
|
    "patient":
       "id": pt_id  
####  Protocol Overrides #
PROTOCOL_OVERRIDE_CREATED  
---  
Target object| Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
|
    "patient":
       "id": pt_id  
PROTOCOL_OVERRIDE_UPDATED  
---  
Target object| Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
|
    "patient":
       "id": pt_id  
PROTOCOL_OVERRIDE_DELETED  
---  
Target object| Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
|
    "patient":
       "id": pt_id  
####  Referral Reports #
REFERRAL_REPORT_CREATED  
---  
Occurs when a specialist consult report is created in Data Integration.  
Target object| Context object  
    "id": referralreport_id
    "type": [ReferralReport](/sdk/data-referral/#referralreport)
|
    "patient":
       "id": pt_id  
REFERRAL_REPORT_UPDATED  
---  
Occurs when a specialist consult report is updated.  
Target object| Context object  
    "id": referralreport_id
    "type": [ReferralReport](/sdk/data-referral/#referralreport)
|
    "patient":
       "id": pt_id  
####  Tasks #
TASK_CREATED  
---  
Occurs when a task is created.  
Target object| Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
|
    "patient":
       "id": pt_id  
TASK_UPDATED  
---  
Occurs when a task is updated.  
Target object| Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
|
    "patient":
       "id": pt_id  
TASK_COMMENT_CREATED  
---  
Occurs when a comment is added to a task.  
Target object| Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
|
    empty  
TASK_COMMENT_UPDATED  
---  
Occurs when a comment for a task is updated.  
Target object| Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
|
    empty  
TASK_COMMENT_DELETED  
---  
Occurs when a comment for a task is removed.  
Target object| Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
|
    empty  
TASK_LABELS_ADJUSTED  
---  
Occurs when a task's labels are changed.  
Target object| Context object  
    "id": task_label_id
    "type": [TaskLabel](/sdk/data-task/#tasklabel)
|
    "patient":
       "id": pt_id
    "task":
        "id": task_id
    "action": literal["add", "remove"]  
TASK_COMPLETED  
---  
Occurs when a task is set to completed.  
Target object| Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
|
    "patient":
       "id": pt_id  
TASK_CLOSED  
---  
Occurs when a task is set to closed.  
Target object| Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
|
    "patient":
       "id": pt_id  
####  Staff #
STAFF_CREATED  
---  
Occurs when a staff is created.  
Target object| Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
|
    empty  
STAFF_UPDATED  
---  
Occurs when a staff is updated.  
Target object| Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
|
    empty  
STAFF_ACTIVATED  
---  
Occurs when a staff record is created with active=True, or a staff record's
active field is updated from False to True.  
Target object| Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
|
    empty  
STAFF_DEACTIVATED  
---  
Occurs when a staff record's active field is updated from True to False.  
Target object| Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
|
    empty  
####  Vital Signs #
VITAL_SIGN_CREATED  
---  
Occurs when a vitals entry is created for a patient using the vitals command.
Additional details for the vitals become available with subsequent
VITAL_SIGN_UPDATED events.  
Target object| Context object  
    "id": vitalsign_id
    "type": None
|
    empty  
VITAL_SIGN_UPDATED  
---  
Occurs when a vitals entry is updated for a patient.  
Target object| Context object  
    "id": vitalsign_id
    "type": None
|
    empty  
###  Command lifecycle events #
These events fire during the command lifecycle.
####  Generic events #
Event| Occurs when| PRE_COMMAND_ORIGINATE| Before any command is entered into
a note.  
---|---  
POST_COMMAND_ORIGINATE| After any command is entered into a note.  
PRE_COMMAND_UPDATE| Before the data in any command is updated.  
POST_COMMAND_UPDATE| After the data in any command is updated.  
PRE_COMMAND_COMMIT| Before any command is committed.  
POST_COMMAND_COMMIT| After any command is committed.  
PRE_COMMAND_DELETE| Before any command is deleted.  
POST_COMMAND_DELETE| After any command is deleted.  
PRE_COMMAND_ENTER_IN_ERROR| Before any command is marked as entered in error.  
POST_COMMAND_ENTER_IN_ERROR| After any command is marked as entered in error.  
PRE_COMMAND_EXECUTE_ACTION| Before an action is executed on any command.  
POST_COMMAND_EXECUTE_ACTION| After an action is executed on any command.  
POST_COMMAND_INSERTED_INTO_NOTE| After a command is added to a note in the UI.  
AVAILABLE_ACTIONS| When a command is rendered in the UI, after any update to
data, state, or other changes  
#####  Context Overview #
Each command lifecycle event provides specific context to the handler,
depending on the stage of the command lifecycle.
**Base Context (All Events Except`PRE_COMMAND_ORIGINATE`)**:
    {
      "note": { "uuid": "note-123" },
      "patient": { "id": "patient-123" },
      "fields": { "key": "value" }
    }
  * `note.uuid`: The unique identifier of the note associated with the command.
  * `patient.id`: The unique identifier of the patient associated with the note.
  * `fields`: A dictionary containing command-specific details. See examples for each command.
**`PRE_COMMAND_ORIGINATE` Context**: Since the command is not yet connected to
a note, the `PRE_COMMAND_ORIGINATE` event context only includes:
    {
      "fields": { "key": "value" }
    }
  * `fields`: Contains details specific to the command being originated.
* * *
####  Adjust Prescription Command #
ADJUST_PRESCRIPTION_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
ADJUST_PRESCRIPTION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION__INDICATIONS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__INDICATIONS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PHARMACY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PHARMACY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
ADJUST_PRESCRIPTION__PRESCRIBE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__CHANGE_MEDICATION_TO__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
ADJUST_PRESCRIPTION__CHANGE_MEDICATION_TO__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Allergy Command #
ALLERGY_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
ALLERGY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY__ALLERGY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[AllergySearchResult]  
ALLERGY__ALLERGY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Assess Command #
ASSESS_COMMAND__CONDITION_SELECTED  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
ASSESS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS__CONDITION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
ASSESS__CONDITION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
####  Cancel Prescription Command #
Event| Description| CANCEL_PRESCRIPTION_COMMAND__PRE_ORIGINATE|  
---|---  
CANCEL_PRESCRIPTION_COMMAND__POST_ORIGINATE|  
CANCEL_PRESCRIPTION_COMMAND__PRE_UPDATE|  
CANCEL_PRESCRIPTION_COMMAND__POST_UPDATE|  
CANCEL_PRESCRIPTION_COMMAND__PRE_COMMIT|  
CANCEL_PRESCRIPTION_COMMAND__POST_COMMIT|  
CANCEL_PRESCRIPTION_COMMAND__PRE_DELETE|  
CANCEL_PRESCRIPTION_COMMAND__POST_DELETE|  
CANCEL_PRESCRIPTION_COMMAND__PRE_ENTER_IN_ERROR|  
CANCEL_PRESCRIPTION_COMMAND__POST_ENTER_IN_ERROR|  
CANCEL_PRESCRIPTION_COMMAND__AVAILABLE_ACTIONS|  
CANCEL_PRESCRIPTION_COMMAND__PRE_EXECUTE_ACTION|  
CANCEL_PRESCRIPTION_COMMAND__POST_EXECUTE_ACTION|  
CANCEL_PRESCRIPTION__SELECTED_PRESCRIPTION__PRE_SEARCH|  
CANCEL_PRESCRIPTION__SELECTED_PRESCRIPTION__POST_SEARCH|  
####  Change Medication Command #
CHANGE_MEDICATION_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
CHANGE_MEDICATION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION__MEDICATION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
CHANGE_MEDICATION__MEDICATION__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Clipboard Command #
CLIPBOARD_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
CLIPBOARD_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
#####  Clipboard Fields Context #
The Clipboard Command provides the following fields in its context:
Field| Type| Description  
---|---|---  
`text`|  _string_|  The raw text content copied to the clipboard.  
Refer to the base context documentation for additional details about the full
context structure.
    {
      "note": { "uuid": "note-123" },
      "patient": { "id": "patient-123" },
      "fields": {
        "text": "Patient complains of persistent headaches for the past two weeks."
      }
    }
* * *
####  Close Goal Command #
CLOSE_GOAL_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
CLOSE_GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL__GOAL_ID__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
CLOSE_GOAL__GOAL_ID__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Diagnose Command #
DIAGNOSE_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
DIAGNOSE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE__DIAGNOSE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
DIAGNOSE__DIAGNOSE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Educational Material Command #
EDUCATIONAL_MATERIAL_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL__LANGUAGE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__LANGUAGE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__TITLE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__TITLE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Family History Command #
FAMILY_HISTORY_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
FAMILY_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY__FAMILY_HISTORY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__FAMILY_HISTORY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__RELATIVE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__RELATIVE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Follow Up Command #
FOLLOW_UP_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
FOLLOW_UP_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP__CODING__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__CODING__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__NOTE_TYPE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__NOTE_TYPE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Goal Command #
GOAL_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  History of Present Illness Command #
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  Imaging Order Command #
IMAGING_ORDER_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
IMAGING_ORDER_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER__IMAGE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGING_CENTER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGING_CENTER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__INDICATIONS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__INDICATIONS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__ORDERING_PROVIDER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__ORDERING_PROVIDER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Immunization Statement Command #
IMMUNIZATION_STATEMENT_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT__STATEMENT__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZATION_STATEMENT__STATEMENT__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Immunize Command #
IMMUNIZE_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
IMMUNIZE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE__CODING__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__CODING__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__GIVEN_BY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__GIVEN_BY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__LOT_NUMBER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__LOT_NUMBER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Instruct Command #
INSTRUCT_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
INSTRUCT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT__INSTRUCT__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
INSTRUCT__INSTRUCT__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Lab Order Command #
LAB_ORDER_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
LAB_ORDER_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER__DIAGNOSIS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__DIAGNOSIS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__LAB_PARTNER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__LAB_PARTNER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__ORDERING_PROVIDER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__ORDERING_PROVIDER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__TESTS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__TESTS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Medical History Command #
MEDICAL_HISTORY_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
MEDICAL_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY__APPROXIMATE_END_DATE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_END_DATE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_START_DATE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_START_DATE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Medication Statement Command #
MEDICATION_STATEMENT_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
MEDICATION_STATEMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT__MEDICATION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
MEDICATION_STATEMENT__MEDICATION__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
####  Perform Command #
PERFORM_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
PERFORM_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM__PERFORM__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PERFORM__PERFORM__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Physical Exam Command #
PHYSICAL_EXAM_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
PHYSICAL_EXAM_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM__QUESTIONNAIRE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PHYSICAL_EXAM__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Plan Command #
PLAN_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
PLAN_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  Prescribe Command #
PRESCRIBE_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
PRESCRIBE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE__INDICATIONS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__INDICATIONS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PHARMACY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PHARMACY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
PRESCRIBE__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Questionnaire Command #
QUESTIONNAIRE_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
QUESTIONNAIRE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE__QUESTIONNAIRE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
QUESTIONNAIRE__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Reason for Visit Command #
REASON_FOR_VISIT_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
REASON_FOR_VISIT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_INSERTED_INTO_NOTE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT__CODING__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REASON_FOR_VISIT__CODING__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Refer Command #
REFER_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
REFER_COMMAND_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND__REFER_TO__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__REFER_TO__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__INDICATIONS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__INDICATIONS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__DOCUMENTS_TO_INCLUDE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__DOCUMENTS_TO_INCLUDE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__LINKED_ITEMS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__LINKED_ITEMS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Refill Prescription Command #
REFILL_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
REFILL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL__INDICATIONS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__INDICATIONS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PHARMACY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PHARMACY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
REFILL__PRESCRIBE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBER__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBER__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Remove Allergy Command #
REMOVE_ALLERGY_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
REMOVE_ALLERGY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY__ALLERGY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REMOVE_ALLERGY__ALLERGY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Resolve Condition Command #
RESOLVE_CONDITION_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
RESOLVE_CONDITION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION__CONDITION__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
RESOLVE_CONDITION__CONDITION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
####  Review of Systems Command #
ROS_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
ROS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS__QUESTIONNAIRE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ROS__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Snooze Protocol Command #
Event| Description| SNOOZE_PROTOCOL_COMMAND__PRE_ORIGINATE|  
---|---  
SNOOZE_PROTOCOL_COMMAND__POST_ORIGINATE|  
SNOOZE_PROTOCOL_COMMAND__PRE_UPDATE|  
SNOOZE_PROTOCOL_COMMAND__POST_UPDATE|  
SNOOZE_PROTOCOL_COMMAND__PRE_COMMIT|  
SNOOZE_PROTOCOL_COMMAND__POST_COMMIT|  
SNOOZE_PROTOCOL_COMMAND__PRE_DELETE|  
SNOOZE_PROTOCOL_COMMAND__POST_DELETE|  
SNOOZE_PROTOCOL_COMMAND__PRE_ENTER_IN_ERROR|  
SNOOZE_PROTOCOL_COMMAND__POST_ENTER_IN_ERROR|  
SNOOZE_PROTOCOL_COMMAND__AVAILABLE_ACTIONS|  
SNOOZE_PROTOCOL_COMMAND__PRE_EXECUTE_ACTION|  
SNOOZE_PROTOCOL_COMMAND__POST_EXECUTE_ACTION|  
SNOOZE_PROTOCOL__PROTOCOL__PRE_SEARCH|  
SNOOZE_PROTOCOL__PROTOCOL__POST_SEARCH|  
####  Stop Medication Command #
STOP_MEDICATION_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
STOP_MEDICATION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION__MEDICATION__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
STOP_MEDICATION__MEDICATION__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Structured Assessment Command #
STRUCTURED_ASSESSMENT_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT__QUESTIONNAIRE__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
STRUCTURED_ASSESSMENT__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Surgical History Command #
SURGICAL_HISTORY_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
SURGICAL_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY__PAST_SURGICAL_HISTORY__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
SURGICAL_HISTORY__PAST_SURGICAL_HISTORY__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Task Command #
TASK_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
TASK_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK__ASSIGN_TO__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__ASSIGN_TO__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__LABELS__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__LABELS__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Update Diagnosis Command #
Event| Description| UPDATE_DIAGNOSIS_COMMAND__PRE_ORIGINATE|  
---|---  
UPDATE_DIAGNOSIS_COMMAND__POST_ORIGINATE|  
UPDATE_DIAGNOSIS_COMMAND__PRE_UPDATE|  
UPDATE_DIAGNOSIS_COMMAND__POST_UPDATE|  
UPDATE_DIAGNOSIS_COMMAND__PRE_COMMIT|  
UPDATE_DIAGNOSIS_COMMAND__POST_COMMIT|  
UPDATE_DIAGNOSIS_COMMAND__PRE_DELETE|  
UPDATE_DIAGNOSIS_COMMAND__POST_DELETE|  
UPDATE_DIAGNOSIS_COMMAND__PRE_ENTER_IN_ERROR|  
UPDATE_DIAGNOSIS_COMMAND__POST_ENTER_IN_ERROR|  
UPDATE_DIAGNOSIS_COMMAND__AVAILABLE_ACTIONS|  
UPDATE_DIAGNOSIS_COMMAND__PRE_EXECUTE_ACTION|  
UPDATE_DIAGNOSIS_COMMAND__POST_EXECUTE_ACTION|  
UPDATE_DIAGNOSIS__CONDITION__PRE_SEARCH|  
UPDATE_DIAGNOSIS__CONDITION__POST_SEARCH|  
UPDATE_DIAGNOSIS__NEW_CONDITION__PRE_SEARCH|  
UPDATE_DIAGNOSIS__NEW_CONDITION__POST_SEARCH|  
####  Update Goal Command #
UPDATE_GOAL_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
UPDATE_GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UPDATE_GOAL__GOAL_STATEMENT__POST_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UPDATE_GOAL__GOAL_STATEMENT__PRE_SEARCH  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Vitals Command #
VITALS_COMMAND__POST_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "actions":
      "name": string
    "user":
      "staff": staff_id  
VITALS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_COMMIT  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_DELETE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_ORIGINATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_UPDATE  
---  
Target object| Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
|
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
###  Patient Portal lifecycle events #
The following events are emitted during the lifecycle of a patient portal
session.
PATIENT_PORTAL__APPOINTMENT_CANCELED  
---  
Occurs after an appointment is canceled  
Target| Target type| Context object  
    appt_id
|
    [Appointment](/sdk/data-appointment/)
|
    None  
PATIENT_PORTAL__APPOINTMENT_RESCHEDULED  
---  
Occurs after an appointment is rescheduled  
Target| Target type| Context object  
    appt_id
|
    [Appointment](/sdk/data-appointment/)
|
    None  
PATIENT_PORTAL__APPOINTMENT_CAN_BE_CANCELED  
---  
Occurs when checking if an appointment can be canceled  
Target| Target type| Context object  
    appt_id
|
    [Appointment](/sdk/data-appointment/)
|
    None  
PATIENT_PORTAL__APPOINTMENT_CAN_BE_RESCHEDULED  
---  
Occurs when checking if an appointment can be rescheduled  
Target| Target type| Context object  
    appt_id
|
    [Appointment](/sdk/data-appointment/)
|
    None  
PATIENT_PORTAL__APPOINTMENTS__SLOTS__POST_SEARCH  
---  
Occurs after the appointment slots search has been done, allowing the values
to be modified  
Target| Target type| Context object  
    None
|
    None
|
    "slots_by_provider": dict  
PATIENT_PORTAL__APPOINTMENTS__FORM_APPOINTMENT_TYPES__PRE_SEARCH  
---  
Occurs before appointment types are resolved, allowing the internal values to
be bypassed  
Target| Target type| Context object  
    None
|
    None
|
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_APPOINTMENT_TYPES__POST_SEARCH  
---  
Occurs after appointment types are resolved, allowing the internal values to
be modified  
Target| Target type| Context object  
    None
|
    None
|
    "appointment_types": list[dict]  
PATIENT_PORTAL__APPOINTMENTS__FORM_LOCATIONS__PRE_SEARCH  
---  
Occurs before appointment locations are resolved, allowing the internal values
to be bypassed  
Target| Target type| Context object  
    None
|
    None
|
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_LOCATIONS__POST_SEARCH  
---  
Occurs after appointment locations are resolved, allowing the internal values
to be modified  
Target| Target type| Context object  
    None
|
    None
|
    "locations": list[dict]  
PATIENT_PORTAL__APPOINTMENTS__FORM_PROVIDERS__PRE_SEARCH  
---  
Occurs before appointment providers are resolved, allowing the internal values
to be bypassed  
Target| Target type| Context object  
    None
|
    None
|
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_PROVIDERS__POST_SEARCH  
---  
Occurs after appointment providers are resolved, allowing the internal values
to be modified  
Target| Target type| Context object  
    None
|
    None
|
    "providers": list[dict]  
###  Action Buttons Events #
For more information on handling these events, see [Action
Buttons](/sdk/handlers-action-buttons).
SHOW_NOTE_HEADER_BUTTON  
---  
Occurs when patient notes are being loaded  
Target| Context object  
    patient_id
|
      "note_id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_NOTE_FOOTER_BUTTON  
---  
Occurs when patient notes are being loaded  
Target| Context object  
    patient_id
|
      "note_id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_SOCIAL_DETERMINANTS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for social
determinants section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_GOALS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for goals
section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CONDITIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for conditions
section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_MEDICATIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for
medications section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_ALLERGIES_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for allergies
section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CARE_TEAMS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for care teams
section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_VITALS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for vitals
section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_IMMUNIZATIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for
immunizations section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_SURGICAL_HISTORY_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for surgical
history section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_FAMILY_HISTORY_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for family
history section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CODING_GAPS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for coding
gaps section  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
ACTION_BUTTON_CLICKED  
---  
Occurs when an action button is clicked  
Target| Context object  
    patient_id
|
      "key": action_button_key
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
###  Application Events #
For more information on these events, see [Applications](/sdk/handlers-
applications).
APPLICATION__ON_OPEN  
---  
Occurs when a user clicks on an application icon to open it  
Target| Context object  
    application_id
|
      "patient":
        "id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
###  Patient Portal Events #
PATIENT_PORTAL__GET_FORMS  
---  
Occurs on every page load of the Patient Portal; It only accepts the
`PATIENT_PORTAL__FORM_RESULT` effect as a return value  
Target| Target type| Context object  
    patient_id
|
    [Patient](/sdk/data-patient/)
|
    "requested_from": str["appointment" |
                          "labs" |
                          "login" |
                          "messaging" |
                          "my-health" |
                          "payment" |
                          "search-appointment"]  
###  Patient Chart Configuration #
PATIENT_CHART__CONDITIONS  
---  
Occurs when the conditions are loaded on the patient chart.  
Target object| Context object  
    "id": patient_id
    "type": [Patient](/sdk/patient/)
|
    "conditions":
        "id": condition id
        "codings":
          "code": str
          "system": str
          "display": str  
PATIENT_CHART__MEDICATIONS  
---  
Occurs when the medications are loaded on the patient chart.  
Target object| Context object  
    "id": patient_id
    "type": [Patient](/sdk/patient/)
|
    "medications":
        "id": medication id
        "codings":
          "code": str
          "system": str
          "display": str  
###  Other Events #
Event| Occurs when| UNKNOWN| Default event type unlikely to ever be emitted.  
---|---  
CRON| This event fires regularly and can be used for scheduled tasks. See
[CronTask](/sdk/handlers-crontask/).  
CLAIM__CONDITIONS| The conditions are loaded within the claim summary.  
PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION| A patient chart's summary
section is loading.  
PANEL_SECTIONS_CONFIGURATION| The panel section is loading.  
PLUGIN_CREATED| A plugin is uploaded for the first time. See
[ProtocolCards](/sdk/effect-protocol-cards/) and [BannerAlerts](/sdk/effect-
banner-alerts/) for examples of how to use this event.  
PLUGIN_UPDATED| A plugin is enabled or when the plugin code has changed. See
[ProtocolCards](/sdk/effect-protocol-cards/) and [BannerAlerts](/sdk/effect-
banner-alerts/) for examples of how to use this event.  
PATIENT_PROFILE__ADD_PHARMACY__POST_SEARCH_RESULTS| Adding a pharmacy for a
patient in their profile.  
PATIENT_PORTAL__WIDGET_CONFIGURATION| Patient Portal landing page is loading.
See [Tailoring Portal Landing Page](/guides/custom-landing-page/) for examples
of how to use this event.  
PATIENT_METADATA__GET_ADDITIONAL_FIELDS| Patient Profile is loading. See [How
to add patient profile additional fields](/guides/profile-additional-fields/)
for examples of how to use this event.  
Context object:
    "patient":
        "id": str
    "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
###  Search Result Data Structures #
Many event payloads include search results. This section documents the common
structures within them.
####  MedicationSearchResult #
Medication search events (such as
`MEDICATION_STATEMENT__MEDICATION__POST_SEARCH`,
`PRESCRIBE__PRESCRIBE__POST_SEARCH`, etc.) return results that follow this
structure:
    {
      "text": "acetaminophen 500 mg tablet",
      "disabled": false,
      "description": null,
      "annotations": null,
      "extra": {
        "coding": [
          {
            "code": 206813,
            "display": "acetaminophen 500 mg tablet",
            "system": "http://www.fdbhealth.com/"
          },
          {
            "code": "198440",
            "display": "acetaminophen 500 mg tablet",
            "system": "http://www.nlm.nih.gov/research/umls/rxnorm"
          }
        ],
        "clinical_quantities": [
          {
            "erx_quantity": "1.0000000",
            "representative_ndc": "57896021910",
            "clinical_quantity_description": "tablet",
            "erx_ncpdp_script_quantity_qualifier_code": "C48542",
            "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
          }
        ]
      },
      "value": 206813
    }
For detailed information about medication data structures, see
[Medication](/sdk/data-medication/).
For examples of working with medication search results, see the [Customize
Search Results](/guides/customize-search-results/) guide.
####  ConditionSearchResult #
Condition/diagnosis search events (such as `DIAGNOSE__DIAGNOSE__POST_SEARCH`,
`MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH`, etc.) return results
that follow this structure:
    {
      "text": "Broken internal left hip prosthesis, subsequent encounter",
      "disabled": false,
      "description": null,
      "annotations": ["T84.011D"],
      "extra": {
        "coding": [
          {
            "code": "T84011D",
            "display": "Broken internal left hip prosthesis, subsequent encounter",
            "system": "ICD-10"
          },
          {
            "code": 404684003,
            "display": "Broken internal left hip prosthesis, subsequent encounter",
            "system": "http://snomed.info/sct"
          }
        ]
      },
      "value": "T84011D"
    }
For detailed information about condition data structures, see
[Condition](/sdk/data-condition/).
####  AllergySearchResult #
Allergy search events (such as `ALLERGY__ALLERGY__POST_SEARCH`,
`REMOVE_ALLERGY__ALLERGY__POST_SEARCH`, etc.) return results that follow this
structure:
    {
      "text": "Penicillins (allergy group)",
      "disabled": false,
      "description": null,
      "annotations": null,
      "extra": {
        "coding": [
          {
            "code": 476,
            "display": "Penicillins",
            "system": "http://www.fdbhealth.com/"
          }
        ],
        "category_id": 1,
        "category": "allergy group"
      },
      "value": 476
    }
For detailed information about allergy data structures, see [Allergy
Intolerance](/sdk/data-allergy-intolerance/).
----- END PAGE https://docs.canvasmedical.com/sdk/events/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers/
# Handlers
Last updated: 8 Apr 2025
The handlers module lets you define reactions to events.
Handlers respond to [Events](/sdk/events/) and return zero, one, or many
[Effects](/sdk/effects/).
There are some special types of handlers, like [Protocols](/sdk/protocols/)
and [CronTasks](/sdk/handlers-crontask/). These offer a differentiated
interface for their particular use-cases. For example, CronTasks only ever
respond to the `CRON` event, require a schedule to be specified, and expect
the `execute` method to be implemented rather than `compute`.
All handlers inherit from [BaseHandler](/sdk/handlers-basehandler/), which
means you always have access to event and configuration data with the
following accessors:
  * `self.event`
    * Information about the event including the event type
  * `self.context`
    * Data included as the event payload
  * `self.target`
    * Identifying information to help you reference the subject of the event
  * `self.secrets`
    * Configuration key-value store for your plugin
    * Secrets have their keys defined in the `CANVAS_MANIFEST.json` and their values are set by the Canvas instance administrator after installing your plugin via the Canvas UI on your pluginâs configuration page
  * `self.environment`
    * Information about the Canvas instance your plugin is being executed on, like the subdomain, which we refer to as the customer identifier.
    * Example: `self.environment['CUSTOMER_IDENTIFIER']`
## [ Action Button Add a button that executes your custom code when clicked.
![Abridged source code of an action button
implementation.](/assets/images/sdk/handlers/ActionButton.png) ![Image of an
action button in a note header.](/assets/images/sdk/handlers/action-button-in-
action.png) ](/sdk/handlers-action-buttons/) ## [ Application Launch an iframe
when your icon is clicked in the app drawer. ![Abridged source code of an
application implementation.](/assets/images/sdk/handlers/Application-
cropped.png) ![Image of application icons in the app
drawer.](/assets/images/sdk/handlers/application-applied.png) ](/sdk/handlers-
applications/) ## [ Cron Task Execute your code on a cron-like schedule.
![Abridged source code of an action button
implementation.](/assets/images/sdk/handlers/CronTask-cropped.png) ![Picture
of Mr. Cron, the little time monster that remembers which tasks should be
executed at any given time.](/assets/images/sdk/handlers/mr-cron.png)
](/sdk/handlers-crontask/) ## [ Base Handler Respond to events with your
custom code. ![Abridged source code of a base handler
implementation.](/assets/images/sdk/handlers/BaseHandler-cropped.png)
![Stylized text that reads 'When X occurs, under Y conditions, I want Z to
happen'.](/assets/images/sdk/handlers/base-handler-can-lend-a-hand.png)
](/sdk/handlers-basehandler/)
----- END PAGE https://docs.canvasmedical.com/sdk/handlers/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-action-buttons/
# Action Buttons
Last updated: 23 Apr 2025
Action buttons are UI elements that trigger specific actions when clicked in
the Canvas UI. These buttons can be placed in different locations and can
interact with runtime data to execute custom code.
##  Overview #
An `ActionButton` class allows you to define custom buttons that appear in
different sections of the Canvas UI. When a user clicks the button, the action
associated with the button is executed. Action buttons can be added to various
locations in the UI, and you can control their visibility and behavior through
effects in a handler class.
There are no limitations on the number of action buttons you can create. You
can define multiple buttons in a single handler class or create separate
classes for each button.
##  Creating an Action Button #
To implement a custom action button, you need to create a handler class that
inherits from the `ActionButton` class. Your handler class must:
  1. Define the constants `BUTTON_TITLE`, `BUTTON_KEY`, and `BUTTON_LOCATION`.
  2. Implement the `handle()` method to specify the action that should be triggered when the button is clicked.
  3. Optionally, implement the `visible()` method to control when the button should be shown.
###  Required Constants #
  * **`BUTTON_TITLE`**  
A string that defines the label of the button displayed in the Canvas UI. This
is the text the user sees when interacting with the button.
  * **`BUTTON_KEY`**  
A unique identifier for your button. This key is used to route events, such as
a click, to the appropriate handler method (`handle()`).
  * **`BUTTON_LOCATION`**  
Specifies where the button will appear within the Canvas UI. The button can be
placed in various locations, such as the note header or footer, or other areas
within the chart summary.
  * **`PRIORITY`** An optional integer that specifies the order in which the button should appear relative to other buttons in the same location. Lower values appear first. If not specified, no order is guaranteed.
###  Optional: Implement the `visible()` Method #
By default, the `ActionButton` class assumes the button is always visible
(`return True`). If you want the button to only be visible under certain
conditions, you can override the `visible()` method. This method must return a
boolean value (`True` to show the button, `False` to hide it).
###  Implementing the `handle()` Method #
The `handle()` method is called when the action button is clicked. Inside this
method, you can define what action should occur. The `handle()` method must
return a list of [`Effect`](/sdk/effects/) objects, which represent the
actions to be executed when the button is clicked. If no action is required,
you can return an empty list.
###  Button Locations #
The `ActionButton` class defines several locations where the button can be
placed. The location is defined using the `ButtonLocation` enum. Supported
button locations include:
**Location**| **Description**  
---|---  
`NOTE_HEADER`| The button will appear in the header of each note.  
`NOTE_FOOTER`| The button will appear in the footer of each note.  
`CHART_SUMMARY_SOCIAL_DETERMINANTS_SECTION`| The button will appear in the
Social Determinants section of the chart summary.  
`CHART_SUMMARY_GOALS_SECTION`| The button will appear in the Goals section of
the chart summary.  
`CHART_SUMMARY_CONDITIONS_SECTION`| The button will appear in the Conditions
section of the chart summary.  
`CHART_SUMMARY_MEDICATIONS_SECTION`| The button will appear in the Medications
section of the chart summary.  
`CHART_SUMMARY_ALLERGIES_SECTION`| The button will appear in the Allergies
section of the chart summary.  
`CHART_SUMMARY_CARE_TEAMS_SECTION`| The button will appear in the Care Teams
section of the chart summary.  
`CHART_SUMMARY_VITALS_SECTION`| The button will appear in the Vitals section
of the chart summary.  
`CHART_SUMMARY_IMMUNIZATIONS_SECTION`| The button will appear in the
Immunizations section of the chart summary.  
`CHART_SUMMARY_SURGICAL_HISTORY_SECTION`| The button will appear in the
Surgical History section of the chart summary.  
`CHART_SUMMARY_FAMILY_HISTORY_SECTION`| The button will appear in the Family
History section of the chart summary.  
`CHART_SUMMARY_CODING_GAPS_SECTION`| The button will appear in the Coding Gaps
section of the chart summary.  
##  Example Implementations #
###  Example 1: Log Information When Button is Clicked #
This example demonstrates a simple action button that logs some information
when clicked. The button is visible only during the month of January.
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from datetime import datetime
    from logger import log
    class MyButton(ActionButton):
        BUTTON_TITLE = "ðªµ Log Action"
        BUTTON_KEY = "LOG_ACTION"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_HEADER
        def visible(self) -> bool:
            # Only show this button in January
            return datetime.now().month == 1
        def handle(self) -> list[Effect]:
            log.info("Button clicked!")
            log.info(self.event.context)
            log.info(self.event.target)
            return []
###  Example 2: Commit All Commands in a Note #
This example demonstrates an action button in the note footer that commits all
commands within a note. The button is always visible since the `visible()`
method is not overridden.
    import json
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.effects.base import EffectType
    # Define a mapping of schema_key to EffectType
    schema_key_to_effect_type = {
        "allergy": EffectType.COMMIT_ALLERGY_COMMAND,
        "assess": EffectType.COMMIT_ASSESS_COMMAND,
        "changeMedication": EffectType.COMMIT_CHANGE_MEDICATION_COMMAND,
        "closeGoal": EffectType.COMMIT_CLOSE_GOAL_COMMAND,
        "diagnose": EffectType.COMMIT_DIAGNOSE_COMMAND,
        "familyHistory": EffectType.COMMIT_FAMILY_HISTORY_COMMAND,
        "goal": EffectType.COMMIT_GOAL_COMMAND,
        "instruct": EffectType.COMMIT_INSTRUCT_COMMAND,
        "hpi": EffectType.COMMIT_HPI_COMMAND,
        "medicalHistory": EffectType.COMMIT_MEDICAL_HISTORY_COMMAND,
        "medicationStatement": EffectType.COMMIT_MEDICATION_STATEMENT_COMMAND,
        "perform": EffectType.COMMIT_PERFORM_COMMAND,
        "plan": EffectType.COMMIT_PLAN_COMMAND,
        "questionnaire": EffectType.COMMIT_QUESTIONNAIRE_COMMAND,
        "reasonForVisit": EffectType.COMMIT_REASON_FOR_VISIT_COMMAND,
        "removeAllergy": EffectType.COMMIT_REMOVE_ALLERGY_COMMAND,
        "stopMedication": EffectType.COMMIT_STOP_MEDICATION_COMMAND,
        "surgicalHistory": EffectType.COMMIT_SURGICAL_HISTORY_COMMAND,
        "task": EffectType.COMMIT_TASK_COMMAND,
        "updateDiagnosis": EffectType.COMMIT_UPDATE_DIAGNOSIS_COMMAND,
        "updateGoal": EffectType.COMMIT_UPDATE_GOAL_COMMAND,
        "vitals": EffectType.COMMIT_VITALS_COMMAND,
    }
    class CommitButtonHandler(ActionButton):
        BUTTON_TITLE = "Commit all commands"
        BUTTON_KEY = "COMMIT_ALL_COMMANDS"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_FOOTER
        def handle(self) -> list[Effect]:
            note_id = self.context.get("note_id")
            effects = []
            for command in Command.objects.filter(note_id=note_id):
                effect_type = schema_key_to_effect_type.get(command.schema_key)
                if not effect_type:
                    raise ValueError(f"No EffectType defined for schema key '{command.schema_key}'.")
                effects.append(
                    Effect(
                        type=effect_type,
                        payload=json.dumps({"command": str(command.id)}),
                    )
                )
            return effects
###  Example 3: Show Button in Vitals Section and render HTML on click #
In this example, we place a button in the Vitals section and define an action
where the button, when clicked, displays custom HTML content to the user. For
more info about `LaunchModalEffect`, check the [documentation](/sdk/layout-
effect/#modals).
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from logger import log
    class VitalsButtonHandler(ActionButton):
        BUTTON_TITLE = "ð Show Vitals Info"
        BUTTON_KEY = "SHOW_VITALS_INFO"
        BUTTON_LOCATION = ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION
        def handle(self) -> list[Effect]:
            # This method will be called when the button is clicked
            log.info("Vitals info button clicked!")
            # Custom HTML content to display
            custom_html = """
            <div style="padding: 20px; background-color: #f0f8ff; border-radius: 5px;">
                <h3>Vitals Information</h3>
                <p>Patient's latest vitals data:</p>
                <ul>
                    <li>Heart Rate: 72 bpm</li>
                    <li>Blood Pressure: 120/80 mmHg</li>
                    <li>Respiratory Rate: 16 breaths/min</li>
                    <li>Temperature: 98.6Â°F</li>
                </ul>
                <p>For more details, please refer to the full report.</p>
            </div>
            """
            # Return a LaunchModalEffect to show the custom HTML content in a modal
            return [LaunchModalEffect(
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL,
                content=custom_html
            ).apply()]
        def visible(self) -> bool:
            # Optionally, make the button visible only under specific conditions
            return True
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-action-buttons/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-applications/
# Applications
Last updated: 7 Nov 2025
Applications are accessible in the app drawer and launch your content when
clicked. Applications can be patient specific, or global.
##  Implementing an Application #
To add an application, your handler class should inherit from the
`Application` class.
Your class must implement the `on_open()` method. In most cases, you will
return a `LaunchModalEffect`, with either a URL you wish to iframe into the
Canvas UI or HTML to be rendered in that iframe directly, make sure to set a
`title` so users can easily recognize the application when itâs minimized.
You can return a single `Effect` or a list of `Effect`s from the `on_open()`
method.
You can also optionally implement the `on_context_change()` method to handle
context changes within the application. This method is automatically triggered
when users navigate to different URLs within Canvas, allowing your application
to react to contextual changes with rich information about the current page.
Context change events are currently supported for revenue workflows and
include:
  * **URL information** : The current page URL that triggered the context change
  * **Patient data** : Patient information when applicable
  * **Resource-specific context** : Additional context based on the specific page:
    * `/revenue/claims/<id>` \- Includes claim data with externally exposable ID
    * `/revenue/queues/<id>` \- Includes queue data with database ID
    * `/revenue` \- Base revenue page with no additional context
This method can return an `Effect` or list of `Effect`s to perform actions
when the applicationâs context changes, or `None` if no action is needed.
When `None` is returned, no effect will be added to the execution queue.
Here is an example of an implemented application class:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class IFrameApp(Application):
        def on_open(self) -> Effect | list[Effect]:
            return LaunchModalEffect(url=f"https://www.your-iframe-app.com",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE, title="Your Iframe App").apply()
        def on_context_change(self) -> Effect | list[Effect] | None:
            # Access the current URL that triggered the context change
            current_url = self.event.context.get("url", "")
            # Handle claim-specific context
            if claim := self.event.context.get("claim"):
                claim_id = claim["id"]
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?claim_id={claim_id}&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title=f"Your Iframe App - Claim {claim_id}"
                ).apply()
            # Handle queue-specific context
            if queue := self.event.context.get("claim_queue"):
                queue_id = queue["dbid"]
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?queue_id={queue_id}&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title=f"Your Iframe App - Queue {queue_id}"
                ).apply()
            # Handle general revenue page context
            if current_url.startswith("/revenue"):
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?page=revenue&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title="Your Iframe App - Revenue"
                ).apply()
            # Return None when no relevant context - this will result in an empty effect list
            return None
##  Context Change Events #
Context change events are automatically triggered when users navigate between
different URLs within Canvas. This feature allows your applications to react
dynamically to the userâs current context, providing relevant information
and functionality based on where they are in the system.
###  Event Triggers #
Context change events are currently supported for revenue workflows and are
triggered when:
  * A user navigates to a different URL within Canvas
  * The application is already open and running
  * The new URL is within the `/revenue` namespace
###  Context Data Structure #
When a context change event occurs, your `on_context_change()` method receives
contextual information through `self.event.context`:
    {
        "url": "/revenue/claims/123",           # Current URL that triggered the event
        "patient": {"id": "patient_key"},       # Patient information (when applicable)
        "user": {...},                          # User information
        "claim": {"id": "external_claim_id"},   # Claim context (for /revenue/claims/<id>)
        "claim_queue": {"dbid": "queue_id"}     # Queue context (for /revenue/queues/<id>)
    }
###  Supported URL Patterns #
URL Pattern| Context Provided| Description  
---|---|---  
`/revenue`| Base context only| General revenue page  
`/revenue/claims/<id>`| `claim` object with externally exposable ID| Specific
claim details page  
`/revenue/queues/<id>`| `claim_queue` object with database ID| Specific queue
management page  
###  Best Practices #
  1. **Always check for context existence** : Use safe dictionary access patterns to avoid KeyErrors
  2. **Handle multiple context types** : Your application may receive different types of context based on the URL
  3. **Return None appropriately** : When no relevant action is needed, return None to avoid unnecessary effects
###  Advanced Example #
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class AdvancedRevenueApp(Application):
        def on_open(self) -> Effect | list[Effect]:
            return LaunchModalEffect(
                url="https://www.your-app.com/dashboard",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                title="Revenue Analytics"
            ).apply()
        def on_context_change(self) -> Effect | list[Effect] | None:
            current_url = self.event.context.get("url", "")
            patient = self.event.context.get("patient", {})
            user = self.event.context.get("user", {})
            # Build base parameters
            params = {
                "source_url": current_url,
                "user_id": user.get("id", ""),
                "patient_id": patient.get("id", "")
            }
            # Handle specific contexts
            if claim := self.event.context.get("claim"):
                params["claim_id"] = claim["id"]
                params["view"] = "claim_details"
                title = f"Revenue Analytics - Claim {claim['id']}"
            elif queue := self.event.context.get("claim_queue"):
                params["queue_id"] = queue["dbid"]
                params["view"] = "queue_management"
                title = f"Revenue Analytics - Queue {queue['dbid']}"
            elif current_url.startswith("/revenue"):
                params["view"] = "revenue_overview"
                title = "Revenue Analytics - Overview"
            else:
                # No relevant context for this application
                return None
            # Build query string
            query_string = "&".join(f"{k}={v}" for k, v in params.items() if v)
            return LaunchModalEffect(
                url=f"https://www.your-app.com/revenue?{query_string}",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                title=title
            ).apply()
In addition, your `CANVAS_MANIFEST.json` file must provide some information
about your application. You reference your class in the âapplicationsâ
section of the components so your application is registered in the app drawer
on plugin installation.
This is also where you can define the title and icon that displays your app in
the app drawer. The icon will be rendered at 48px by 48px, so should be square
and simple enough to not lose detail at that size.
Other information you can define about your application is the `scope`
(`"patient_specific"` or `"global"`), which determines if the application is
visible only in a patient chart or outside of charts.
If you want to increase your applicationâs visibility and display it
alongside other panel buttons (instead of in the applications drawer), you can
add the `show_in_panel` attribute. If youâve added more than one application
to that panel, you can set their priorities using the `panel_priority`
attribute.
For security reasons you also need to specify the domains that will be loaded
within the iframe, or they will not be rendered. For more info on the format
of the `url_permissions` field, check the [Additional
Configuration](/sdk/layout-effect/#additional-configuration) for
`LaunchModalEffect`.
Hereâs what your `CANVAS_MANIFEST.json` might look like:
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "my_application",
      "description": "This is a very nice application",
      "url_permissions": [
        {
          "url": "https://example.com/",
          "permissions": ["ALLOW_SAME_ORIGIN", "MICROPHONE", "SCRIPTS", "CAMERA"]
        }
      ],
      "components": {
        "protocols": [],
        "applications": [
          {
            "class": "my_application.apps.iframe:IFrameApp",
            "name": "My Application",
            "description": "Test App for patients",
            "icon": "/assets/cappuccino.png",
            "scope": "patient_specific",
            "show_in_panel": true,
            "panel_priority": 100
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-applications/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-basehandler/
# Base Handler
Last updated: 7 Nov 2025
The `BaseHandler` is the simplest of all handlers. Specify which events you
are interested in, then provide the code to execute when one of those events
is emitted. All the [handlers](/sdk/handlers/) inherit from `BaseHandler`, and
many of yours will too.
##  Handling Events With `BaseHandler` #
To create a class that responds to one or more events, inherit from
`BaseHandler`, set the `RESPONDS_TO` constant, and implement the `compute()`
method.
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class MyEventHandler(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            # Your code goes here!
            return []
You can respond to one event, or several. To respond to multiple events, set
`RESPONDS_TO` to a list of [event types](/sdk/events/).
    # Respond when tasks are created:
    RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
    # Respond when tasks are created OR updated:
    RESPONDS_TO = [
        EventType.Name(EventType.TASK_CREATED),
        EventType.Name(EventType.TASK_UPDATED),
    ]
The `compute()` method must return a list of [Effects](/sdk/effects/). That
list can be empty, of course. You have access to event information with
`self.event`, `self.target`, and`self.context`, as well as configuration
information for your plugin with `self.secrets` and for the running instance
with `self.environment`. You can use our [Data Module](/sdk/data/) to retrieve
additional information at runtime.
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-basehandler/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-crontask/
# CronTask
Last updated: 7 Nov 2025
You can write a handler that subclasses `CronTask` to execute code on a
schedule. You might use this to automate reporting on task performance (every
hour, send the number of tasks created during the previous hour, and the
number of tasks completed during the previous hour), to send birthday wishes
to your patients (at 7am every morning, find patients born on this day and
send them an email wishing them a happy birthday), or to send customized
appointment reminders (every hour, find appointments that start on this hour
the following day and send the patients of those appointments a message that
says âDr. X is looking forward to seeing you at (location) at (time)â).
##  Example #
This example `CronTask` shows an extremely basic example that just logs the
time. You can see the critical pieces here:
  * Subclass `CronTask`
  * Set your `SCHEDULE` with a cron string
  * Implement an `execute` method with the code you want to schedule to run, returning a list containing any effects you want to return, or an empty list if you do not wish to return any effects.
    from canvas_sdk.handlers.cron_task import CronTask
    from canvas_sdk.effects import Effect
    from logger import log
    class LogTheTime(CronTask):
        # A cron string.
        #           ââââââââââââââ minute (0 - 59)
        #           â ââââââââââââââ hour (0 - 23)
        #           â â ââââââââââââââ day of the month (1 - 31)
        #           â â â ââââââââââââââ month (1 - 12)
        #           â â â â ââââââââââââââ day of the week (0 - 6) (Sunday to Saturday)
        #           â â â â â
        #           â â â â â
        #           â â â â â
        SCHEDULE = "* * * * *"  # Run every minute, which is the most frequently something can run.
        def execute(self) -> list[Effect]:
            # The current timestamp can be found as an iso8601 string in
            # `self.target`
            log.info(f"The current time is {self.target}")
            # We don't need to return any effects
            return []
###  Output #
Hereâs what this scheduled task would output in the logs:
`INFO 2024-07-18 18:47:00,000 The current time is
2024-07-18T18:47:00.000000+00:00`
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-crontask/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api/
# SimpleAPI
Last updated: 15 May 2025
The Canvas SDK allows developers to define both HTTP and WebSocket APIs to
integrate custom plugin logic into a Canvas instance.
[ HTTP APIDefine endpoints to handle incoming HTTP requests using custom logic
and authentication. ](/sdk/handlers-simple-api-http) [ WebSocket APIEstablish
real-time communication channels for interactive plugin behavior and updates.
](/sdk/handlers-simple-api-websocket)
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-http/
# SimpleAPI HTTP
Last updated: 24 Sep 2025
The Canvas SDK provides a way to define an HTTP API with any number of
endpoints in your instance. Developers can define the routes and implement the
code that will handle incoming HTTP requests.
This feature allows developers to create endpoints that can receive webhook
events from other services. An endpoint receiving a request can invoke Effects
in a Canvas instance, send another request to a different service, or simply
return a response back to the requester.
##  Quickstart #
Follow the instructions in [Your First
Plugin](https://docs.canvasmedical.com/guides/your-first-plugin/) to create a
plugins project. For this exercise, use `my_api` as your project (i.e. plugin)
name.
Open `CANVAS_MANIFEST.json` in your editor. You can modify filenames,
directory structures, and class names as you see fit in your project, but for
this exercise, we are just going to set the value at `components -> protocols
-> 0 -> class` to be `my_api.protocols.my_protocol:MyAPI`.
Weâre going to need a secret value for authentication. The instructions for
declaring secrets are outlined on the [Your First
Plugin](https://docs.canvasmedical.com/guides/your-first-plugin/) page.
Declare a secret in `CANVAS_MANIFEST.json` named `my-api-key`.
Open `my_api/protocols/my_protocol.py` and replace the contents of the file
with this code:
    from hmac import compare_digest
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            provided_api_key = credentials.key
            api_key = self.secrets["my-api-key"]
            # compare_digest requires bytes, so we must encode the strings
            return compare_digest(provided_api_key.encode(), api_key.encode())
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
The next step is to deploy your plugin; the instructions for doing so are on
the [Your First Plugin](https://docs.canvasmedical.com/guides/your-first-
plugin/) page.
You can see in the code above that the `authenticate` method is going to
authenticate using API key authentication. Weâve already declared the
secret, so now we need to generate a value and set it on your instance. You
can generate an API key like this:
    python -c "import secrets; print(secrets.token_hex(16))"
Copy the value that it prints out and set the value for `my-api-key` in your
plugin secrets on your instance.
Now that your plugin is deployed and your secret is set, you can send requests
to your endpoint with `curl`. The `curl` command would look like the following
(note that you will need to supply your instance name and API key):
    curl --location 'https://<instance-name>.canvasmedical.com/plugin-io/api/my_api/routes/hello-world' \
         --header 'Authorization: <api-key>'
##  Defining APIs #
The Canvas SDK offers two styles for defining API endpoints. To implement an
API endpoint or set of endpoints using one of the two styles, your handler
will simply inherit from a specific base class. The following HTTP verbs are
supported:
  * GET
  * POST
  * PUT
  * DELETE
  * PATCH
###  SimpleAPIRoute #
For handlers that inherit from **SimpleAPIRoute** , you set a class variable
in your handler called `PATH` as in the example above, and then
implementations of the HTTP verbs you wish to support on that path. The method
names will match the names of the HTTP verbs, but lowercased.
The plugin name and the `PATH` value together will form the unique part of the
full URL for your endpoint. The format of the full URL will be:
`https://<instance-name>.canvasmedical.com/plugin-io/api/<plugin-name>/<PATH>`
We can adapt the previous example to add a POST endpoint for the same route on
the same handler:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my GET endpoint!"})
            ]
        def post(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my POST endpoint!"})
            ]
The handler can now respond to both GET and POST requests at `/routes/hello-
world`.
###  SimpleAPI #
For handlers that inherit from **SimpleAPI** , the syntax is a little
different. You can include any number of endpoints in your handler class, and
you can name your route handling methods anything you wish. Here is an
example:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPI, api
    class MyAPI(SimpleAPI):
        PREFIX = "/routes"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        @api.get("/hello-world")
        def hello_world_get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my GET endpoint!"})
            ]
        @api.post("/hello-world")
        def hello_world_post(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my POST endpoint!"})
            ]
        @api.get("/goodbye")
        def goodbye_get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Goodbye from my GET endpoint!"})
            ]
This syntax will be familiar if you have used Python API frameworks like
`Flask` or `FastAPI`. The decorator functions are named for the HTTP verb you
wish to implement on the route, and the URL path is passed into the decorator
function. If you have many endpoints that you wish to share the same
authentication, this syntax may be more convenient.
You can also specify a path `PREFIX` value for endpoint grouping purposes, as
shown in the example above. If you have multiple endpoints that will all have
the same path prefix, you can specify it by setting a value for `PREFIX`. With
`PREFIX` set, each endpoint does not have to individually specify the
`/routes` portion of the URL path.
###  Path patterns #
If you want to set up an endpoint that will respond to requests where the path
matches a pattern rather than an exact string, you can use a path pattern.
This is common in cases where the path of an endpoint contains a resource
identifier.
You can specify a path pattern by by denoting any number of the path
parameters in the path using `<>` syntax, with the name of the path parameters
in between the angle brackets. Path parameter names must be be unique within
the path. They can also be specified in the path prefix (for **SimpleAPI**
handlers).
Path parameters will be extracted from the path and will be available on the
request object in the `path_params` attribute.
In the example below, the value `id` is specified as part of the path, and can
be accessed by the handler:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world/<id>"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            id_ = self.request.path_params["id"]
            return [
                JSONResponse(
                    {
                        "message": "Hello world from my GET endpoint!",
                        "id": id_
                    }
                )
            ]
####  Path matching #
When you specify routes using path patterns, it is possible that multiple
endpoints may match with a request. This has a few implications that need to
be considered, because only one endpoint can provide a response.
If the endpoints that match are all part of the same handler class, then the
request will be handled by the endpoint that appears highest up in the class
definition, i.e. the one that is defined first. Consider two endpoints
specified to match the following patterns:
    /routes/hello-world/current-user
    /routes/hello-world/<id>
The first uses an exact match, and the second uses a pattern. The path
`/routes/hello-world/current-user` matches both of those patterns. However, if
you register the second endpoint first it would never be possible for a
request with the path of `/routes/hello-world/current-user` to match with the
endpoint for `/routes/hello-world/current-user`. If you need to define
endpoints that use exact matching that may overlap with endpoints defined with
path patterns, order must be carefully considered.
If, however, you have defined multiple **SimpleAPIRoute** or **SimpleAPI**
handlers, and a request matches with multiple endpoints across these handlers,
an error condition will result. There is not a way to specify priority across
handlers, so if you need fine-grained control over request routing for
endpoints that use path patterns, make sure they are contained within the same
handler class.
###  Request objects #
When a handler is invoked to handle an incoming HTTP request, the request
object is available as an attribute on the handler. The request method, path,
query parameters, content type, and body are all available as attributes on
the request object:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    from logger import log
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            request = self.request
            # HTTP method
            method = request.method
            # URL path component
            path = request.path
            # Raw query string
            query_string = request.query_string
            # Query parameters as a key-value mapping
            query_params = request.query_params
            # Request headers
            headers = request.headers
            # Request body content type
            content_type = request.content_type
            # Raw body
            body = request.body
            # JSON body as a Python dictionary (for requests with application/json content types)
            json_body = request.json()
            # Body as plain text
            text_body = request.text()
            # Body parsed as form data
            form_data = request.form_data()
            return [
                JSONResponse({"message": "Hello world!"})
            ]
####  Key-value mappings #
Attributes on the request object like headers, query parameters, and form data
can in most cases be represented by mappings containing key-value pairs (e.g.
Python dictionaries) with a small caveat: keys are not required to be unique.
Because of this, there can be more than one value per key.
These attributes are represented by a data structure that most of the time
will behave like a Python dictionary, unless you want to access the additional
values for a key. If you do request the value for a key using standard
dictionary syntax, you will get the first value that was encountered for that
key. If you want the other values, you will need to use different methods to
access them.
Here is an example showing how to access the additional values:
    # Request sent to /route?value1=a&value1=b&value2=c
    query_params = request.query_params
    # Get the first value for value1
    value1: str = query_params["value1"]
    # Get all values for value1 with get_list
    value1_all: list[str] = query_params.get_list("value1")
    # Iterate over all query parameters (repeating keys if necessary) with multi_items
    for key, value in query_params.multi_items():
        log.info(f"key:   {key}")
        log.info(f"value: {value}")
####  Forms #
If your endpoint is set up to accept `application/x-www-form-urlencoded` or
`multipart/form-data` data, there is method named `form_data` on the request
object that will parse the request body. This method will return a key-value
mapping containing `FormPart` objects, each of which represents a subpart of
the form.
Every subpart in a form has a name, and these names are the keys in the
mapping that is returned by the method. A `FormPart` can represent either a
simple string value or a file. A `FormPart` that represents a string will have
attributes for `name` and `value`. A `FormPart` that represents a file will
have attributes for `name`, `filename`, `content`, `content_type`.
If the content type of a request is `application/x-www-form-urlencoded`, then
all `FormPart` objects will represent simple string values. If the content
type of a request is `multipart/form-data`, then each `FormPart` object may
represent either a simple string value or a file.
Here is an example of how to use the `form_data` method to iterate over the
subparts of a request body with form data:
    form_data = request.form_data()
    # To iterate over all parts, we have to use the multi_items method because there may be more than
    # one part with the same name
    for name, part in form_data.multi_items():
        log.info(f"part name:    {name}")
        if part.is_file():
            # It's a file
            log.info(f"content:      {part.content}")
            log.info(f"filename:     {part.filename}")
            log.info(f"content type: {part.content_type}")
        else:
            # It's a simple string
            log.info(f"value:        {part.value}")
If you know the name of the subparts you are looking for, you can also access
the subparts directly by looking up the name in the mapping returned by
`form_data`:
    form_data = request.form_data()
    # Get the first part named "my-part-name"
    part = form_data["my-part-name"]
    # Get all parts named "my-part-name"
    parts_all = form_data.get_list("my-part-name")
###  Responses #
Endpoint handlers may return zero or one response objects and any number of
Effects. Handlers that return multiple response objects will return a **500
Internal Server Error** response back to the requester. If your endpoint does
not provide a response object, then the requester will receive a **204 No
Content** response.
####  Response types #
Several response types are provided for convenience:
  * HTMLResponse
  * JSONResponse
  * PlainTextResponse
  * Response (for returning raw content)
In addition to the response body, you can also specify the response status
code and the response headers.
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import HTMLResponse, JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            return [
                HTMLResponse(
                    "<p>Hello world from my GET endpoint!</p>",
                    status_code=HTTPStatus.OK,
                    headers={"My-Header", "my header value"}
                )
            ]
        def post(self) -> list[Response | Effect]:
            return [
                JSONResponse(
                    {"message": "Hello world from my POST endpoint!"},
                    status_code=HTTPStatus.CREATED,
                    headers={"My-Header", "my header value"}
                )
            ]
        def put(self) -> list[Response | Effect]:
            return [
                PlainTextResponse(
                    "Hello world from my PUT endpoint!",
                    status_code=HTTPStatus.ACCEPTED,
                    headers={"My-Header", "my header value"}
                )
            ]
        def patch(self) -> list[Response | Effect]:
            return [
                Response(
                    b'{"message": "Hello world from my PATCH endpoint!"}',
                    status_code=HTTPStatus.NOT_MODIFIED,
                    headers={"My-Header", "my header value"},
                    content_type="application/json"
                )
            ]
####  Returning Effects #
**SimpleAPI** endpoints can return any number of Effects just like any Canvas
plugin; this is why **SimpleAPI** endpoints return a list of items rather than
just a single response object.
Any effects present in the list returned by an endpoint will be processed by
your Canvas instance, and the response object, if provided, will be sent back
to the original requester.
###  Authentication #
Defining an `authenticate` method on your handler is required. By default,
**SimpleAPI** handlers will return a **401 Unauthorized** response if no
`authenticate` method is defined. The `authenticate` method should return
`True` or `False` depending on whether the requester is authenticated.
Please keep in mind that while setting plugins secrets on your instance is out
of scope for this guide, best practices would dictate that most `authenticate`
methods would use these secrets to authenticate credentials in a request
(OAuth being a notable exception). Your secrets can be accessed through the
`secrets` attribute on the handler.
Additionally, to assist with adhering to security and cryptography best
practices, the Python `hashlib`, `hmac`, and `secrets` modules are available
for use.
Examples of how to define `authenticate` methods for various authentication
schemes are shown in the next section, but if you are interested in something
that is more âbatteries includedâ, please skip ahead to the Authentication
mixins section below. The API key authentication mixin is a good choice that
offers simplicity and good security if you need something to get started.
####  Authentication schemes #
The Canvas SDK can parse and validate the format of the Authentication header
automatically for several authentication schemes, but you must authenticate
the credentials in your `authenticate` method. You can specify which
authentication scheme you want to use for your route or API in the method
signature of your `authenticate` method.
#####  Basic #
For Basic authentication, use `BasicCredentials`:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import BasicCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: BasicCredentials) -> bool:
            provided_username = credentials.username
            provided_password = credentials.password
            # Validate provided username and password against a username and password in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
#####  Bearer #
For Bearer authentication, use `BearerCredentials`:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import BearerCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: BearerCredentials) -> bool:
            provided_token = credentials.token
            # Validate provided access token via OAuth
            ...
        def get(self) -> list[Response | Effect]:
            ...
#####  API key #
For API key authentication, use `APIKeyCredentials`:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            provided_api_key = credentials.key
            # Validate provided key against an API key in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
#####  Session #
To authenticate using a logged-in userâs session, use `SessionCredentials`:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import SessionCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: SessionCredentials) -> bool:
            logged_in_user = credentials.logged_in_user
            # Structure looks like:
            # {
            #     "id": "abc123",
            #     "type": "Staff"
            # }
            # Where "type" is "Staff" or "Patient"
            # You could authenticate based on type or check to see if the
            # individual is in a particular group or team.
            ...
        def get(self) -> list[Response | Effect]:
            ...
#####  Custom #
Itâs also possible to create custom authentication schemes. There are two
ways to do this.
The first way is to access authentication headers on the request object
directly. If you wish to do this, then you would define your authenticate
method to take a `Credentials` object, and pull the authentication values from
the request headers:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: Credentials) -> bool:
            provided_api_key = self.request.headers["My-API-Key"]
            provided_app_key = self.request.headers["My-App-Key"]
            # Validate provided credentials against the credentials in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
Another way to do this is by defining your own `Credentials` subclass which
obtains the authentication values out of the request headers:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPIRoute
    from canvas_sdk.handlers.simple_api.api import Request
    class MyCredentials(Credentials):
        def __init__(self, request: Request) -> None:
            self.api_key = self.request.headers['My-API-Key']
            self.app_key = self.request.headers['My-App-Key']
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: MyCredentials) -> bool:
            provided_api_key = credentials.api_key
            provided_app_key = credentials.app_key
            # Validate provided credentials against the credentials in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
####  Authentication mixins #
The Canvas SDK offers several âbatteries includedâ authentication mixins
that you can use to implement your authentication method. If you choose to use
these, then the only action you must take is to ensure that you set the
appropriate secrets for your plugin on your instance.
Make sure you always list the mixin class to the left of the base class, which
is **SimpleAPIRoute** in the examples below.
#####  Basic #
If you want an implementation of Basic authentication, you can use the
`BasicAuthMixin`. You will need to declare the `simpleapi-basic-username` and
`simpleapi-basic-password` secrets in your manifest file, and then set the
secrets on your instance after you deploy your plugin.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import BasicAuthMixin, SimpleAPIRoute
    class MyAPI(BasicAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
#####  API key #
If you want an implementation of API key authentication, you can use the
`APIKeyAuthMixin`. You will need to declare the `simpleapi-api-key` secret in
your manifest file, and then set the secret on your instance after you deploy
your plugin.
You can generate a secure, random API key like this:
    python -c "import secrets; print(secrets.token_hex(16))"
Copy the output from that command, and set the `simpleapi-api-key` secret on
your instance.
After you set your secret, you can use the `APIKeyAuthMixin`:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPIRoute
    class MyAPI(APIKeyAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
#####  Staff Session #
If you want to ensure the visiting user is a logged in staff user, you can use
the `StaffSessionAuthMixin`. This makes no assertions about the particular
staff member, just that they are staff, and that they are logged in.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import StaffSessionAuthMixin, SimpleAPIRoute
    class MyAPI(StaffSessionAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
#####  Patient Session #
If you want to ensure the visiting user is a logged in patient user, you can
use the `PatientSessionAuthMixin`. This makes no assertions about the
particular patient, just that they are a patient, and that they are logged in.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import PatientSessionAuthMixin, SimpleAPIRoute
    class MyAPI(PatientSessionAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-http/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-websocket/
# SimpleAPI WebSocket
Last updated: 15 Jul 2025
WebSocket APIs in Canvas let you define **channels** that clients can connect
to. These APIs support one-way, server-to-client communication, and are
designed for use cases such as real-time notifications.
###  Defining a WebSocket API #
To define a WebSocket handler, subclass `WebSocketAPI`. You must implement an
`authenticate` method that determines whether the connection should be
accepted.
    from canvas_sdk.handlers.simple_api.websocket import WebSocketAPI
    class MyWebSocketAPI(WebSocketAPI):
        def authenticate(self) -> bool:
            ...
If `authenticate()` returns `True`, the connection is accepted. Otherwise, it
is denied.
Clients should connect using a URL that maps to your plugin and channel name:
    wss://<instance>.canvasmedical.com/plugin-io/ws/<plugin_name>/<channel_name>/
###  WebSocket Object #
When a handler is invoked, the `websocket` object is available as an attribute
on the handler. This object provides details about the connection, including:
  * `channel`: The channel name from the connection URL
  * `headers`: A dictionary of headers associated with the connection
  * `api_key`: The api key, if present
  * `logged_in_user`: A dictionary like `{ "id": ..., "type": ... }` if a logged-in user is present
You can access this object within your handler methods using `self.websocket`.
###  Authentication #
You must implement the `authenticate()` method in your handler class. Two
authentication methods are supported:
#####  Session-Based (Internal Clients) #
For connections initiated from within the Canvas browser UI by a logged-in
user:
    def authenticate(self) -> bool:
        logged_in_user = self.websocket.logged_in_user
        # Structure looks like:
        # {
        #     "id": "abc123",
        #     "type": "Staff"
        # }
        # Where "type" is "Staff" or "Patient"
        # You could authenticate based on type or check to see if the
        # individual is in a particular group or team.
        ...
#####  APIKey-Based (External Clients) #
For external tools or scripts, pass an auth key as a query parameter:
    wss://<instance>.canvasmedical.com/plugin-io/ws/<plugin>/<channel>?api_key=<key>
The key is made available in your handler via `self.websocket.api_key`. You
can store this key as a secret.
    def authenticate(self) -> bool:
      provided_token = self.websocket.api_key
      # Validate provided key against an API key in self.secrets
      ...
###  Broadcasting Messages #
To send a message to all connected clients on a WebSocket channel, use the
`Broadcast` effect. This effect can be returned from any handler.
The `Broadcast` effect takes the following parameters:
  * `message`: A JSON-serializable Python dictionary or value.
  * `channel`: The target channel name as a string.
Hereâs an example using a SimpleAPI HTTP POST route to trigger a broadcast:
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Broadcast, JSONResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    class WebhookAPI(SimpleAPI):
        @api.post("/callback")
        def broadcast_message(self) -> list[Response | Effect]:
            body = self.request.json()
            return [
                Broadcast(message=body, channel="notifications").apply(),
                JSONResponse({"status": "ok"}, status_code=HTTPStatus.ACCEPTED),
            ]
In this example, when the `/callback` endpoint receives a POST request, it
broadcasts the request body as a message to all clients subscribed to the
`notifications` channel.
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-websocket/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/protocols/
# Protocols
Last updated: 23 Sep 2025
The protocols module lets you define workflows and workflow automations.
Protocols respond to [Events](/sdk/events/) and return zero, one, or many
[Effects](/sdk/effects/).
##  Contents #
  * BaseProtocol
  * ClinicalQualityMeasure
##  BaseProtocol #
`BaseProtocol` is the abstract base class all protocol implementations inherit
from. It extends the handler contract (`BaseHandler`) and provides the
lifecycle and surface area plugin authors implement for event-driven
protocols.
###  Purpose & lifecycle #
  * The framework will call `compute()` on the protocol instance when an event should be handled. `compute()` must return a list of `Effect` objects that the runtime will apply.
  * Protocols must override the `compute()` method.
###  Constructor and attributes #
  * Your protocol should inherit from `BaseProtocol` and define the following:
    * `RESPONDS_TO` â The `Event(s)` that trigger the protocol.
    * `compute` â The method that handles the Event and returns a list of Effects.
  * Instance attributes available to protocol authors:
    * `self.event` â The `Event` instance.
    * `self.secrets` â Secrets provided to the protocol (defaults to {}).
###  Example #
    from canvas_sdk.protocols.base import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.effects.task import AddTask
    class SimpleFollowUpProtocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.IMAGING_REPORT_CREATED)
        def compute(self):
            # Use self.event, self.secrets
            patient_id = self.event.context["patient"]["id"]
            imaging_report_id = self.event.target.id
            # Create a follow-up task effect
            return [AddTask(patient_id=patient_id, title="Follow-up", linked_object_type=AddTask.LinkableObjectType.IMAGING, linked_object_id=imaging_report_id).apply()]
##  ClinicalQualityMeasure #
`ClinicalQualityMeasure` is the base class for clinical quality measure (CQM)
protocols. CQMs are patient-centric protocols used to evaluate, detect, or
surface clinical conditions, gaps in care, and population-level metrics.
Plugin authors create concrete subclasses that implement the clinical logic
and return Effects in response to incoming Events.
When using `ClinicalQualityMeasure`, you have the option to utilize the
[Campaigns](https://help.canvasmedical.com/articles/3097826946-campaigns-
populations-patients) module in Canvas. However, the `ClinicalQualityMeasure`
must return a single [`ProtocolCard`](/sdk/effect-protocol-cards/) effect in
order to for patients to be included in the population for that CQM.
###  Meta properties #
Subclasses should populate the `Meta` inner class. Common meta fields include:
  * `title` (str): Human-readable title for the protocol.
  * `identifiers` (list[str]): One or more external identifiers for the measure (for example, CMS/QDM ids). These will show in the subtitle of the protocol card.
  * `description` (str): A short description of what the measure evaluates.
  * `information` (str): Longer contextual information or rationale.
  * `references` (list[str]): Links or identifiers for authoritative references. These are visible in the info button on the protocol card.
  * `source_attributes` (dict[str, str]): Map of the 13 or 31 source attributes that certified health IT developers must reference when implementing DSI or PDSI. These are visible in the info button on the protocol card.
  * `types` (list[str]): Tags or classification strings for the measure, like âCQMâ or âHCCâ. These are visible in the subtitle of the protocol card.
  * `authors` (list[str]): Authors or maintainers of the protocol.
  * `show_in_chart` (bool): Determines whether the protocol card will show on the patientâs chart.
  * `show_in_population` (bool): Determines whether the protocol will be included in the Campaigns module of Canvas.
  * `can_be_snoozed` (bool): Determines whether a user can snooze the protocol card to be addressed at a later date.
  * `is_abstract`, `is_predictive` (bool): Behavioral flags for the framework.
###  Key methods #
  * `timeframe` (property) -> `Timeframe`
    * Provides the default timeframe used by the protocol when searching for relevant events or records. The default implementation returns a timeframe with a start one year before now and an end at the current time. Subclasses can override this property to adjust the window of interest.
  * `relative_float(value: str) -> float`
    * Parses comparison-style numeric strings that may include relational prefixes like `<`, `<=`, `>` or `>=`. Returns a float adjusted slightly (Â±1e-6) for strict `<` or `>` operators so comparisons can be expressed without ambiguity. If parsing fails, returns `0`.
  * `patient_id_from_target()` -> str
    * Extracts and caches the patient id from a protocol event target for supported event types. The method supports a variety of patient-centric event targets (Conditions, LabOrders, LabReports, Medications, Patient create/update events, and ProtocolOverride events). The first call will fetch and cache the patient id to avoid repeated DB lookups. If an unsupported event type is provided a `ValueError` is raised.
###  Example â react to a lab report #
This example shows a protocol that reacts to `LAB_REPORT_CREATED` events, uses
`patient_id_from_target` to determine which patient the report belongs to, and
emits an Effect when a particular lab value is out of range. Note the example
avoids heavy synchronous DB work and emits an Effect for the platform to
handle asynchronously.
    from datetime import datetime
    from canvas_sdk.commands import TaskCommand
    from canvas_sdk.effects.protocol_card import ProtocolCard
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols.clinical_quality_measure import ClinicalQualityMeasure
    class AbnormalPotassiumMeasure(ClinicalQualityMeasure):
        """Detects clinically significant potassium abnormalities and surfaces follow-up tasks."""
        class Meta:
            title = "Abnormal Potassium Alert"
            identifiers = ["CQM-K-001"]
            description = "Creates a task recommendation when a potassium lab report shows hypokalemia or hyperkalemia."
            information = (
                "Detects clinically significant potassium abnormalities and surfaces follow-up tasks."
            )
            references = ["Potassium Guideline https://example.org/guideline/potassium"]
            source_attributes = {"Canvas Medical": "Canvas Medical https://www.canvasmedical.com"}
            types = ["CQM"]
            authors = ["Clinical Team"]
            show_in_chart = True
            show_in_population = True
            can_be_snoozed = False
            is_abstract = False
            is_predictive = False
        RESPONDS_TO = EventType.Name(EventType.LAB_REPORT_CREATED)
        def compute(self):
            # Resolve patient id (cached on first call)
            patient_id = self.patient_id_from_target()
            # Read the lab report values from the event target (avoid extra DB queries here)
            report = self.event.target
            potassium_value = report.get_value('potassium')  # simplified accessor
            # Use relative_float to safely parse any comparator-style values
            k = self.relative_float(str(potassium_value))
            if k < 3.5 or k > 5.5:
                # Emit an effect â e.g., create a task. Keep heavy work to platform handlers.
                task = TaskCommand(
                    title="Follow-up on abnormal potassium",
                    due_date=datetime.now().date(),
                )
                return [
                    ProtocolCard(
                        patient_id=patient_id,
                        title=f"Abnormal potassium: {k}",
                        due=datetime.now(),
                        key="abnormal_potassium",
                        narrative="Talk to patient about potassium",
                        recommendations=[task.recommend(title="Follow-up on abnormal potassium")],
                    ).apply()
                ]
            return []
![ProtocolCard]()
When a CQM protocol that returns a single ProtocolCard effect is uploaded to
Canvas, you can select the protocol as an option in the Campaigns module and
view the population of patients, create campaigns, etc. More details on
Populations and Campaigns can be found
[here](https://help.canvasmedical.com/articles/3097826946-campaigns-
populations-patients).
###  Caveats & notes #
  * Timeframe: by default the protocol looks at the 1-year window prior to now. Override `timeframe` if your measure requires a broader or narrower lookback.
  * patient id resolution: `patient_id_from_target()` supports only the event types enumerated by the implementation; verify the event you plan to subscribe to maps to a supported model. When used heavily, this method avoids extra DB queries by caching the patient id on the instance.
  * Event-driven protocols should avoid expensive synchronous DB operations inside their event handler. When possible, emit Effects that are handled asynchronously by the platform.
----- END PAGE https://docs.canvasmedical.com/sdk/protocols/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/utils/
# Utils
Last updated: 24 Sep 2025
##  Making requests with Http #
The Canvas SDK offers a helper class for completing HTTP calls.
    from canvas_sdk.utils import Http
    http = Http()
###  get #
Sends a GET request.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`url`|  _string_| `true`| The url of the request.  
`headers`|  _dict_| `false`| The headers to include in the request.  
**Example** :
    from canvas_sdk.utils import Http
    http = Http()
    http.get("https://my-url.com/", headers={"Authorization": f"Bearer token"})
###  post #
Sends a POST request.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`url`|  _string_| `true`| The url of the request.  
`headers`|  _dict_| `false`| The headers to include in the request.  
`json`|  _dict_| `false`| The json to include in the request.  
`data`|  _dict_ or _string_| `false`| The data to include in the request.  
**Example** :
    from canvas_sdk.utils import Http
    http = Http()
    http.post(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"post": "json"},
        data="this-is-my-data"
    )
###  put #
Sends a PUT request.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`url`|  _string_| `true`| The url of the request.  
`headers`|  _dict_| `false`| The headers to include in the request.  
`json`|  _dict_| `false`| The json to include in the request.  
`data`|  _dict_ or _string_| `false`| The data to include in the request.  
**Example** :
    from canvas_sdk.utils import Http
    http = Http()
    http.put(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"put": "json"},
        data="this-is-my-data"
    )
###  patch #
Sends a PATCH request.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`url`|  _string_| `true`| The url of the request.  
`headers`|  _dict_| `false`| The headers to include in the request.  
`json`|  _dict_| `false`| The json to include in the request.  
`data`|  _dict_ or _string_| `false`| The data to include in the request.  
**Example** :
    from canvas_sdk.utils import Http
    http = Http()
    http.patch(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"patch": "json"},
        data="this-is-my-data"
    )
##  Making concurrent requests with Http #
There is an interface for executing HTTP requests in parallel.
The `batch_requests` method will execute the requests in parallel using
multithreading, and return once all the requests have completed.
The first parameter to the method is an iterable of `BatchableRequest`
objects. These can be created with the following helper functions:
    batch_get
    batch_post
    batch_put
    batch_patch
The parameters that these helper functions accept match what the corresponding
single-request methods accept.
The `timeout` parameter allows for specifying a timeout value in seconds; if a
request has not completed before the timeout value, an error will be returned
for that request. The maximum allowed value for `timeout` is 30 seconds. If
`timeout` is not specified, it will be set to the maximum value.
The return value will be a list of responses to the requests. The order of the
return value will correspond to the order of the provided requests.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`batch_requests`|  _Iterable[BatchableRequest]_| `true`| The list of batched
requests.  
`timeout`|  _integer_| `false`| The timeout value in seconds.  
**Example** :
    from canvas_sdk.utils import Http, batch_get, batch_post, batch_put, batch_patch
    http = Http()
    requests = [
        batch_get("https://my-url.com/", headers={"Authorization": f"Bearer token"}),
        batch_post("https://my-url.com/", headers={"Authorization": f"Bearer token"}, json={"post": "json"}),
        batch_put("https://my-url.com/", headers={"Authorization": f"Bearer token"}, data="this-is-my-data"),
        batch_patch("https://my-url.com/", headers={"Authorization": f"Bearer token"}, json={"patch": "json"})
    ]
    responses = http.batch_requests(requests, timeout=10)
##  Making requests to the Ontologies service #
Plugin authors can make requests to our Ontologies service using the
`ontologies_http` wrapper.
In addition to the `json()` method of the response, which youâll use to
access the response itself, you can also access the `status_code` to verify
that the request was succcessful.
###  `fdb_code` #
Elsewhere in the SDK there are commands that take an `fdb_code` or
`new_fdb_code`, some examples being
[`AdjustPrescriptionCommand`](/sdk/commands/#adjustprescription),
[`MedicationStatementCommand`](/sdk/commands/#medicationstatement),
[`PrescribeCommand`](/sdk/commands/#prescribe), and
[`RefillCommand`](/sdk/commands/#refill). The value to be sent as the
`fdb_code` is returned in the search payloads below as the
`med_medication_id`.
###  Searching for medications #
Plugin authors can search for medications by NDC code, RxNorm RXCUI, FDB code,
or full-text search.
    from urllib.parse import urlencode
    from canvas_sdk.utils.http import ontologies_http
    # full text search of the medication name, description, and synonyms
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/?{urlencode({'search': 'tylenol'})}").json()
    # response_json contains a "results" key with this object as the first result:
    # {
    #   "results": [
    #     {
    #       "description_and_quantity": "Athenol 325 mg tablet",
    #       "med_medication_id": 436095,
    #       "search_rank": 0.082745634,
    #       "search_terms": "Athenol 325 mg tablet|ACETAMINOPHEN ORAL|ACETAMINOPHEN PO|ACETAMINOPHEN VIA FEEDING TUBE|TYLENOL|TYLENOL ORAL|TYLENOL PO|APAP|APAP ORAL|APAP PO|PANADOL|PANADOL ORAL|PANADOL PO|ATHENOL 325 MG TABLET|ACETAMINOPHEN 325 MG TABLET",
    #       "med_medication_description": "Athenol 325 mg tablet",
    #       "clinical_quantities": [
    #         {
    #           "erx_quantity": "1.0000000",
    #           "representative_ndc": "11822317640",
    #           "clinical_quantity_description": "tablet",
    #           "erx_ncpdp_script_quantity_qualifier_code": "C48542",
    #           "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
    #         }
    #       ],
    #       "etc_path_id": [
    #         3645,
    #         574,
    #         578,
    #         577
    #       ],
    #       "etc_path_name": [
    #         "Analgesic, Anti-inflammatory or Antipyretic",
    #         "Analgesic, Anti-inflammatory or Antipyretic - Non-Opioid",
    #         "Analgesic or Antipyretic Non-Opioid and Combinations",
    #         "Analgesic or Antipyretic Non-Opioid"
    #       ],
    #       "rxnorm_rxcui": "313782"
    #     },
    #     ...
    #   ]
    # }
    # search for a specific RxNorm RXCUI
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/?{urlencode({'rxnorm_rxcui': 313782})}").json()
    # response_json contains the same general format as above
    # search for a specific FDB code (med_medication_id)
    med_medication_id = 123456
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/{med_medication_id}/").json()
    # response_json contains the same general format as above
    # search for multiple FDB codes (med_medication_ids)
    med_medication_ids = [123456, 123457]
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/{','.join(med_medication_ids)}/").json()
    # response_json contains the same general format as above
    # look up by NDC
    response_json = ontologies_http.get_json(f"/fdb/ndc-to-medication/76420037215/").json()
    # response_json contains this object:
    # {
    #   "description_and_quantity": "Aphen 325 mg tablet",
    #   "med_medication_id": 572345,
    #   "search_terms": "Aphen 325 mg tablet|APHEN 325 MG TABLET|ACETAMINOPHEN 325 MG TABLET",
    #   "med_medication_description": "Aphen 325 mg tablet",
    #   "clinical_quantities": [
    #     {
    #       "erx_quantity": "1.0000000",
    #       "representative_ndc": "76420037215",
    #       "clinical_quantity_description": "tablet",
    #       "erx_ncpdp_script_quantity_qualifier_code": "C48542",
    #       "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
    #     }
    #   ],
    #   "etc_path_id": [
    #     3645,
    #     574,
    #     578,
    #     577
    #   ],
    #   "etc_path_name": [
    #     "Analgesic, Anti-inflammatory or Antipyretic",
    #     "Analgesic, Anti-inflammatory or Antipyretic - Non-Opioid",
    #     "Analgesic or Antipyretic Non-Opioid and Combinations",
    #     "Analgesic or Antipyretic Non-Opioid"
    #   ],
    #   "rxnorm_rxcui": "313782"
    # }
    # look up multiple NDCs
    response_json = ontologies_http.get_json(f"/fdb/ndcs-to-medications/76420037215,11822317640/").json()
    # response_json is a dictionary where each key is an NDC and each each attribute contains the
    # object formatted as the individual ndc-to-medication search above
    # look up by RxNorm RXCUI
    # response_json is a list containing objects of this type:
    # [
    #   {
    #     "med_medication_id": 156060,
    #     "clinical_formulation_id": {
    #       "clinical_formulation_id": 4489.0,
    #       "hierarchical_specific_therapeutic_class_code": "H3E",
    #       "dosage_form_code_2_character": "TA",
    #       "route_of_administration_code_1_character": "1",
    #       "drug_strength_description": "325 MG",
    #       "therapeutic_class_code_generic": 2.0,
    #       "therapeutic_class_code_standard": 41.0,
    #       "drug_category_code": "0",
    #       "gcn_seqno_level_multi_source_single_source_indicator": "1",
    #       "gender_specific_drug_indicator": "0",
    #       "hierarchical_specific_therapeutic_class_code_sequence_number": 271.0,
    #       "drug_strength_description_60": "325 mg",
    #       "ingredient_list_description": 1866.0,
    #       "interactions": [
    #         1674.0,
    #         27763.0,
    #         29424.0,
    #         30280.0,
    #         30534.0
    #       ]
    #     },
    #     "clinical_quantities": [
    #
    #     ],
    #     "med_routed_dosage_form_medication_id": 12758.0,
    #     "med_strength": "325",
    #     "med_strength_unit_of_measure": "mg",
    #     "med_medication_description": "Dolono 325 mg tablet",
    #     "med_gcn_seqno_assignment_code": "1",
    #     "med_medication_name_source_code": "1",
    #     "med_reference_federal_legend_indicator": "2",
    #     "med_reference_federal_dea_class_code": "0",
    #     "med_reference_multi_source_code": "1",
    #     "med_reference_generic_medication_name_code": "2",
    #     "med_reference_generic_comparative_price_code": "9",
    #     "med_reference_generic_price_spread_code": "9",
    #     "med_reference_innovator_indicator": "0",
    #     "med_reference_generic_therapeutic_equivalence_code": "4",
    #     "med_reference_desi_indicator": "9",
    #     "med_reference_desi2_indicator": "9",
    #     "med_medication_status_code": "3",
    #     "med_generic_medication_identifier": 160401.0
    #   },
    #   ...
    # ]
##  Making requests to the Pharmacy service #
Plugin authors can make requests to our Pharmacy service using the
`PharmacyHttp` client. This client provides a simplified interface for
searching pharmacies and retrieving pharmacy details.
    from canvas_sdk.utils.http import pharmacy_http
Unlike the general Http client, PharmacyHttp only provides two specific
methods for pharmacy operations. Direct HTTP methods (get, post, put, patch)
are not available.
###  Searching for pharmacies #
Search for pharmacies by name, with optional location-based filtering.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`search_term`|  _string_| `true`| The search query for pharmacy name or
organization.  
`latitude`|  _string_| `false`| Latitude coordinate for location-based search.  
`longitude`|  _string_| `false`| Longitude coordinate for location-based
search.  
**Example** :
    from canvas_sdk.utils.http import pharmacy_http
    # Basic search by name
    results = pharmacy_http.search_pharmacies("CVS")
    # Search with location filtering
    results = pharmacy_http.search_pharmacies(
        "pharmacy",
        latitude="40.7128",
        longitude="-74.0060"
    )
    # The results list contains pharmacy objects like:
    # [
    #   {
    #     "id": 123456,
    #     "distance_miles": 0.8,
    #     "ncpdp_id": "1234567",
    #     "store_number": "#1234",
    #     "organization_name": "CVS Pharmacy #1234",
    #     "address_line_1": "123 MAIN ST",
    #     "address_line_2": "",
    #     "city": "New York",
    #     "state": "NY",
    #     "zip_code": "10001",
    #     "phone_primary": "2125551234",
    #     "fax": "2125555678",
    #     "latitude": 40.7128,
    #     "longitude": -74.0060,
    #     "npi": "1234567890",
    #     "specialty_type": "Retail",
    #     ...
    #   },
    #   ...
    # ]
###  Looking up a pharmacy by NCPDP ID #
Retrieve detailed information about a specific pharmacy using its NCPDP
(National Council for Prescription Drug Programs) identifier.
**Parameters** :
Name| Type| Required| Description  
---|---|---|---  
`ncpdp_id`|  _string_| `true`| The NCPDP identifier of the pharmacy.  
**Example** :
    from canvas_sdk.utils.http import pharmacy_http
    # Look up a specific pharmacy
    pharmacy = pharmacy_http.get_pharmacy_by_ncpdp_id("1234567")
    # The response contains detailed pharmacy information:
    # {
    #   "id": 123456,
    #   "ncpdp_id": "1234567",
    #   "store_number": "#1234",
    #   "organization_name": "Example Pharmacy #1234",
    #   "address_line_1": "123 MAIN ST",
    #   "address_line_2": "",
    #   "city": "New York",
    #   "state": "NY",
    #   "zip_code": "10001",
    #   "country": "US",
    #   "standardized_address_line_1": "123 Main St",
    #   "standardized_city": "New York",
    #   "standardized_state": "NY",
    #   "standardized_zip_code": "100010000",
    #   "phone_primary": "2125551234",
    #   "fax": "2125555678",
    #   "email": "",
    #   "active_start_time": "2020-01-01T00:00:00Z",
    #   "active_end_time": "2099-12-31T23:59:59Z",
    #   "service_level": "New~Refill~Change~Cancel~ControlledSubstance",
    #   "npi": "1234567890",
    #   "specialty_type": "Retail",
    #   "dea_number": "",
    #   "organization_type": "Pharmacy",
    #   "organization_id": 1234567,
    #   "latitude": 40.7128,
    #   "longitude": -74.0060,
    #   ...
    # }
###  Response fields #
Both methods return pharmacy objects with the following key fields:
  * `ncpdp_id`: Unique NCPDP identifier for the pharmacy
  * `organization_name`: Name of the pharmacy
  * `address_line_1`, `address_line_2`, `city`, `state`, `zip_code`: Physical address
  * `phone_primary`: Primary phone number
  * `fax`: Fax number
  * `npi`: National Provider Identifier
  * `specialty_type`: Type of pharmacy (e.g., âRetailâ, âMail Orderâ)
  * `service_level`: Services available (e.g., âNew~Refill~Change~Cancel~ControlledSubstanceâ)
  * `latitude`, `longitude`: Geographic coordinates
  * `distance_miles`: Distance from search location (only present in search results when location is provided)
----- END PAGE https://docs.canvasmedical.com/sdk/utils/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/questionnaires/
# Questionnaires
Last updated: 14 Oct 2025
Questionnaires are a structured set of questions intended to guide the
collection of answers from end-users.
##  How to build and install a Questionnaire #
To include a questionnaire in your plugin, add a reference to its YAML
template inside the `questionnaires` section of the `CANVAS_MANIFEST.json`
file.
###  Example Manifest Configuration #
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "example_questionnaire",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [],
            "commands": [],
            "content": [],
            "effects": [],
            "views": [],
            "questionnaires": [
                {
                    "template": "templates/example_questionnaire.yml"
                }
            ]
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
###  Key Properties #
  * **`template`** : The relative path to the YAML file defining the questionnaire.
The questionnaire YAML file should adhere to the JSON schema found
[here](https://raw.githubusercontent.com/canvas-medical/canvas-
plugins/main/schemas/questionnaire.json) that is also listed below.
##  JSON Schema Reference #
###  Questionnaire Settings #
Property| Description| Required  
---|---|---  
`name`| Name of the Questionnaire.| Yes  
`form_type`| Specifies the use case: `QUES` (Questionnaire), `SA` (Structured
Assessment), `EXAM` (Physical Exam), or `ROS` (Review of Systems).| Yes  
`code_system`| The coding system used for the questionnaire, e.g., `SNOMED`,
`LOINC`, `INTERNAL`, `ICD-10`, `CPT`, `CANVAS`.| Yes  
`code`| The assigned code for the questionnaire (e.g., `72109-2`).| Yes  
`can_originate_in_charting`| Specifies if the questionnaire can be initiated
from charting. Values: `TRUE` or `FALSE`.| Yes  
`prologue`| Text displayed at the beginning of the questionnaire to provide
context to the user.| No  
`display_results_in_social_history_section`| Determines if completion
information should be displayed in the Social History (SHX) section. Values:
`TRUE` or `FALSE`. Default: `FALSE`.| No  
`questions`| List of questions in the questionnaire. See below.| Yes  
###  Question Settings #
Property| Description| Required  
---|---|---  
`code_system`| The coding system for the question. Options: `SNOMED`, `LOINC`,
`INTERNAL`, `ICD-10`, `CPT`, `CANVAS`.| Yes  
`code`| The assigned code for the question. Example: `44250-9`. Codes should
be unique within the same questionnaire.| Yes  
`content`| The text displayed when the command is printed.| Yes  
`responses_code_system`| The coding system for responses. Options: `SNOMED`,
`LOINC`, `INTERNAL`, `ICD-10`, `CPT`.| Yes  
`responses_type`| Response type: `SING` (Single Select), `MULT` (Multi
Select), `TXT` (Free Text).| Yes  
`display_result_in_social_history_section`| Determines if the response should
be shown in the Social History (SHX) section. Values: `TRUE` or `FALSE`.
Default: `FALSE`.| No  
`responses`| List of responses for the question. See below.| Yes  
###  Response Settings #
Property| Description| Required  
---|---|---  
`name`| For `SING`/`MULT`, this is the text that will be displayed for each
response. For `TXT`, enter âTXTâ.| Yes  
`code`| The assigned code for the response. Example: `Z759`. No response codes
should be reused within the same question.| Yes  
`value`| For `SING`/`MULT`, leave blank if no scoring is desired. If scoring
is desired, insert the numerical value assigned.| No  
###  Example Questionnaire Definition #
    name: Example Name
    form_type: QUES
    code_system: LOINC
    code: QUES_EXAMPLE_NAME
    can_originate_in_charting: true
    prologue: This is an example of a structured assessment with single select, multiselect, and free text responses.
    questions:
      - content: "This is question #1"
        code_system: CPT
        code: H0005
        responses_code_system: INTERNAL
        responses_type: SING
        display_result_in_social_history_section: true
        responses:
          - name: "Single select response #1"
            code: QUES_EXAMPLE_NAME_Q1_A1
            value: "1"
          - name: "Single select response #2"
            code: QUES_EXAMPLE_NAME_Q1_A2
            value: "0"
          - name: "Single select response #3"
            code: QUES_EXAMPLE_NAME_Q1_A3
            value: "0"
      - content: "This is question #2"
        code_system: INTERNAL
        code: QUES_EXAMPLE_NAME_Q2
        responses_code_system: ICD-10
        responses_type: MULT
        display_result_in_social_history_section: true
        responses:
          - name: "Multi select response #1"
            code: F1910
            value: "0"
          - name: "Multi select response #2"
            code: QUES_EXAMPLE_NAME_Q1_A1
            value: "2"
          - name: "Multi select response #3"
            code: QUES_EXAMPLE_NAME_Q1_A2
            value: "0"
      - content: "This is question #3"
        code_system: INTERNAL
        code: QUES_EXAMPLE_NAME_Q3
        responses_code_system: INTERNAL
        responses_type: TXT
        display_result_in_social_history_section: true
        responses:
          - name: "Free text response"
            code: QUES_EXAMPLE_NAME_Q3_A1
            value: "This is a default pre-populated free text response."
##  Load Questionnaire definition from YAML file #
You can use the `questionnaire_from_yaml` function from
`canvas_sdk.questionnaires` within your plugin to load a questionnaire
definition from a YAML file. The function takes the path to the YAML file as
an argument and returns a dictionary containing the questionnaire definition.
    def questionnaire_from_yaml(questionnaire_name: str, **kwargs):
        """Load a Questionnaire configuration from a YAML file.
        Args:
            questionnaire_name (str): The path to the questionnaire file, relative to the plugin package.
                If the path starts with a forward slash ("/"), it will be stripped during resolution.
            kwargs (Any): Additional keyword arguments.
        Returns:
            QuestionnaireConfig: The loaded Questionnaire configuration.
        Raises:
            FileNotFoundError: If the questionnaire file does not exist within the plugin's directory
                or if the resolved path is invalid.
            PermissionError: If the resolved path is outside the plugin's directory.
            ValidationError: If the questionnaire file does not conform to the JSON schema.
        """
----- END PAGE https://docs.canvasmedical.com/sdk/questionnaires/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/secrets/
# Managing Secrets
Last updated: 27 Aug 2025
Canvas provides a secure key-value secret store that allows your plugins to
access sensitive information (such as API tokens) without hardcoding them into
source files. This guide explains how to define, configure, and access secrets
within your plugins.
###  Declaring Secrets in `CANVAS_MANIFEST.json` #
Secrets are declared in your pluginâs `CANVAS_MANIFEST.json` file under the
top-level `secrets` field. These declared secrets become available for
configuration in the Canvas Admin UI when the plugin is installed.
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "live_notifications",
      "description": "Edit the description in CANVAS_MANIFEST.json",
      "components": {
        "protocols": [
          {
            "class": "live_notifications.protocols.my_protocol:Protocol",
            "description": "A protocol that does xyz..."
          }
        ]
      },
      "secrets": ["API_TOKEN"],
      "tags": {}
    }
###  Configuring Secrets in the Admin UI #
Once your plugin is installed, you can update secret values through the Admin
interface:
Navigation path: `Home` âº `Plugin_IO` âº `Plugins` âº `(your plugin)`
Or, go directly to:
    https://<your_canvas_instance>/admin/plugin_io/plugin/<plugin_id>/change/
On this page, you will find input fields for each secret defined in your
manifest.
![Setting plugin
secrets](/assets/images/sdk/secrets/plugins_secrets_setting.png)
###  Configuring Secrets in the CLI #
You can set secrets either after a plugin is installed or as part of the
install. Secrets must be listed under the secrets field in the pluginâs
`CANVAS_MANIFEST.json`.
Set (or update) secrets on an installed plugin:
    $ canvas config set <plugin_name> API_TOKEN=your_api_token_value
Provide secrets during install:
    $ canvas install <plugin_name> --secret API_TOKEN=your_api_token_value
Set multiple secrets:
    # Pass multiple key=value pairs.
    $ canvas config set <plugin_name> API_TOKEN=abc123 OTHER_KEY=xyz
    # For installs, repeat --secret
    $ canvas install <plugin_name> \
      --secret API_TOKEN=abc123 \
      --secret OTHER_KEY=xyz
###  Accessing Secrets in Your Plugin #
Secrets defined in your manifest and configured in the admin UI are exposed to
your plugin code through the `self.secrets`. This is a Python dictionary
containing all secret values.
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    class Protocol(BaseProtocol):
        def compute(self) -> list[Effect]:
            api_token = self.secrets["API_TOKEN"]
            ...
----- END PAGE https://docs.canvasmedical.com/sdk/secrets/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/your-first-plugin/
# Your First Plugin
Last updated: 12 Sep 2025
Plugins are your tool for customizing the Canvas experience. By using the
modules of the Canvas SDK, you can react to [events](/sdk/events/) emitted
from the EHR, request additional [data](/sdk/data/) if needed, and respond
with [effects](/sdk/effects/) that alter workflows and add or change data in
Canvas. You can also use [utils](/sdk/utils/) to do things like call out to
web services with our provided HTTP client.
##  Video #
The video below showcases a Canvas engineer working through this guide step-
by-step.
##  1\. Install the Canvas CLI #
To install the Canvas CLI, simply `pip install canvas`. Python 3.11 or 3.12 is
required. You can find additional detail on the features of the Canvas CLI
[here](/sdk/canvas_cli/).
##  2\. Configure the Canvas CLI for your instances #
The Canvas CLI uses OAuth credentials to connect to your Canvas instance. If
youâve used our FHIR API, youâll be very familiar with the process for
[registering credentials](/api/customer-authentication/). Register a separate
OAuth application, choosing `confidential` for the Client type, and `client-
credentials` for the Authorization grant type. Redirect URIs can be left
blank, and the Algorithm should be `No OIDC support`. Note the client_id and
client_secret for the next step.
Create a file at the path `~/.canvas/credentials.ini`. Here is what its
contents should look like:
    [buttered-popcorn]
    client_id=butter
    client_secret=salt
    [buttered-popcorn-dev]
    client_id=devbutter
    client_secret=devsalt
    is_default=true
Each section represents credentials for a different Canvas instance. Replace
the section headers with your Canvas subdomains. The example configuration
provided would be valid for instances with URLs `https://buttered-
popcorn.canvasmedical.com` and `https://buttered-popcorn-
dev.canvasmedical.com`.
You can optionally set the `is_default` flag for the instance you wish to be
implied when using the CLI. If no section is set as default, the first one
will be considered default.
##  3\. Initialize a new plugin #
The Canvas CLI gives you a great head start when creating a plugin. Simply run
`canvas init`, and answer the prompt to name your plugin.
    $ canvas init
      [1/1] project_name (My Cool Plugin): Paperwork Eviscerator
    Project created in /Users/andrew/src/canvas-plugins/paperwork-eviscerator
This output shows the location of our freshly generated plugin project.
##  4\. Navigate the structure of a plugin #
Letâs take a look at what was generated for us.
    $ tree paperwork-eviscerator/
    paperwork-eviscerator/
    âââ paperwork_eviscerator
    â    âââ CANVAS_MANIFEST.json
    â    âââ README.md
    â    âââ protocols
    â         âââ __init__.py
    â         âââ my_protocol.py
    âââ pyproject.toml
    âââ tests
        âââ __init__.py
        âââ test_models.py
    5 directories, 9 files
###  CANVAS_MANIFEST.json #
The CANVAS_MANIFEST.json is particularly important. It is used during the
installation of the plugin.
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "paperwork_eviscerator",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [
                {
                    "class": "paperwork_eviscerator.protocols.my_protocol:Protocol",
                    "description": "A protocol that does xyz...",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": ["my_secret_code"],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
The name, plugin version, and description are all surfaced in your Canvas
instance when viewing installed plugins.
Only protocols declared here are invoked by the plugin runner. If they are not
declared, they will be ignored.
Secrets can be declared (though not defined) here. Any secrets declared here
will be initialized on plugin install, and can be set in the plugin listing in
the Settings section of your Canvas instance.
###  README.md #
Share details about the purpose of your plugins and how it works in this
README file.
###  protocols/my_protocol.py #
This file contains the protocol class declared in the manifest file. Weâve
included some sample content and copious comments for inspiration.
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    # Inherit from BaseProtocol to properly get registered for events
    class Protocol(BaseProtocol):
        """
        You should put a helpful description of this protocol's behavior here.
        """
        # Name the event type you wish to run in response to
        RESPONDS_TO = EventType.Name(EventType.ASSESS_COMMAND__CONDITION_SELECTED)
        NARRATIVE_STRING = "I was inserted from my plugin's protocol."
        def compute(self):
            """
            This method gets called when an event of the type RESPONDS_TO is fired.
            """
            # This class is initialized with several pieces of information you can
            # access.
            #
            # `self.event` is the event object that caused this method to be
            # called.
            #
            # `self.target` is an identifier for the object that is the subject of
            # the event. In this case, it would be the identifier of the assess
            # command. If this was a patient create event, it would be the
            # identifier of the patient. If this was a task update event, it would
            # be the identifier of the task. Etc, etc.
            #
            # `self.context` is a python dictionary of additional data that was
            # given with the event. The information given here depends on the
            # event type.
            #
            # `self.secrets` is a python dictionary of the secrets you defined in
            # your CANVAS_MANIFEST.json and set values for in the uploaded
            # plugin's configuration page: <emr_base_url>/admin/plugin_io/plugin/<plugin_id>/change/
            # Example: self.secrets['WEBHOOK_URL']
            # You can log things and see them using the Canvas CLI's log streaming
            # function.
            log.info(self.NARRATIVE_STRING)
            # Craft a payload to be returned with the effect(s).
            payload = {
                "note": {"uuid": self.context["note"]["uuid"]},
                "data": {"narrative": self.NARRATIVE_STRING},
            }
            # Return zero, one, or many effects.
            # Example:
            # return [Effect(type=EffectType.LOG, payload=json.dumps(payload))]
            return []
##  5\. Listen for an Event #
Set the `RESPONDS_TO` value to the [Event Type](/sdk/events/#event-types)
youâre interested in.
##  6\. Return an Effect #
Form an [Effect](/sdk/effects/#effect-types) to return to your Canvas
instance.
##  7\. Deploy and use your plugin #
When your plugin is just the way youâd like it, deploying is simple.
Navigate to the root of your plugin project (i.e. `paperwork-eviscerator/`)
and run `canvas install <path/to/plugin_package>` (i.e. `canvas install
paperwork_eviscerator`) and your plugin will be packaged, uploaded, installed,
and enabled. As you make changes to your plugin, run the same command to
update the code of the installed plugin.
##  8\. Tail the logs #
To view logs and to surface any errors with your plugin, run `canvas logs
--host buttered-popcorn-dev` (replace with your Canvas instance name). This
will tail the logs for all plugins installed on that instance.
----- END PAGE https://docs.canvasmedical.com/guides/your-first-plugin/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/custom-landing-page/
# Building a Custom Portal Landing Page
Last updated: 24 Sep 2025
This guide provides examples of how to leverage patient data to personalize
the portal landing page, and explains how to integrate the ready-made widgets
provided by Canvas.
This guide assumes pre-existing knowledge of the Canvas SDK. If you're
starting from scratch, you may want to read and implement [Your First
Plugin](/guides/your-first-plugin/) before working through this exercise.
##  What Are Widgets in the Patient Portal? #
[Widgets](/sdk/layout-effect/#portal-landing-page-widgets) in the patient
portal are interactive components that enhance the user experience by
providing quick access to information and functionalities. They can display
key details like upcoming appointments. Widgets can be fully customized with
unique content or leverage ready-made componentsâsuch as Appointments and
Messaging provided by Canvas to ensure consistency and ease of use. These
widgets are organized on the landing page using a grid layout, which supports
various sizes to optimize the visual presentation and responsiveness across
different devices.
##  How to add a Widget? #
A widget can be added by listening to the
`PATIENT_PORTAL__WIDGET_CONFIGURATION` event and returning one or several
`PortalWidget`
###  Step 1: Initialize a plugin #
The Canvas CLI gives you a great head start when creating a plugin. Simply run
      canvas init
Then, follow the prompts to name and configure your new plugin project.
###  Step 2: Update you protocol #
Modify your protocol to handle the widget configuration event. For example:
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            widget = PortalWidget(
              content="Hello World",
              size=PortalWidget.Size.COMPACT,
              priority=10
            )
            return [widget.apply()]
This code listens for the `PATIENT_PORTAL__WIDGET_CONFIGURATION` event and,
when triggered, creates a new widget with a simple âHello Worldâ message,
a compact size, and a priority of 10.
##  Patient medication widget #
This widget will show the last medication and CTA to request a refill.
So letâs update the example above to:
  * Fetch the patientâs medication.
  * Leverage [HTML templating](/sdk/layout-effect/#custom-html-and-django-templates) to display the necessary information
###  Step 1: Fetch patient medication #
Since the event includes the patient object, you can easily access all the
necessary data. Add the following snippet to your compute method to retrieve
the patientâs details:
    patient = Patient.objects.get(id=self.target)
    last_medication = patient.medications.last()
###  Step 2: Prepare HTML template #
Create a `templates` folder inside your pluginâs folder:
      mkdir templates
Add the HTML file:
      touch medication_widget.html
And add the following HTML:
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body, html {
          height: 100%;
          width: 100%;
          margin: 0;
          font-family: "Roboto","Helvetica","Arial",sans-serif;
          font-size: 16px;
        }
      </style>
    </head>
    <body>
    </body>
    </html>
###  Step 3: Design your widget #
Developers are responsible for providing all the necessary CSS to style their
widget. The widget does not include default styles, so you should include
custom CSSâeither inline or via an external stylesheetâto define the
layout, typography, colors, spacing, and interactive elements.
While you can design your widget in any way that suits your needs, for this
example weâll create one featuring a header and a card component. The card
will display the medication name, the prescription date, and a clear call-to-
action (CTA) button that redirects the patient to the messaging page to
request a refill.
####  Header #
A light gray background color and a blue text to ensure it matches the patient
portal aesthetic.
    <style>
      .header {
          padding: 8px;
          background: #E5E5E5;
          color: #2185D0;
          text-align: left;
          margin: 0;
          font-weight: 500;
          font-size: 18px;
          line-height: 1.6;
        }
    </style>
    <body>
        <div class="header">My Health</div>
    </body>
####  Card Component #
We will add template variables for the medication name and start date,
allowing these values to be dynamically updated in the plugin.
    <body>
      <div class="widget">
        <div class="medication-info">
          <span class="material-icons">medication</span>
          <span>{{name}}</span>
        </div>
        <p style="padding: 0 12px">This medication was prescribed on {{start_date}}. Do you need a refill?</p>
        <button onclick="onClick()">Ask for a refill</button>
      </div>
      <script>
        function onClick() {
          window.top.location.href = "http://localhost:8000/app/messaging"
        }
      </script>
    </body>
Letâs dive in and add some styles to the card.
Our `widget` class ensures that all elements are both vertically and
horizontally centered, creating a sleek card design with rounded borders and a
subtle shadow for a modern, elevated look.
    .widget {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 98%;
      height: 80%;
      border-radius: 4px;
      box-shadow: 0 2px 1px -1px rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 1px 3px 0 rgba(0, 0, 0, 0.12);
      background-color: #f9f9f9;
      text-align: center;
      margin: 4px auto auto;
    }
Our medication info section will feature a Material UI icon next to the
medication name, providing a clear and modern visual representation consistent
with the portalâs design aesthetic.
    .medication-info {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      padding: 0 8px;
      font-size: 14px;
    }
    .material-icons {
      font-size: 50px;
    }
And finally, we style the CTA button to mimic a Material UI button, ensuring
it aligns perfectly with the portalâs overall design aesthetic.
    button {
      margin-top: 16px;
      background-color: #1976d2;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 16px 16px;
      font-size: 14px;
      min-width: 64px;
      text-transform: uppercase;
      box-shadow: 0 3px 1px -2px rgba(0,0,0,0.2),
                  0 2px 2px 0 rgba(0,0,0,0.14),
                  0 1px 5px 0 rgba(0,0,0,0.12);
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #115293;
    }
###  Step 4: Tying everything together #
Update your pluginâs `compute` method to pass the desired values for
medication name and start date using `render_to_string` function
    medication_info = {
        "start_date": last_medication.start_date.strftime("%B %d, %Y"),
        "name": last_medication.codings.first().display
    }
    widget = PortalWidget(content=render_to_string("templates/medication_widget.html", medication_info), size=PortalWidget.Size.COMPACT, priority=10)
![medication widget](/assets/images/sdk/widgets/patient_medication_widget.png)
###  Full Example #
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data import Patient
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            patient = Patient.objects.get(id=self.target)
            last_medication = patient.medications.last()
            medication_info = {
                "start_date": last_medication.start_date.strftime("%B %d, %Y"),
                "name": last_medication.codings.first().display
            }
            medication_widget = PortalWidget(
              content=render_to_string("templates/medication_widget.html", medication_info),
              size=PortalWidget.Size.COMPACT,
              priority=10
            )
            return [medication_widget.apply()]
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      <style>
        body, html {
          height: 100%;
          width: 100%;
          margin: 0;
          font-family: "Roboto","Helvetica","Arial",sans-serif;
          font-size: 16px;
        }
        .widget {
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          width: 98%;
          height: 80%;
          border-radius: 4px;
          box-shadow: 0 2px 1px -1px rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 1px 3px 0 rgba(0, 0, 0, 0.12);
          background-color: #f9f9f9;
          text-align: center;
          margin: 4px auto auto;
        }
        .header {
          padding: 8px;
          background: #E5E5E5;
          color: #2185D0;
          text-align: left;
          margin: 0;
          font-weight: 500;
          font-size: 18px;
          line-height: 1.6;
        }
        .medication-info {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 15px;
          padding: 0 8px;
          font-size: 14px;
        }
        .material-icons {
          font-size: 50px;
        }
        button {
          margin-top: 16px;
          background-color: #1976d2;
          color: #fff;
          border: none;
          border-radius: 4px;
          padding: 16px 16px;
          font-size: 14px;
          min-width: 64px;
          text-transform: uppercase;
          box-shadow: 0 3px 1px -2px rgba(0,0,0,0.2),
                      0 2px 2px 0 rgba(0,0,0,0.14),
                      0 1px 5px 0 rgba(0,0,0,0.12);
          cursor: pointer;
          transition: background-color 0.3s ease;
        }
        button:hover {
          background-color: #115293;
        }
      </style>
    </head>
    <body>
      <div class="header">My Health</div>
      <div class="widget">
        <div class="medication-info">
          <span class="material-icons">medication</span>
          <span>{{name}}</span>
        </div>
        <p style="padding: 0 12px">This medication was prescribed on {{start_date}}. Do you need a refill?</p>
        <button onclick="onClick()">Ask for a refill</button>
      </div>
      <script>
        function onClick() {
          window.top.location.href = "http://localhost:8000/app/messaging"
        }
      </script>
    </body>
    </html>
##  Upcoming appointments Widget provided by Canvas #
This is one of the ready-made widgets provided by Canvas that you can add to
your patient portal. It will show upcoming appointments.
###  Step 1: Add a new protocol to your plugin #
Create a new protocol in your plugin with the following content:
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class UpcomingAppointmentWidget(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            widget = PortalWidget(component=PortalWidget.Component.APPOINTMENTS, priority=25)
            return [widget.apply()]
![medication
widget](/assets/images/sdk/widgets/upcoming_appointments_widget.png)
----- END PAGE https://docs.canvasmedical.com/guides/custom-landing-page/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/creating-webhooks-with-the-canvas-sdk/
# Creating Webhooks With the Canvas SDK
Last updated: 14 Aug 2025
Webhooks are user-defined callbacks that make a request to an API. You may
want to create a webhook to notify a system you control that some event has
occurred in Canvas. This guide shows how to create a webhook that sends an API
request containing the ID of a Task upon its creation.
This guide assumes pre-existing knowledge of the Canvas SDK. If you're
starting from scratch, you may want to read and implement [Your First
Plugin](/guides/your-first-plugin/) before working through this exercise.
##  Initialize a new plugin #
The Canvas CLI gives you a great head start when creating a plugin. Simply run
`canvas init`, and answer the prompt to name your plugin.
    $ canvas init
      [1/1] project_name (My Cool Plugin): Task Webhook
    Project created in /Users/andrew/src/canvas-plugins/task-webhook
This output shows the location of our freshly generated plugin.
##  Edit the plugin code #
The default content of this file shows you the information you have available
to you in the comments. Iâve stripped it down to almost nothing so we can
layer in the functionality step by step.
###  Log a message when a task is created. #
The code below listens for the `TASK_CREATED` event and logs the string âA
Task was created!â.
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, log a message
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Log a message as tasks are created.
            """
            log.info("A Task was created!")
            return []
You can see this log output by first streaming logs with `canvas logs` and
then creating a task. You can create this task with Canvas Chat, a Task
Command, or our [FHIR Task Create endpoint](/api/task/#create).
After youâve [installed your plugin](/sdk/canvas_cli/#canvas-install) and
created a task, you should see this in your log stream:
    INFO 2024-09-26 17:04:08,396 Starting server, listening on port 50051
    INFO 2024-09-26 17:04:08,396 Loading custom-plugins/task_webhook
    INFO 2024-09-26 17:04:08,396 Loading plugin 'task_webhook:task_webhook.protocols.my_protocol:Protocol'
    INFO 2024-09-26 17:04:24,410 A Task was created!
    INFO 2024-09-26 17:04:24,410 task_webhook:task_webhook.protocols.my_protocol:Protocol.compute() completed (0 ms)
    INFO 2024-09-26 17:04:24,411 Responded to Event TASK_CREATED (1 ms)
Awesome! But weâre not here to log, we need to make an API request. To do
that, we need to use the HTTP client found in the Canvas SDKâs [Utils
module](/sdk/utils/)
###  Make an HTTP request when a Task is created #
We can use <https://webhook.site/> for a quick way to test our webhook and see
the requests it receives. Here is the updated code that uses the HTTP client
to make the request:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, hit a webhook
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = "https://webhook.site/ee7aed78-b652-4d9e-b858-04465c409d15"
            payload = {
                "message": "A Task was created!"
            }
            http = Http()
            response = http.post(url, json=payload)
            if response.ok:
                log.info("Successfully notified API of task creation!")
            else:
                log.info("Notification unsuccessful. =[")
            return []
After youâve [installed your updated plugin](/sdk/canvas_cli/#canvas-
install) and created a task, you should see this in your log stream:
    INFO 2024-09-26 17:18:23,206 Loading custom-plugins/task_webhook
    INFO 2024-09-26 17:18:23,207 Reloading plugin 'task_webhook:task_webhook.protocols.my_protocol:Protocol'
    INFO 2024-09-26 17:18:33,850 Successfully notified API of task creation!
    INFO 2024-09-26 17:18:33,851 task_webhook:task_webhook.protocols.my_protocol:Protocol.compute() completed (693 ms)
    INFO 2024-09-26 17:18:33,851 Responded to Event TASK_CREATED (696 ms)
This log output is a great reminder for me to mention that making HTTP
requests to external servers will slow plugin execution while it waits on the
external server to respond. Itâs a good idea to make sure the servers
youâre hitting have a sufficiently quick response time.
Checking in on our webhook.site logs shows it received our request! ![Log of
web
request](/assets/images/webhook-guide/webhook-guide-first-request.png)
Awesome, but you arenât sending these requests to a server that allows
unauthenticated requests! And this request doesnât even tell you anything
about the task itâs notifying you about. This isnât useful at all!
Letâs do another iteration, this time using the information provided along
with the event so that we can send a usable message, securely. Weâre
specifically going to incorporate the eventâs `target` and `secrets`.
###  Make an authenticated HTTP request that includes the newly created
Taskâs ID #
Within your `Protocol` class, you have access to `self.target`, which
represents the ID of the subject of the event. In our case, it will be the
Taskâs ID. This is the same ID used in the [FHIR Task
endpoints](/api/task/), so you can use it to make FHIR API requests.
You also have access to `self.secrets`, which is a python dictionary
containing the key-value pairs from your plugins configuration page. You
declare the keys in your `CANVAS_MANIFEST.json`, and can then set the values
after the plugin is installed.
Weâll set two secrets, one for the unique id of the webhook, and one for an
auth token. Hereâs what the manifest file looks like with secrets declared:
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "task_webhook",
        "description": "Webhooks for task creation",
        "components": {
            "protocols": [
                {
                    "class": "task_webhook.protocols.my_protocol:Protocol",
                    "description": "Hit an API when a task is created",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
           ]
        },
        "secrets": ["WEBHOOK_ID", "AUTH_TOKEN"],
        "tags": {},
        "license": "",
        "readme": "./README.md"
    }
The line `"secrets": ["WEBHOOK_ID", "AUTH_TOKEN"],` declares two secrets,
`WEBHOOK_ID` and `AUTH_TOKEN`. After we update the plugin, we can set values
for these in the plugin configuration page. This allows for different values
to be used across different installations.
Hereâs how that configuration looks:
![Plugin secrets
configuration](/assets/images/webhook-guide/webhook-guide-secrets.png)
With those values set, we can use them in our code:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, hit a webhook
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = f"https://webhook.site/{self.secrets['WEBHOOK_ID']}"
            headers = {
                "Authorization": f"Bearer {self.secrets['AUTH_TOKEN']}"
            }
            payload = {
                "message": "A Task was created!",
                "resource_id": self.target
            }
            http = Http()
            response = http.post(url, json=payload, headers=headers)
            if response.ok:
                log.info("Successfully notified API of task creation!")
            else:
                log.info("Notification unsuccessful. =[")
            return []
And checking once more on our webhook.site logs shows it received our updated
request, including our `AUTH_TOKEN` value and the created taskâs ID.
![Log of web
request](/assets/images/webhook-guide/webhook-guide-second-request.png)
##  Listening for multiple events #
A single plugin handler can listen for multiple event types. The event type
will be available in `self.event.type`, which will contain a member of the
`EventType` enum. The [full list of events is available](/sdk/events/#event-
types). Here is a short example that listens for two different events:
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created or updated, hit a webhook
        """
        RESPONDS_TO = [
            EventType.Name(EventType.TASK_CREATED),
            EventType.Name(EventType.TASK_UPDATED),
        ]
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = f"https://webhook.site/{self.secrets['WEBHOOK_ID']}"
            headers = {"Authorization": f"Bearer {self.secrets['AUTH_TOKEN']}"}
            # self.event.type is a member of the EventType enum corresponding to
            # one of the event types in the plugin's RESPONDS_TO attribute
            verb = 'created' if self.event.type == EventType.TASK_CREATED else 'updated'
            payload = {
                "message": f"A Task was {verb}!",
                "resource_id": self.target,
            }
            http = Http()
            response = http.post(url, json=payload, headers=headers)
            # You can also get the name of the event as as string using EventType.Name()
            event_name = EventType.Name(self.event.type)
            if response.ok:
                log.info(f"Successfully notified API of {event_name}")
            else:
                log.info(f"Notification of {event_name} unsuccessful. =[")
            return []
Alternatively, you could include several classes, each resposible for some
specific request type. When including several classes in one plugin, they all
have access to the same secrets dictionary, you just need to declare each
class in the manifest file.
##  Conclusion #
I hope you found this helpful. Happy coding, we canât wait to see what you
build!
----- END PAGE https://docs.canvasmedical.com/guides/creating-webhooks-with-the-canvas-sdk/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/customize-search-results/
# Customize Search Results
Last updated: 17 May 2024
In a typical visit note, itâs common for clinicians to make 20, 30, even 50
or more selections from structured terminologies with commands like Diagnose,
Prescribe, Family History, and many more. You can help clinicians make faster
and more accurate selections with Canvas plugins. Write simple plugin code to
apply custom filtering, sorting, and search result annotations in real time
with near zero latency.
This search modification can help clinicians:
  * Choose the most appropriate medication that is also covered by insurance
  * Prioritize in-network specialists
  * Consider appropriate risk adjustment factors when selecting diagnosis codes
Canvas supports modifying search results in [all refactored
commands](/product-updates/commands-module/#progress).
First, weâll show you a complete example of customizing the search results
for choosing a medication in a Medication Statement command, then weâll
break it down piece by piece so you can adapt the example to your own needs.
##  The Complete Example #
This example checks for the presence of a particular medication in the search
results and, if present, annotates that medication option with additional
information and adjusts its position to the top of the search results.
For reference, hereâs the difference in behavior with the plugin inactive vs
active:
**Inactive (normal behavior):**
![With the plugin inactive, the results are
unaltered](/assets/images/customize-search-results/plugin-inactive.png)
**Active (modified behavior):**
![With the plugin active, the preferred result is listed first, and with
additional context](/assets/images/customize-search-results/plugin-active.png)
Hereâs the code in its entirety:
    import json
    from canvas_sdk.events import EventType
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            post_processed_results = []
            for result in results:
                should_float_to_top = False
                for coding in result.get("extra", {}).get("coding", []):
                    if (
                        coding.get("code") == 554704
                        and coding.get("system") == "http://www.fdbhealth.com/"
                    ):
                        if result.get("annotations") is None:
                            result["annotations"] = []
                        result["annotations"].append("Kirkland Signature")
                        should_float_to_top = True
                if should_float_to_top:
                    post_processed_results.insert(0, result)
                else:
                    post_processed_results.append(result)
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
##  Anatomy of the Example #
This code can be broken down into the following sections:
  * Register interest in the correct search event
  * Decide whether to make any changes
  * Loop through the results, making modifications as appropriate
  * Return the modified results as a properly typed effect
###  Register interest in the correct search event #
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
The class inherits from `BaseProtocol`, which clues the plugin-runner into
registering your code as interested in the event or events listed in the
`RESPONDS_TO` class constant. We only specify one event here,
`MEDICATION_STATEMENT__MEDICATION__POST_SEARCH`, but you could make this value
a list to fire on multiple events. The event weâve chosen to listen for can
be read backwards to understand when it fires. This event is emitted after
(â _post_ â) the normal _search_ results are found for the _medication_
autocomplete field of the _medication statement_ command. This event comes
with a context that contains the search results that would be served to the
user if there were no modifications.
###  Decide whether to make any changes #
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
If the value of the results `is None`, we bail out early. There is a subtle
difference between results of `None` and an empty result set (`[]`). Results
being `None` means âmake no changes, present the results without
modificationâ, whereas an empty result set means âpresent no options to
the userâ.
###  Loop through the results, making modifications as appropriate #
            post_processed_results = []
            for result in results:
                should_float_to_top = False
                for coding in result.get("extra", {}).get("coding", []):
                    if (
                        coding.get("code") == 554704
                        and coding.get("system") == "http://www.fdbhealth.com/"
                    ):
                        if result.get("annotations") is None:
                            result["annotations"] = []
                        result["annotations"].append("Kirkland Signature")
                        should_float_to_top = True
                if should_float_to_top:
                    post_processed_results.insert(0, result)
                else:
                    post_processed_results.append(result)
In this block of code, we create a new list named `post_processed_results` to
hold our modified result set. We then loop through each result in the
unmodified results set, and check to see if the current medication result
matches our chosen criteria (FDB code 554704).
If it does match, we first check to see if any annotations already exist and
initialize the annotations list if needed. We then append our chosen
annotation to the resultâs annotation list and flag it as needing to be
floated to the top (we had defaulted it to not be floated earlier on).
Finally, we add the result to our parallel list, `post_processed_results`. If
it matched and was marked as being floated to the top, we insert it into the
list at position 0. If it did not match, we append the result to the end of
the list.
###  Return the modified results as a properly typed effect #
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
With our list of modified results in place, we just need to return an effect
of type `AUTOCOMPLETE_SEARCH_RESULTS` with our modified list as the payload.
The dropdown of options presented to the user now reflects our modifications!
##  Understanding Search Result Data Structures #
The search results in this example follow the MedicationSearchResult
structure. Each result contains fields like `text`, `disabled`, `description`,
`annotations`, `extra`, and `value` that provide detailed information about
the medication option.
For complete details about medication search result data contracts and other
search result structures, see the [Search Result Data
Structures](/sdk/events/#search-result-data-structures) section in the Events
documentation.
##  Accessing User Context #
All command-related PRE_SEARCH and POST_SEARCH events include information
about the user performing the search in the event context. This includes
search events for fields like prescriber, medication, diagnosis, pharmacy, and
many others across various commands.
You can access the userâs staff key from the context:
    def compute(self):
        user_context = self.context.get("user", {})
        staff_key = user_context.get("staff")
        # Use the staff key to customize search results
        # based on the user's role, preferences, or permissions
This can be useful for customizing search results based on:
  * User-specific preferences or settings
  * Role-based filtering (e.g., showing different prescriber options based on the userâs specialty)
  * Permission-based access control
  * Userâs organization or practice location
##  Watch Me Build It #
----- END PAGE https://docs.canvasmedical.com/guides/customize-search-results/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/embedding-a-smart-on-fhir-application/
# Embedding a SMART app into Canvas
Last updated: 24 Jul 2025
Canvasâ FHIR API supports the SMART launch sequence, and the Canvas SDK
allows you to embed html content within the Canvas EMR. The combination of
these capabilities is a frictionless experience when embedding a SMART app
into Canvas. This example will show you how to register a SMART appâs
credentials and create an application to launch it from within a patientâs
chart.
##  In this guide you will learn how to: #
  * Configure credentials for a public OAuth application.
  * Create an application to initiate the SMART launch sequence.
  * Use application launch context to help form the SMART launch URL parameters.
##  What is a SMART app? #
SMART on FHIR applications adhere to a standards-based approach to
authentication, authorization, and data access with the goal of being portable
across EMR installations and vendors. Because SMART apps limit themselves to
standards based data, the logic can be agnostic to the EMR it is running
against. Vendor to vendor, site to site, FHIR is FHIR, thatâs how it works,
right?
##  Where can I get a SMART app? #
Weâve provided an example SMART app [here](https://github.com/canvas-
medical/example-smart-on-fhir-app). You can fork it and customize, or just use
ours as-is. We use GitHub pages to host it at `https://canvas-
medical.github.io/example-smart-on-fhir-app/`. Please ensure the client id
[listed in `launch.html`](https://github.com/canvas-medical/example-smart-on-
fhir-app/blob/205b14ed8d4f4d9c57fd11a26f9a22c800f38c29/launch.html#L15)
matches the client id for the credentials you configure in the next step.
##  Configuring credentials #
The first step to embedding a SMART application is to configure OAuth
credentials for it to use. Navigate to
`<YOUR_CANVAS_URL>/auth/applications/register/` and choose `Public` client
type, `Authorization code` grant type, the `RSA` algorithm, and set the
redirect uri for your SMART application.
![OAuth Configuration](/assets/images/guides/embedding-a-smart-
app/SMART_OAuth.png)
##  Creating an application #
We encourage you to read our more comprehensive guide on [creating
applications via the Canvas SDK](/guides/your-first-application/), but we can
provide an abridged version here.
Using the [Canvas CLI](/sdk/canvas_cli/), create an application from a
template using `canvas init application`. After providing a name, the Canvas
CLI will create a directory with your application inside it.
    dev@canvas:plugins$ canvas init application
      [1/1] project_name (My Cool Application): My Smart App
    Project created in /Users/dev/src/plugins/my_smart_app
    dev@canvas:plugins$ tree my_smart_app/
    my_smart_app/
    âââ CANVAS_MANIFEST.json
    âââ README.md
    âââ applications
    âÂ Â  âââ __init__.py
    âÂ Â  âââ my_application.py
    âââ assets
        âââ python-logo.png
    3 directories, 5 files
There are two files weâll want to visit for changes: `CANVAS_MANIFEST.json`
and `applications/my_application.py`.
###  Configuring the manifest file #
In order to set the same-origin policy for the iframe our SMART app will be
embedded into, we need to make sure the url where the SMART app is hosted is
listed in the `url_permissions` section of the manifest, and the
`ALLOW_SAME_ORIGIN` permission is requested.
        "url_permissions": [
            {
                "url": "https://canvas-medical.github.io",
                "permissions": ["ALLOW_SAME_ORIGIN"]
            }
        ],
We also want to change the application scope from the default âglobalâ
setting to âpatient specificâ:
        "components": {
            "applications": [
                {
                    ...
                    "scope": "patient_specific",
                }
            ],
        },
###  Setting the SMART launch URL #
The SMART authorization dance begins with the SMART appâs launch URL. The
parameters present on this URL set the wheels in motion. The launch URL is
loaded in an iframe, and javascript immediately reads the `iss` param in order
to probe the FHIR APIâs CapabilityStatement for the EMRâs Authorize
endpoint, which the iframe is then redirected to, with its own load of URL
parameters in tow.
We can set this initial URL and launch params in the `on_open` method found in
`applications/my_application.py`. This is the code that is invoked when a user
clicks the applicationâs launch icon.
    import json
    from base64 import b64encode
    from urllib.parse import urlencode
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class MyApplication(Application):
        def on_open(self) -> Effect:
            launch_context = {
                "patient": self.context["patient"]["id"]
            }
            encoded_launch_context = b64encode(json.dumps(launch_context).encode()).decode()
            launch_params = {
                "iss": f"https://fumage-{self.environment['CUSTOMER_IDENTIFIER']}.canvasmedical.com",
                "launch": encoded_launch_context
            }
            encoded_launch_params = urlencode(launch_params)
            return LaunchModalEffect(
                url=f"https://canvas-medical.github.io/example-smart-on-fhir-app/launch.html?{encoded_launch_params}",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
Thatâs all the plugin work we need to do in order to create a launcher for
the SMART application. Install the plugin into your Canvas instance, navigate
to a patientâs chart, and choose your application from the launcher.
##  Executing the launch sequence #
Upon launching your application, the SMART app will need the user to sign off
on the access token it will receive to access the FHIR API on behalf of the
logged in user.
![Authorize the token](/assets/images/guides/embedding-a-smart-
app/SMART_Authorize.png)
The page youâre seeing in the image is served by Canvas. This page is asking
for the logged in userâs consent to sending the SMART app a token which can
access the FHIR API on the userâs behalf. Clicking `Authorize` will redirect
the iframe to the URL specified in the OAuth clientâs configuration with
several params, most critically the API access token.
With the SMART app now in possession of a valid API access token, the
application can function with access to all the data it is authorized to
retrieve from the FHIR API. The example SMART app weâve been working with
simply shows the raw FHIR records retrieved for the patient.
![SMART app in action](/assets/images/guides/embedding-a-smart-
app/SMART_App.png)
If you want to update the example SMART app to authorize additional data
access from the FHIR API, youâll need to add those endpoints to the `scope`
values in [launch.html](https://github.com/canvas-medical/example-smart-on-
fhir-app/blob/main/launch.html), or wherever your authorize method is called:
        <script>
            FHIR.oauth2.authorize({
                ...
                // The scopes that you request from the EHR. In this case we want to:
                scope: "patient/Patient.read patient/MedicationStatement.read patient/Goal.read patient/DocumentReference.read launch offline_access openid fhirUser",
                ...
            });
        </script>
For a more comprehensive list of available FHIR scopes, visit the [API
docs](https://docs.canvasmedical.com/api/).
##  A more flexible alternative #
If youâre looking to provide your users a more native experience without
requiring the intricate authorization dance SMART prescribes, youâre already
pretty close just by going through the exercise above! While we created an
embedded iframe of remote-hosted content, the Canvas SDK also allows you to
[define HTTP endpoints](/sdk/handlers-simple-api-http/) which can also be the
targets of the iframes. This allows your plugins to host [dynamically rendered
HTML](/sdk/layout-effect/#custom-html-and-django-templates), CSS, Javascript,
and more, with no external hosting required! You can take advantage of the
built-in [session authentication](/sdk/handlers-simple-api-http/#session) for
access control (no separate logins or authorizations for your users), and you
have direct access to the EMR database through the Canvas SDKâs [data
module](/sdk/data/). [Caching](/sdk/caching/) and [websockets](/sdk/handlers-
simple-api-websocket/) help you provide modern experiences, while the [effects
module](/sdk/effects/) ensures you can write new data back into Canvas as
needed.
The Canvas SDK allows you to deploy full web applications within the EMR,
colocating your code with the data it needs to function, and without requiring
any additional infrastructure. Want to explore further? Join us in our
[developer community](https://github.com/canvas-medical/canvas-
plugins/discussions) and say hello!
----- END PAGE https://docs.canvasmedical.com/guides/embedding-a-smart-on-fhir-application/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/scribe-ai-parser/
# Creating, Implementing, and Extending an AI Scribe Parser
Last updated: 24 Sep 2025
The [AI Scribe Parser Plugin](https://github.com/Medical-Software-
Foundation/canvas/tree/main/extensions/ai-scribe) was designed to help
streamline clinical documentation by parsing structured transcripts into
commands. With healthcare providers increasingly adopting AI-driven solutions,
this guide provides developers with the insights and instructions needed to
integrate and extend our example plugin to meet diverse documentation needs.
In this guide, youâll learn how to:
  * Intercept [`CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE`](/sdk/events/#clipboard-command).
  * Use `ScribeParser` (or custom parsers) to process transcripts.
  * Generate commands for each section.
  * Add or replace section parsers for custom sections.
  * Implement a fully custom parser for alternate formats.
##  Understanding the Transcript Parsing Flow. #
The workflow is triggered by pasting a transcript into a note. Doing so will
automatically insert the content in the form of a clipboard command. We can
then respond to that event and transform the content into the appropriate
commands.
###  Input Transcript Example #
Our example transcript includes many structured sections. The sections listed
below were flagged as being formatted in a way that makes them easy to
translate into Canvas commands.
  * Chief complaint
  * History of present illness
  * Past medical history
  * Vitals
  * Plan
Each section contains specific information that can be parsed. For example:
  * The **Vitals** section includes data like weight, heart rate, and blood pressure, which can be converted into a `VitalsCommand`.
  * The **Assessment** section provides diagnoses and clinical impressions, which can be mapped to an `AssessCommand`.
**Complete Example**
    Chief complaint
    - Concern about potential diabetes
    - Hypertension
    History of present illness
    - Patient named Ken, age and gender not mentioned
    - Has sleep apnea, uses CPAP machine
    - Has hyperlipidemia
    - Has hypertension, on medication but doesn't remember the names
    - No other symptoms or issues reported
    - No shortness of breath or pain reported
    Past medical history
    - Sleep apnea
    - Hyperlipidemia
    - Hypertension
    Family history
    No known family history of hypertension
    Social history
    Travels a lot
    Current medications
    Medication for hypertension, names not provided
    Vitals
    - Weight: 244 lbs
    - Height: 5'10"
    - Heart rate: 80
    - Oxygen saturation: 94%
    - Blood pressure: 167/106
    Lab results
    A1C: 5.2 (Normal range, neither prediabetic nor diabetic)
    Physical exam
    CARDIOVASCULAR: Heart sounds good.
    LUNGS: Lungs sound good.
    Assessment
    - Hypertension, not well controlled
    - Sleep apnea, using CPAP machine
    - Hyperlipidemia
    - Elevated BMI, potential for weight loss intervention
    - No diabetes or prediabetes
    Plan
    - Recommendation for weight loss services
    - Recommendation to address hypertension, either at this clinic or with primary care
    - Potential adjustment of hypertension medication
    - Offered subscription program with unlimited office visits and access to a nutritionist
    - Potential telemedicine consultations due to patient's frequent travel
    Appointments
    No specific appointment made, patient to contact clinic after discussing with wife
    ICD-10 codes (3)
    - Sleep apnea, unspecified [G47.30]
    - Hyperlipidemia, unspecified [E78.5]
    - Essential (primary) hypertension [I10]
###  AI Scribe Plugin Architecture #
Once the content is pasted in, the plugin does the rest. Hereâs how.
####  1\. Protocol Class #
The `Protocol` class intercepts events and processes the transcript using a
parser.
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    class ScribeParser: ...  # explained in section 2 below, "ScribeParser"
    class Protocol(BaseProtocol):
        """A Plugin for interpreting transcripts."""
        RESPONDS_TO = EventType.Name(EventType.CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE)
        def compute(self) -> list[Effect]:
            """Parse the transcript and generate effects to originate commands."""
            transcript = self.context["fields"]["text"]
            parser = ScribeParser()
            parsed_transcript = parser.parse(transcript, self.context)
            note_uuid = self.context["note"]["uuid"]
            effects = []
            for commands in parsed_transcript.values():
                for command in commands:
                    command.note_uuid = note_uuid
                    effects.append(command.originate(line_number=1))
            effects.reverse()
            return effects
####  2\. ScribeParser #
The `ScribeParser` delegates the parsing of each transcript section to
specific section parsers.
    from ai_scribe.parsers.base import TranscriptParser
    # explained in section 3 below, "Section Parsers"
    class ChiefComplaintParser: ...
    class HistoryOfPresentIllnessParser: ...
    class PastMedicalHistoryParser: ...
    class PlanParser: ...
    class VitalsParser: ...
    class ScribeParser(TranscriptParser):
        """A parser for scribe transcripts."""
        section_parsers = {
            "chief_complaint": ChiefComplaintParser(),
            "history_of_present_illness": HistoryOfPresentIllnessParser(),
            "past_medical_history": PastMedicalHistoryParser(),
            "vitals": VitalsParser(),
            "plan": PlanParser(),
        }
        def parse(self, transcript: str, context: dict) -> dict:
            """Parse the transcript into commands grouped by sections."""
            parsed_sections = {}
            for section, parser in self.section_parsers.items():
                parsed_sections[section] = parser.parse(transcript, context)
            return parsed_sections
####  3\. Section Parsers #
Each section parser extracts relevant information from its section and
produces commands.
    from typing import Any, Sequence
    from ai_scribe.parsers.base import CommandParser, ParsedContent
    from canvas_sdk.commands.commands.plan import PlanCommand
    class PlanParser(CommandParser):
        """Parses the plan section of a transcript."""
        def parse(self, content: ParsedContent, context: Any = None) -> Sequence[PlanCommand]:
            """Parses the plan section of a transcript."""
            return [PlanCommand(narrative=line) for line in content["arguments"]]
##  Extending the Parser #
###  1\. Adding a New Section Parser #
Suppose you want to parse the âAppointmentsâ section into a `TaskCommand`
for follow-up tasks.
####  Define the Parser #
    from typing import Sequence, Any
    from canvas_sdk.commands import TaskCommand
    from ai_scribe.parsers.base import CommandParser, ParsedContent
    class AppointmentsParser(CommandParser):
        """Parses the 'Appointments' section of a transcript."""
        def parse(self, content: ParsedContent, context: Any = None) -> Sequence[TaskCommand]:
            """Parses the Appointments section and generates TaskCommands."""
            tasks = []
            for line in content["arguments"]:
                tasks.append(TaskCommand(title=line))
            return tasks
####  Register the Parser #
Add the `AppointmentsParser` to the `section_parsers` dictionary.
    class AppointmentsParser: ... # defined above
    class ScribeParser:
        """A parser for transcripts."""
        section_parsers = {
            "appointments": AppointmentsParser()
        }
###  2\. Customizing the Entire Parser #
To replace `ScribeParser`, define your custom parser.
    from ai_scribe.parsers.base import (
        ParsedContent,
        TranscriptParser,
        TranscriptParserOutput,
    )
    class CustomParser(TranscriptParser):
        """Custom parser for alternative transcript formats."""
        def parse(self, transcript: str, context: dict) -> dict:
            """Parse the transcript and produce commands."""
            # Implement custom parsing logic
            ...
Replace the parser in the `Protocol` class:
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    class CustomParser: ... # defined above
    class Protocol(BaseProtocol):
        """Protocol using a custom parser."""
        def compute(self) -> list[Effect]:
            transcript = self.context["fields"]["text"]
            parser = CustomParser()  # Use custom parser
            parsed_transcript = parser.parse(transcript, self.context)
            note_uuid = self.context["note"]["uuid"]
            effects = []
            for commands in parsed_transcript.values():
                for command in commands:
                    command.note_uuid = note_uuid
                    effects.append(command.originate(line_number=1))
            effects.reverse()
            return effects
##  Watch the Workflow in Action #
##  Conclusion #
With robust parsing capabilities and extensibility, this example plugin equips
developers to support clinicians in reclaiming their time for what matters
most: patient care. By following the steps in this guide, developers can
ensure seamless integration into clinical workflows, while also tailoring the
tool to suit specific needs.
----- END PAGE https://docs.canvasmedical.com/guides/scribe-ai-parser/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/patient-portal-forms/
# Implementing Patient Portal Forms in Canvas SDK
Last updated: 1 Apr 2025
The Canvas SDK enables custom patient engagement workflows by dynamically
displaying forms (questionnaires) within the Patient Portal. This guide walks
through implementing a plugin that automatically assigns forms based on a
patientâs appointment type and previously completed forms. The patientâs
responses are stored as Interviews, and the developer can choose to generate a
Questionnaire Command within a Note.
##  What youâll learn: #
  * Use the [`FormResult`](/sdk/form-result-effect) effect to display questionnaires dynamically.
  * Fetch patient [appointments](/sdk/data-appointment/) and [interviews](/sdk/data-questionnaire/).
  * Control when forms should be shown or hidden.
  * Optionally create a Questionnaire Command inside a Note.
##  Example #
This example assigns intake questionnaires based on the presence of upcoming
appointments and adds the completed questionnaires to the visit, authored by
the patient.
    from canvas_sdk.effects.patient_portal.form_result import FormResult
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Patient, Appointment, Interview, Note, Questionnaire
    from canvas_sdk.v1.data.appointment import AppointmentProgressStatus
    import arrow
    # 1
    INTAKE_QUESTIONNAIRES = [
      "Insurance Details",
      "Preferred Pharmacy Details",
      "Social History",
    ]
    class Protocol(BaseHandler):
      """Protocol for processing Patient Portal form requests and generating form effects."""
      RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__GET_FORMS)
      def _get_upcoming_appointment_note_id(self, appointments, note_type_names):
        """Retrieve the note_id for the first confirmed future appointment matching given note type names."""
        now = arrow.now().date()
        return appointments.filter(
          status=AppointmentProgressStatus.CONFIRMED,
          start_time__gt=now,
          note_type__name__in=note_type_names
        ).values_list("note__id", flat=True).first()
      def compute(self):
        """Compute and return a list of FormResult effects based on upcoming appointments."""
        # 2
        patient = Patient.objects.get(id=self.target)
        patient_appointments = patient.appointments
        completed_forms = set(
          Interview.objects.filter(
            patient=patient,
            entered_in_error_id__isnull=True,
            questionnaires__name__in=INTAKE_QUESTIONNAIRES
          ).values_list("questionnaires__name", flat=True)
        )
        forms = []
        # Assign Intake Forms for new patients
        if note_id := self._get_upcoming_appointment_note_id(patient_appointments, ["Telehealth", "Office visit"]):
          missing_intake_forms = [qname for qname in INTAKE_QUESTIONNAIRES if qname not in completed_forms]
          missing_intake_questionnaire_ids = Questionnaire.objects.filter(name__in=missing_intake_forms).values_list("id",
                                                                                                                     flat=True)
          #3
          forms = [
            FormResult(questionnaire_id=qid, create_command=True, note_id=note_id).apply()
            for qid in missing_intake_questionnaire_ids
          ]
        return forms
###  How It Works #
  1. **On each Patient Portal page load** , the plugin evaluates which forms to show.
     * The example above defines the questionnaire by name. This is an effective way to leverage the same plugin across instances, as questionnaire IDs will differ. You could also filter based on a prefix so that all questionnaires that start with `Portal_` show.
  2. Forms are automatically assigned based on:
     * **Upcoming Appointments**
     * **Previously completed forms**
  3. If applicable, the response can create a Questionnaire Command inside a Note using the [form result effect](/sdk/form-result-effect/).
  4. The developer is responsible for ensuring that forms do not persist unnecessarily.
##  Adding Form Logic in a Protocol Handler #
We define a **Protocol** that listens for `PATIENT_PORTAL__GET_FORMS` events
and determines which forms need to be displayed.
##  Best Practices #
  * **Prevent Duplicate Forms:** Since this logic runs on every page load, check **existing responses** before assigning new forms.
##  Summary #
  * This plugin **automatically assigns Patient Portal forms** based on upcoming appointments.
  * Forms are created as **Questionnaires** , and responses are stored as **Interviews**.
  * The developer can **optionally** create a **Questionnaire Command** inside a **Note**.
  * **Forms are re-evaluated on each page load** , so plugin developers must ensure they donât persist unnecessarily.
----- END PAGE https://docs.canvasmedical.com/guides/patient-portal-forms/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/improve-hcc-coding-accuracy/
# Improve HCC Coding Accuracy
Last updated: 16 Oct 2025
Different patients present unique challenges, and your tools should adapt to
meet their specific needs.
Hierarchical condition category (HCC) coding is a critical component of value-
based care, especially for organizations serving Medicare Advantage patients.
Accurate risk adjustment ensures patients receive appropriate coverage while
aligning reimbursement with the complexity of their care needs. However,
navigating HCC coding can feel overwhelming with so many diagnoses to
consider, guidelines to follow, and tools to use.
This guide will walk you through practical steps to use HCC codings in Canvas
for more efficient and effective care delivery. Youâll learn how to leverage
our [HCC capture plugin](https://github.com/Medical-Software-
Foundation/canvas/tree/main/extensions/hcc_capture) to do the following:
  * Create coding gaps from external data using the FHIR DetectedIssue endpoint
  * Surface coding gaps as actionable protocol cards
  * Address and resolve codings gaps seamlessly within the clinical workflow through streamlined commands.
  * Annotate ICD-10 codes that are mapped to HCC categories
By surfacing relevant data when and where itâs needed, you can eliminate
unnecessary steps, reduce cognitive load, and keep workflows aligned with
patient needs.
##  Create Coding Gaps via FHIR Detected Issue #
The [DetectedIssue FHIR resource](/api/detectedissue)) can be used to surface
an actual or potential clinical issue with or between one or more active or
proposed clinical actions for a patient; e.g. Drug-drug interaction,
ineffective treatment frequency, procedure-condition conflict, gaps in care,
etc.
A key use case is surfacing potential codings gaps that come from external
sources.
The workflow within Canvas is centered around issues created with the
`DetectedIssue.code` set to `CODINGGAP`. Although we are leveraging it in our
R4 endpoint, `CODINGGAP` was introduced to the value set in R5, and can be
used for surfacing conditions that may be present on historical claims but not
yet diagnosed within the current year, suspect conditions, or condition data
from external sources. The code should be structured as follows:
        "code": {
            "coding": [
                {
                    "system": "https://terminology.hl7.org/CodeSystem/v3-ActCode",
                    "code": "CODINGGAP"
                }
            ]
        },
The ICD-10 code can be added to `DetectedIssue.evidence` attribute.
Validated coding gaps (where `DetectedIssue.status` = `preliminary`) will
appear in the patient summary if the coding gap commands are enabled in your
environment (see more below).
##  Surface New Coding Gaps as Protocol Cards #
Clinical Documentation Improvement (CDI) staff often play a crucial role in
reviewing potential coding gaps, especially those added via the API using
external data.
There is no built in UI feature in Canvas that surfaces coding gaps that have
yet to be reviewed for accuracy by staff members. Instead, We haven chosen to
leverage plugins to allow for customization within your workflow for surfacing
gaps in care. The example protocol below creates a [protocol
card](/sdk/effect-protocol-cards/) when a new DetectedIssue is created for a
coding gap with a `registered` status. It then recommends that a staff member
validates the information before presenting it to a clinician in the summary.
The protocol will surface in each patientâs chart and staff can also
leverage the population page as a work list.
    from canvas_sdk.protocols.clinical_quality_measure import ClinicalQualityMeasure
    from canvas_sdk.events import EventType
    from canvas_sdk.effects.protocol_card import ProtocolCard
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    class SurfaceNonvalidatedCodingGaps(ClinicalQualityMeasure):
        class Meta:
            title = "Validate Coding Gaps"
            identifiers = ["HCCCapturev1"]
            description = "Surfaces registered coding gaps within a protocol card with the recommendation to validate"
            information = "https://canvasmedical.com"
            references = ["Canvas Medical. https://docs.canvasmedical.com/guides/improve-hcc-coding-accuracy/"]
            authors = ["Canvas Medical"]
        RESPONDS_TO = [
            EventType.Name(EventType.DETECTED_ISSUE_CREATED),
            EventType.Name(EventType.DETECTED_ISSUE_UPDATED),
        ]
        def surface_non_validated_coding_gaps(self, patient, nonvalidated_coding_gaps):
            """
            Craft a protocol card with the list of coding gaps and return an add protocol card effect
            """
            card = ProtocolCard(
                patient_id=patient.id,
                key="hcccapturev1",
                title="Coding Gaps",
                narrative="These codings gaps have not been validated.",
                status=ProtocolCard.Status.DUE,
                feedback_enabled=False,
            )
            for coding_gap in nonvalidated_coding_gaps:
                coding_gap_title_strings = []
                for evidence in coding_gap.evidence.all():
                    coding_gap_title_strings.append(f"{evidence.display} ({evidence.code})")
                card.add_recommendation(
                    title="\n".join(coding_gap_title_strings),
                    button="Validate",
                    command="validateCodingGap",
                    context={"detected_issue_id": coding_gap.dbid},
                )
            return [card.apply()]
        def resolve_coding_gaps_protocol_card(self, patient):
            """
            Craft and return a remove protocol card effect
            """
            card = ProtocolCard(
                patient_id=patient.id,
                key="hcccapturev1",
                title="Coding Gaps",
                narrative="There are no non-validated coding gaps for this patient.",
                status=ProtocolCard.Status.SATISFIED,
                feedback_enabled=False,
            )
            return [card.apply()]
        def compute(self) -> list:
            """
            When a new detectedissue is created or updated, reevaluate (create/update/remove) a protocol card based on the associated evidence
            """
            detected_issue_from_the_event = DetectedIssue.objects.get(id=self.target)
            if detected_issue_from_the_event.code != "CODINGGAP":
                # This detected issue has no impact on the protocol card, so we
                # don't need to do any work.
                return []
            patient = detected_issue_from_the_event.patient
            all_of_that_patients_non_validated_detected_issues = patient.detected_issues.filter(status="registered", code="CODINGGAP")
            if all_of_that_patients_non_validated_detected_issues.count() > 0:
                return self.surface_non_validated_coding_gaps(patient, all_of_that_patients_non_validated_detected_issues)
            else:
                return self.resolve_coding_gaps_protocol_card(patient)
##  Use Coding Gap Commands to Update the Patientâs Record #
The API can be leveraged to create coding gaps in various states. There are
also 4 commands for clinicians and staff to manage coding gaps.
  * **Create Coding Gap** serves as a manual way to add coding gaps to the chart. Staff have the ability to create and validate in the same step.
  * **Validate Coding Gap** allows the care team (often CDI Reviewers) to review the external date and confirm that the gap should be surfaced to a clinician.
  * **Assess Coding Gap** allows clinicians to accept or refute the diagnose and choose the appropriate diagnosis to add to the visit.
  * **Defer Coding Gap** allows clinicians to acknowledge the gap and snooze it for a period of time so that they can return to it at a later date. This may be necessary if the patient is unable to provide enough detail or they run out of time during a visit. When recapture rate is an important metric, this allow reporting to reflect an action was taken.
##  Annotate ICD-10 Codes #
Adding an HCC tag as an annotation to ICD-10 is an easy way to increase
awareness for clinicians. The example protocols below leverage a static list
of ICD-codes. You could also reference a file contained within the plugin
pacakge. Depending on which [HCC
model](https://www.cms.gov/medicare/payment/medicare-advantage-rates-
statistics/risk-adjustment) you follow, you can swap out the codes
accordingly.
###  Adding âHCCâ to Command Search Results #
The following protocol leverages [command `POST_SEARCH` lifecycle
events](/sdk/events/#command-lifecycle-events) and adds an `HCC` annotation to
the associated ICD-10 codes within the results for the diagnose, past medical
history, create coding gap, and assess coding gap commands.
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    ICD_CODES = {
        "HCC": {"A0103", "A0104", "A0105", "A021", "A0222", "A0223", "A0224", "A065", "A072", "A202", "ADD_MORE_CODES..."}
    }
    class AnnotateSearchResults(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
            EventType.Name(EventType.CREATE_CODING_GAP__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.ASSESS_CODING_GAP__DIAGNOSE__POST_SEARCH),
        ]
        def compute(self):
            """
            Add HCC code annotation if the HCC code is found in the search results.
            """
            results = self.context.get("results")
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            post_processed_results = []
            for result in self.context["results"]:
                for coding in result.get("extra", {}).get("coding", []):
                    if not coding.get("system") in ("http://hl7.org/fhir/sid/icd-10", "ICD-10"):
                        continue
                    if coding.get("code") in ICD_CODES["HCC"]:
                        if result.get("annotations") is None:
                            result["annotations"] = []
                        result["annotations"].append("HCC")
                        break
                post_processed_results.append(result)
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
###  Adding Annotations to Conditions and Detected Issues #
The following event/effect pairings can be leveraged to add annotations (such
as the `HCC` tag) to conditions and detected issues in the patient summary as
well as on claims using the protocol code below.
  * `CLAIM__CONDITIONS` and `ANNOTATE_CLAIM_CONDITION_RESULTS`
  * `PATIENT_CHART__CONDITIONS` and `ANNOTATE_PATIENT_CHART_CONDITION_RESULTS`
  * `PATIENT_CHART__DETECTED_ISSUES` and `ANNOTATE_PATIENT_CHART_DETECTED_ISSUE_RESULTS`
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    ICD_CODES = {
        "HCC": {
            "A0103", "A0104", "A0105", "A021", "A0222", "A0223", "A0224", "A065", "A072", "A202", "ADD_MORE_CODES...",
        }
    }
    HCC = "HCC"
    class PatientChartConditionAnnotation(BaseProtocol):
        """
        Annotate Conditions in the Patient Chart with an HCC tag
        """
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__CONDITIONS)
        def compute(self):
            """
            Annotate patient summary conditions if they match the provided set of HCC codes
            """
            hcc_codes = ICD_CODES[HCC]
            payload = {}
            for condition in self.context:
                icd10_code = next((coding.get("code") for coding in condition.get("codings", []) if coding.get("system") == "ICD10"), None)
                if not icd10_code:
                    continue
                if icd10_code in hcc_codes:
                    payload[condition["id"]] = [HCC]
            return [Effect(type=EffectType.ANNOTATE_PATIENT_CHART_CONDITION_RESULTS, payload=json.dumps(payload))]
    class ClaimConditionAnnotation(BaseProtocol):
        """
        Annotate Conditions in the Claim modal with an HCC tag
        """
        RESPONDS_TO = [EventType.Name(EventType.CLAIM__CONDITIONS)]
        def compute(self):
            """
            Annotate claim conditions if they match the provided set of HCC codes
            """
            hcc_codes = ICD_CODES[HCC]
            payload = {}
            for condition in self.context:
                icd10_code = next((coding.get("code") for coding in condition.get("codings", []) if coding.get("system") == "ICD10"), None)
                if not icd10_code:
                    continue
                if icd10_code in hcc_codes:
                    payload[condition["id"]] = [HCC]
            return [Effect(type=EffectType.ANNOTATE_CLAIM_CONDITION_RESULTS, payload=json.dumps(payload))]
    class DetectedIssueAnnotation(BaseProtocol):
        """
        Annotate Detected Issues in the Patient Chart with ICD-10 codes from evidence
        """
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__DETECTED_ISSUES)
        def compute(self):
            """
            Annotate patient summary detected issues with their ICD-10 code from evidence
            """
            payload = {}
            for detected_issue in self.context:
                # Get the first ICD-10 code from evidence if available
                evidence_code = None
                if detected_issue.get("evidence"):
                    for evidence in detected_issue["evidence"]:
                        if evidence.get("code"):
                            evidence_code = evidence["code"]
                            break
                if evidence_code:
                    payload[detected_issue["id"]] = [evidence_code]
            return [Effect(type=EffectType.ANNOTATE_PATIENT_CHART_DETECTED_ISSUE_RESULTS, payload=json.dumps(payload))]
##  Watch the Workflow in Action #
##  Conclusion #
By leveraging intuitive tools and streamlined workflows, you can simplify HCC
coding and focus on delivering patient-centered care. This approach ensures
accuracy, efficiency, and confidence in addressing risk adjustment challenges.
----- END PAGE https://docs.canvasmedical.com/guides/improve-hcc-coding-accuracy/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/staying-on-top-of-tasks/
# Staying on Top of Tasks
Last updated: 25 Nov 2024
Many Canvas users work in multiple systems. If you have a system that deals
with tasks that are ultimately completed in Canvas, youâll want to manage
the full task lifecycle from that external system. Using Canvasâ [FHIR
API](/api/) and the [Canvas SDK](/sdk/), you can have your system create tasks
in Canvas, and get notified when your users complete them.
![](/assets/images/guides/staying-on-top-of-tasks/flow.png)
##  Creating Tasks with the FHIR API #
Your system can originate Tasks in Canvas using our FHIR [Task Create
endpoint](/api/task/#create). The id of the task you create can be found in
the `location` response header. It comes back as the FHIR Task Read URL, but
you can parse the id from it. See the example below. Remember, this code is
hitting the Canvas API from _your_ system, not from within Canvas.
    import requests
    import json
    payload = json.dumps({
      "resourceType": "Task",
      "status": "requested",
      "intent": "unknown",
      "description": "Send a thank you card to the office admin team.",
      "requester": {
        "reference": "Practitioner/abc123"
      }
    })
    url = "https://fumage-api-test-clinic.canvasmedical.com/Task"
    headers = {
      'Content-Type': 'application/json',
      'Authorization': 'not-a-real-token'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    # find the id of the task we just created
    task_location = response.headers['location']  # http://fumage-api-test-clinic.canvasmedical.com/Task/b6426693-eb5b-4702-9f90-4728972c7f16
    task_id = task_location.split("/Task/")[1]  # b6426693-eb5b-4702-9f90-4728972c7f16
You can then take that task id and persist it in your application for tracking
its status. While some choose to poll for status changes, a better way to keep
track of the state of a task is by creating a webhook. We can do that with the
Canvas SDK.
##  Creating a Task completion webhook with the Canvas SDK #
Webhook plugins are discussed in more detail in [Creating Webhooks with the
Canvas SDK](/guides/creating-webhooks-with-the-canvas-sdk/).
Implementing webhooks in a plugin gives you ultimate control over the payload
and headers in your request. We use the python
[requests](https://requests.readthedocs.io/en/latest/) library under the hood,
so thereâs an extremely good chance anything you require for your request is
supported.
In this example, we listen for either the `TASK_COMPLETED` or the
`TASK_CLOSED` events, and send an HTTP POST with the id of the task that was
either completed or closed, along with whether it was completed or closed. The
target of the event is the id of the task, so the event comes with all the
information we need here. You can substitute any of the Canvas SDKâs
supported [events](/sdk/events/) to extend this example to other record types.
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.utils import Http
    from logger import log
    class TaskResolutionWebhook(BaseHandler):
        RESPONDS_TO = [
            EventType.Name(EventType.TASK_COMPLETED),
            EventType.Name(EventType.TASK_CLOSED),
        ]
        def compute(self):
            task_disposition = 'closed'
            if self.event.type == EventType.TASK_COMPLETED:
                task_disposition = 'completed'
            url = "https://webhook.site/ee7aed78-b652-4d9e-b858-04465c409d15"
            payload = {
                "task_id": self.target,
                "disposition": task_disposition,
            }
            http = Http()
            response = http.post(url, json=payload)
            if response.ok:
                log.info("Successfully notified API of task update!")
            else:
                log.info("Notification unsuccessful. =[")
            return []
Once installed, the url you specified in the code will receive an HTTP POST
request whenever a user marks a task as completed or closed. Your application
can listen for those requests and update your internal status of that task.
----- END PAGE https://docs.canvasmedical.com/guides/staying-on-top-of-tasks/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/tailoring-the-chart-to-the-patient/
# Tailoring the Chart to the Patient
Last updated: 24 Sep 2025
Different patients have different needs, and your tools should reflect that.
EMRs are able to be used in a wide variety of scenarios. In order to be able
to do just about anything, your EMR is packed to the gills with features and
options. While you might need all of these features for all of your patients,
you almost certainly donât need _every_ feature for _each_ of your patients.
This guide shows a few examples of using a patientâs data to customize their
chart so the EMR features most relevant to them are front-and-center, while
minimizing or hiding what you donât need in the moment. Tailoring the
interface based on the patient in front of you creates a focused environment
for you to deliver care without irrelevant options getting between you and
your patient.
This guide assumes pre-existing knowledge of the Canvas SDK. If you're
starting from scratch, you may want to read and implement [Your First
Plugin](/guides/your-first-plugin/) before working through this exercise.
##  Chart Customizations for Pediatric Patients #
We will make two simple changes to the charting interface when the selected
patient is a child:
  1. Move the Immunization list to the top of the patient summary
  2. Prevent adult-only diagnosis choices from appearing in searches
First, weâll need to initialize a new plugin.
The Canvas CLI gives you a great head start when creating a plugin. Simply run
`canvas init`, and answer the prompt to name your plugin.
    $ canvas init
      [1/1] project_name (My Cool Plugin): Pediatric Patient Chart Customizations
    Project created in /Users/andrew/src/canvas-plugins/pediatric-patient-chart-customizations
This output shows the location of our freshly generated plugin project. In
this directory, youâll see a default class
(`pediatric_patient_chart_customizations/protocols/my_protocol.py`) provided
as a starting point for your code.
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    âââ CANVAS_MANIFEST.json
    âââ README.md
    âââ protocols
        âââ __init__.py
        âââ my_protocol.py
    2 directories, 4 files
You can use this file as a starting point, or you can start fresh with a new
file. At minimum, I recommend renaming `my_protocol.py` to something more
descriptive, and youâll need to update the references to the file in
`CANVAS_MANIFEST.json` as well.
###  Move Immunizations to the Top of the Patient Summary #
Iâve created a new file, `protocols/pediatric_chart_layout.py`, and Iâve
updated my `CANVAS_MANIFEST.json` to reflect it.
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    âââ CANVAS_MANIFEST.json
    âââ README.md
    âââ protocols
        âââ __init__.py
        âââ pediatric_chart_layout.py
    2 directories, 4 files
Here is a pretty empty class with some comments that will guide our
development:
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            # Look up the patient whose chart is being loaded right now
            # See if the patient is younger than 18 years old
            # If they are not younger than 18, do nothing
            # If they are younger than 18, re-arrange the layout of their summary
            # sections to put immunizations at the top.
            # BaseHandler subclasses must return a list, but it can be empty. It
            # is empty here since we aren't doing anything just yet.
            return []
Pretty straightforward logic. Do nothing or do something based on their age.
####  Looking Up the Patient #
In order to determine if we are on a pediatric chart, weâll need to know the
patient and their birth date. We can use the [Patient class](/sdk/data-
patient/) in the [Data Module](/sdk/data/) for this.
The `PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event is accompanied by the
id of the patient whose chart is being loaded. You can find it using
`self.target`. The patient is the target of the event.
    import arrow
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.patient import Patient
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            eighteen_years_ago = arrow.now().shift(years=-18).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=self.target, birth_date__gt=eighteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the layout.
            if not patient_is_pediatric:
                return []
            # TODO: Alter the layout
            return []
In the code above, youâll see I didnât actually retrieve the patientâs
information. Since I donât plan to use any of the data from the patient
record, I instead let the database answer the question: âDoes the patient
with this id have a birth date more recent than 18 years ago?â This is a
performance optimization. The less data transmitted, the faster your plugins
execute, and the faster your charts load. This is not strictly necessary, but
over time and with enough plugins installed the inefficiencies could add up.
If youâd like you could alternately retrieve the patient and make a direct
comparison to their `birth_date` attribute.
####  Altering the Layout #
When loading the patientâs summary, the front-end consults a list of
sections to retrieve data for and render. Our plugin influences this list, and
it does so using the
[`PatientChartSummaryConfiguration`](https://github.com/canvas-medical/canvas-
plugins/blob/main/canvas_sdk/effects/patient_chart_summary_configuration.py)
effect. Using the list of possible sections, we construct the ordered list of
sections we want to see. In this example weâre just moving one to the top,
but you could also omit sections to hide them entirely if there are sections
you do not use or need for your [Care
Model](https://www.canvasmedical.com/articles/care-modeling-the-secret-to-
success-in-care-delivery).
    import arrow
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    from canvas_sdk.v1.data.patient import Patient
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            eighteen_years_ago = arrow.now().shift(years=-18).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=self.target, birth_date__gt=eighteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the layout.
            if not patient_is_pediatric:
                return []
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.IMMUNIZATIONS,
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.GOALS,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.CARE_TEAMS,
              PatientChartSummaryConfiguration.Section.VITALS,
              PatientChartSummaryConfiguration.Section.SURGICAL_HISTORY,
              PatientChartSummaryConfiguration.Section.FAMILY_HISTORY,
            ])
            return [layout.apply()]
Once installed, pediatric patients will have their immunization section at the
top of their summary, while adult patients will continue to have social
determinants as their initial section.
###  Prevent adult-only diagnosis choices from appearing in searches #
Some diagnosis codes are restricted to adult patients. CMS provides a
[list](https://www.cms.gov/Medicare/Coding/OutpatientCodeEdit/Downloads/ICD-10-IOCE-
Code-Lists.pdf) of these âAdult Diagnosesâ. We can reference this list and
filter them out of the diagnosis search results for pediatric patients. This
increases the quality of your search and makes it easier for you to find the
right choice.
Iâve created a new file, `protocols/pediatric_condition_search.py`, and
Iâve updated my `CANVAS_MANIFEST.json` to reflect it.
Hereâs the updated plugin file structure:
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    âââ CANVAS_MANIFEST.json
    âââ README.md
    âââ protocols
        âââ __init__.py
        âââ pediatric_chart_layout.py
        âââ pediatric_condition_search.py
    2 directories, 5 files
And hereâs the updated `CANVAS_MANIFEST.json`:
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "pediatric_patient_chart_customizations",
        "description": "Customizations for pediatric patients",
        "components": {
            "protocols": [
                {
                    "class": "pediatric_patient_chart_customizations.protocols.pediatric_chart_layout:PediatricChartLayout",
                    "description": "Moves the immunization section to the top of the patient summary on pediatric charts.",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                },
                {
                    "class": "pediatric_patient_chart_customizations.protocols.pediatric_condition_search:PediatricConditionSearch",
                    "description": "Filters the condition search to eliminate adult-only conditions on pediatric charts.",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
And hereâs the very basic outline weâll start out with:
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            # This event's target is the command we are searching within. Look up
            # the patient id from the command, and use that to look up the patient.
            # If the patient is not pediatric, do not alter the search.
            # If the patient is pediatric, loop through the search results, and
            # compare the codings of the options with our list of adult-only
            # diagnosis codes. If it's an adult only code, remove it from the
            # list.
            return []
Using the list provided by CMS, we can create a set of ICD-10 codes that
should be restricted to adults. According to CMS, these diagnoses are only
relevant to patients 15 or older.
While the layout altering class responded to a single event, weâre listening
for two different events here: diagnose command search and past medical
history command search. Both of these commands include a diagnosis code search
box, so weâll want to affect both. We wouldnât want to impact a family
history command diagnosis search, since the family members recorded there are
often adults.
####  Looking Up the Patient #
In the previous example, the target of the
`PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event was the patient. For the
events weâre responding to here, the target is the [command](/sdk/data-
command/) that the search is occurring within. In order to determine if the
patient is young enough for our code to be invoked, weâll first look up the
patientâs id from the command, then assess their age in a similar manner as
before.
    import arrow
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            # This event's target is the command we are searching within. Look up
            # the patient id from the command.
            patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
            fifteen_years_ago = arrow.now().shift(years=-15).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=patient_id, birth_date__gt=fifteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the search.
            # If the patient is pediatric, loop through the search results, and
            # compare the codings of the options with our list of adult-only
            # diagnosis codes. If it's an adult only code, remove it from the
            # list.
            return []
Once again you see some code that optimizes for performance over readability.
If youâre not familiar with the Django ORM, this code:
    patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
Is equivalent to this code, which you may find more readable:
    command = Command.objects.get(id=self.target)
    patient_id = command.patient.id
However you get to the patientâs id is up to you. Once you have it, the code
is nearly identical to the previous example, the only difference being the age
weâre targeting. We are asking the database âDoes the patient with this id
have a birth date more recent than 15 years ago?â
####  Altering the Layout #
Now that we know when we should act, we need to write the code for filtering
the list of search results. When the search is performed, the raw results are
sent to our code before being ultimately delivered to the dropdown box in the
front-end. We have the opportunity to modify that list before it hits the
dropdown. While weâre focused on removing irrelevant choices, you could also
add labels to certain ones you wish to highlight or alter the search order to
guide users to preferred options.
Our code loops through the ICD-10 codes associated with the search results,
checks for their presence in the set of adult ICD-10 codes, and only includes
them in the post-processed set if they are not in the adult code list. The raw
search results are in the eventâs context object under the `results` key.
Hereâs the full code:
    import json
    import arrow
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            results = self.context.get("results")
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            # This event's target is the command we are searching within. Look up
            # the patient id from the command.
            patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
            fifteen_years_ago = arrow.now().shift(years=-15).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=patient_id, birth_date__gt=fifteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the search.
            if not patient_is_pediatric:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            # Create our container for modified search results
            post_processed_results = []
            # Loop through the ICD 10 codes associated with the results
            for result in self.context["results"]:
                for coding in result.get("extra", {}).get("coding", []):
                    if not coding.get("system") in ("http://hl7.org/fhir/sid/icd-10", "ICD-10"):
                        continue
                    # If the ICD 10 code is not in the list of Adult-only codes,
                    # we can add this result to what will ultimately be returned.
                    if coding.get("code") not in ADULT_ONLY_ICD_CODES:
                        post_processed_results.append(result)
                        break
            # Return our modified search results
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
Once installed, certain diagnosis codes will not clutter up search results in
commands for pediatric patients, but will continue to show as expected for
patients over the age of 15.
##  Watch the Workflow in Action #
View and deploy the Pediatric Patient Chart Customization Extension
[here](https://www.canvasmedical.com/extensions/pediatric-patient-chart-
customizations).
##  Conclusion #
Age is one differentiator that changes the relevance of EMR features, but
there are many, many others. Using the Canvas SDK can help keep clinicians
focused, with the features they need front-and-center and the ones they
donât need out of the way.
----- END PAGE https://docs.canvasmedical.com/guides/tailoring-the-chart-to-the-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/growth-charts/
# Visualizing Data Within the Canvas Chart
Last updated: 24 Sep 2025
The Canvas SDK gives you access to real-time patient data and allows you to
create custom UIs accessible from a patientâs chart. The combination of
these capabilities allows you to create rich, interactive data visualizations
your clinicians can access directly in the charting interface. This example
will show you how weâve used this approach to implement a pediatric growth
charts feature.
##  In this guide you will learn how to: #
  * Use the [`ActionButton`](/sdk/handlers-action-buttons) handler to provide a button, specify its location, and define its action in the UI.
  * Use the [`LaunchModalEffect`](/sdk/layout-effect/#modals) to display your custom visualization.
  * Fetch patient [observations](/sdk/data-observation/), such as height and weight, from the [data module](/sdk/data/).
  * Use the patient observation data within an HTML template.
  * Combine all of the above to surface a pediatric growth chart visualization right in the chart.
##  Growth Charts #
Growth charts are percentile curves showing the distribution of selected body
measurements in children. A growth chart shows how a childâs height, weight,
and head circumference (for infants) compare to other children of the same age
and sex. It helps track a childâs growth over time and can indicate whether
they are growing at an expected rate. Growth charts are commonly used by
doctors to monitor development and identify potential health concerns. In this
guide we will use charts from the [Center for Disease Control and Prevention
(CDC)](https://www.cdc.gov/growthcharts/who-data-files.htm) to demonstrate how
you can create your own.
The complete plugin is open-source and can be found in the [Medical Software
Foundation GitHub repo](https://github.com/Medical-Software-
Foundation/canvas/tree/main/extensions/growth_charts/).
The plugin adds a button on the Vital Signs section of the patient chart that,
when clicked, launches a modal displaying the patientâs height, weight, and
head circumference measurements graphed against various percentile curves.
![vitals action button](/assets/images/vitals-action-button.png)
![chart template](/assets/images/growth-charts.png)
In the following steps, weâll show you how we used the Canvas SDK to create
it.
##  Adding a button #
To add a button to the vital signs section, youâll implement an
[`ActionButton`](/sdk/handlers-action-buttons) handler. In your handler class,
youâll set the `BUTTON_LOCATION` constant to
`ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION` to make the action
button appear in the corresponding summary section of the chart.
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.effects import Effect
    class GenerateVitalsGraphs(ActionButton):
        BUTTON_TITLE = "Growth Charts"
        BUTTON_KEY = "show_growth_charts"
        BUTTON_LOCATION = ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION
        def handle(self) -> list[Effect]:
            # This method is invoked when the button is clicked.
            pass
##  Launching a modal when the button is clicked #
Now that you have your button showing in the chart section, you can launch a
modal when itâs clicked using the [`LaunchModalEffect`](/sdk/layout-
effect/#modals)
In this guide, we are launching a modal, but this click action can result in
any [effect](/sdk/effects/) your handling code returns.
Hereâs an example of a simple plugin using the `LaunchModalEffect` to
display a âHello Worldâ message.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.templates import render_to_string
    class HelloWorld(ActionButton):
        BUTTON_TITLE = "Hello World"
        BUTTON_KEY = "show_hello_world"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_HEADER
        def handle(self) -> list[Effect]:
            launch_modal = LaunchModalEffect(content=render_to_string("protocols/hello-world.html", { "title": "hello world" }))
            return [launch_modal.apply()]
And hereâs the result!
![action button](/assets/images/action-button-hello-world.png)
![hello world](/assets/images/template-hello-world.png)
##  Using HTML templates in the modal #
The use of templates allows us to render any kind of information from the data
we have. We can even import external libraries from CDNs and add CSS styles to
customize and enhance our modal.
To draw our graphs we use d3js, a free, open-source JavaScript library for
visualizing data. How to use d3js is outside the scope of this guide, but you
can find great documentation and tutorials on the d3 website
[here](https://d3js.org/getting-started)
Hereâs an example of a template file name `hello-world.html` that receives a
variable called title, which will be used inside the template.
    <!DOCTYPE html>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 30px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <html lang="en">
        <h1 id="main"></h1>
    </html>
    <script>
        const div = document.getElementById('main');
        div.textContent = ``;
    </script>
##  Fetching the observations #
To retrieve the patient data we use the [Data Module](/sdk/data/).
Specifically, the [`Observation`](/sdk/data-observation/) model.
Here, we can use `self.target`, which is the patientâs `id`, to retrieve the
patient and their observations by filtering for the values we need â such as
weight, height, etc.
    from canvas_sdk.effects import Effect
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.v1.data.patient import Patient
    def handle(self) -> list[Effect]:
        patient = Patient.objects.get(id=self.target)
        sex_at_birth = patient.sex_at_birth
        birth_date = patient.birth_date
        observation_weight = Observation.objects.for_patient(self.target).filter(name="weight")
        observation_length = Observation.objects.for_patient(self.target).filter(name="length")
        observation_bmi = Observation.objects.for_patient(self.target).filter(name="bmi")
        observation_head_circumference = Observation.objects.for_patient(self.target).filter(name="head_circumference")
##  Tying it all together #
We now know:
  1. How to put a button in the chart
  2. How to launch a modal when that button is clicked
  3. How to create an HTML template to render within that modal
  4. How to retrieve data to use within that HTML template
All thatâs left is combining these actions into a useful data visualization
for our clinical users.
You can see our HTML template [here](https://github.com/Medical-Software-
Foundation/canvas/blob/main/extensions/growth_charts/templates/chart.html),
which draws many charts based on the observations provided and the percentile
curve data provided by the CDC. To make that percentile data usable in our
template, we transformed the Excel files from the CDC website into structured
data we could use programatically. You can find those python representations
of the percentile data [here](https://github.com/Medical-Software-
Foundation/canvas/tree/main/extensions/growth_charts/graphs).
Hereâs an excerpt:
    who_boys_length_age = [
        { "x": 0, "y": 46.77032, "z": "5th" },
        { "x": 1, "y": 51.52262, "z": "5th" },
        { "x": 2, "y": 55.13442, "z": "5th" },
        ...,
        { "x": 23, "y": 92.93123, "z": "98th" },
        { "x": 24, "y": 93.92634, "z": "98th" }
    ]
In addition to the percentile data series, we of course need to plot the
patient observation data series. To do this, we create a lists of x and y
values corresponding to the patientâs age and measurements. You can see this
in more detail in the [GitHub repo](https://github.com/Medical-Software-
Foundation/canvas/blob/5e8a3dfdb18307e596d2da2d9fce33a3e379cd11/extensions/growth_charts/protocols/growth_charts.py#L80),
but hereâs an excerpt:
    import arrow
    import datetime
    from canvas_sdk.effects import Effect
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.v1.data.patient import Patient
    def convert_oz_to_kg(oz: str) -> float:
        return float(oz) * 0.0283495
    def get_age_in_months(birth_date: datetime.date, date: datetime.date = datetime.datetime.now()) -> int:
        now = arrow.get(date)
        date = arrow.get(birth_date)
        year_difference = now.year - date.year
        month_difference = now.month - date.month
        return year_difference * 12 + month_difference
    def handle(self) -> list[Effect]:
        graphs = []
        patient = Patient.objects.get(id=self.target)
        sex_at_birth = patient.sex_at_birth
        birth_date = patient.birth_date
        age_in_months = get_age_in_months(birth_date)
        is_less_than_24_months_old = age_in_months < 24
        is_less_than_36_months_old = age_in_months < 36
        observation_weight = Observation.objects.for_patient(self.target).filter(name="weight")
        observation_height = Observation.objects.for_patient(self.target).filter(name="height")
        observation_length = Observation.objects.for_patient(self.target).filter(name="length")
        observation_bmi = Observation.objects.for_patient(self.target).filter(name="bmi")
        observation_head_circumference = Observation.objects.for_patient(self.target).filter(name="head_circumference")
        weight_for_age = {}
        length_for_age = {}
        weight_for_length = {}
        head_for_age = {}
        bmi_for_age = {}
        for obs in observation_weight:
            if obs.value:
                note = Note.objects.get(dbid=obs.note_id)
                age_in_months = get_age_in_months(birth_date, note.datetime_of_service)
                weight_in_kg = convert_oz_to_kg(obs.value)
                weight_for_age[age_in_months] = weight_in_kg
        # ... repeat for other data series
Finally, we create a list of graphs with the necessary variables and data,
which are passed to the template to generate and render the graph.
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.templates import render_to_string
    who_boys_length_age = ... # from growth_charts.graphs.who_boys_length_age
    class Protocol(BaseHandler):
        def compute(self):
            # list of graphs
            length_for_age = {} # filled in the actual implementation, see linked GitHub repository
            graphs = [
                {
                    "data": who_boys_length_age, # the data from the graph file
                    "title": 'Length for age (Boys 0 - 2 years)', # graph title
                    "xType": 'Generic', # the type of x axis (Generic, Length, Weight) - We need this info to convert the values
                    "yType": 'Length', # the type of y axis (Generic, Length, Weight)
                    "xLabel": 'Age', # label for the x axis
                    "yLabel": 'Length', # label for the y axis
                    "zLabel": 'Percentile', # label for the z axis
                    "layerData": length_for_age, # the patientâs data that will be plotted on the graph
                    "tab": "WHO" # the section where the graph should be rendered (WHO or CDC)
                },
                # ...repeat for other data series
            ]
            launch_modal = LaunchModalEffect(
                content=render_to_string("templates/chart.html", {"graphs": graphs}),
            )
            return [launch_modal.apply()]
![chart template](/assets/images/growth-charts.png)
By combining action buttons, the data module, and the `LaunchModalEffect`, you
can create unique visualizations to help contextualize patient data for your
clinical users.
----- END PAGE https://docs.canvasmedical.com/guides/growth-charts/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/your-first-application/
# Your First Application
Last updated: 24 Jul 2025
This guide will walk you through the process of installing, initializing, and
customizing embeddable applications in Canvas.
##  What Are Applications in Canvas? #
Applications in Canvas are embeddable plugins that enhance the functionality
of the Canvas platform. They allow developers to create custom features
accessible directly from within the Canvas interface, such as interactive
tools, data visualizations, or workflow integrations. These applications can
be configured to appear globally or within specific contexts, such as the
patient chart page.
##  Step 1: Install and Configure the Canvas CLI #
Follow the instructions in the [Canvas
documentation](https://docs.canvasmedical.com/guides/your-first-
plugin/#1-install-the-canvas-cli) to install and configure the Canvas CLI.
Once complete, ensure that you can successfully run `canvas` commands from
your terminal.
##  Step 2: Initialize an Application #
To create a new application, run the following command:
    canvas init application
This will generate a boilerplate application along with a
`CANVAS_MANIFEST.json` file.
##  Step 3: Understanding the `CANVAS_MANIFEST.json` File #
The `CANVAS_MANIFEST.json` file describes your application and its components.
Below is an example of a manifest and a description of the customizable
properties:
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "my_cool_application",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "url_permissions": [
            {
                "url": "https://my-application.com",
                "permissions": []
            }
        ],
        "components": {
            "applications": [
                {
                    "class": "my_cool_application.applications.my_application:MyApplication",
                    "name": "My Application",
                    "description": "An Application that does xyz...",
                    "scope": "global",
                    "icon": "assets/python-logo.png",
                    "menu_position": "top",
                    "menu_order": "100",
                    "show_in_panel": false,
                    "panel_priority": 100
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
###  Customizable Properties #
  1. **name** : The display name of the application.
  2. **description** : A brief description of the application.
  3. **icon** : The icon for the application. This can be a URL to an image or a path inside the plugin package.
  4. **scope** :
     * `global`: The app will appear across all contexts.
     * `patient_specific`: The app will appear only in the patient chart page.
     * `provider_menu_item`: The app button will be displayed on the providerâs menu.
     * `portal_menu_item`: The app button will be displayed on the patient portal menu.
  5. **url_permissions** : The allowed urls and permissions for the application. This is used for security purposes. For more info check the [Application Handler](/sdk/
handlers-applications).
  6. **menu_position** : Determines where the menu item will be placed within the menu (this configuration applies only to the providers menu)
     * `top`: The item will be placed on the top section.
     * `bottom`: The item will be placed in the bottom section - this section should display items that open in a new window.
  7. **menu_order** : How the items will be ordered in the menu. e.g 100, 200
  8. **show_in_panel** : If you want to increase your applicationâs visibility and display it alongside other panel buttons (instead of in the applications drawer), you can set this attribute
  9. **panel_priority** : How the applications will be ordered in the panel section. e.g 100, 200
##  Step 4: Overriding the Application Behavior #
Developers must extend the `Application` class and override the `on_open`
method to define the behavior when the app icon is clicked. Below is an
example implementation:
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class MyApplication(Application):
        """An embeddable application that can be registered to Canvas."""
        def on_open(self) -> Effect:
            """Handle the on_open event."""
            # Implement this method to handle the application on_open event.
            return LaunchModalEffect(
                url="http://localhost:8000",
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL
            ).apply()
###  Key Details #
  * **`on_open` Method**:
    * Called when the user clicks on the app icon.
    * Should return a `LaunchModalEffect` that specifies:
      * **url** : The URL to open.
      * **target** : The display target.
###  Target Options #
  * `DEFAULT_MODAL`: Opens the URL in a modal centered on the screen.
  * `NEW_WINDOW`: Opens the URL in a new browser window.
  * `PAGE`: Opens the URL as a page in the app
  * `RIGHT_CHART_PANE`: Opens the URL in the right-hand pane of the patient chart.
  * `RIGHT_CHART_PANE_LARGE`: Opens the URL in an enlarged right-hand pane of the patient chart.
##  Step 5: Installing the Application #
To install your application, run:
    canvas install <path/to/application>
----- END PAGE https://docs.canvasmedical.com/guides/your-first-application/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/profile-additional-fields/
# How to add additional profile fields
Last updated: 24 Sep 2025
This guide explains how to create additional fields that will appear on the
patient profile demographics form. With this, you can define custom fields,
and the information will be stored as patient metadata.
##  What youâll learn: #
  * Use the [`PatientMetadataCreateForm`](/sdk/patient-metadata-create-form-effect) effect to display additional fields on the patient profile.
  * Use the [`FormField`](/sdk/patient-metadata-create-form-effect/#formfield) class to create fields
##  Patient Metadata Create form plugin #
####  1\. FormField #
To create the form, we need to specify which items will be included. For this,
we use the [`FormField`](/sdk/patient-metadata-create-form-effect/#formfield)
class, where we can define our inputs and their attributes.
    from canvas_sdk.effects.patient_metadata import InputType, FormField
    FormField(
        key='musicGenre',
        label='Preferred music genre',
        type=InputType.TEXT,
        required=False,
        editable=True,
    )
####  2\. PatientMetadataCreateFormEffect #
The next step is to add these fields to the effect so they can be used to
build the form.
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    PatientMetadataCreateFormEffect(form_fields=[
        FormField(
            key='musicGenre',
            label='Preferred music genre',
            type=InputType.TEXT,
            required=False,
            editable=True,
        ),
        ...,
    ])
####  3\. The plugin #
Hereâs an example of a complete plugin showcasing the different input types.
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    # Inherit from BaseHandler to properly get registered for events
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_METADATA__GET_ADDITIONAL_FIELDS)
        def compute(self) -> list[Effect]:
            form = PatientMetadataCreateFormEffect(form_fields=[
                FormField(
                    key='musicGenre',
                    label='Preferred music genre',
                    type=InputType.TEXT,
                    required=False,
                    editable=True,
                ),
                FormField(
                    key='occupation',
                    label='Occupation',
                    type=InputType.SELECT,
                    required=False,
                    editable=True,
                    options=["Engineer", "Teacher", "Other"]
                ),
                FormField(
                    key='date',
                    label='Date',
                    type=InputType.DATE,
                    required=False,
                    editable=True,
                ),
            ])
            return [form.apply()]
####  4\. The Output #
And thatâs it! Below, you can see how it will appear in the app â these
fields will be stored as patient metadata.
![medication widget](/assets/images/additional-fields.png)
----- END PAGE https://docs.canvasmedical.com/guides/profile-additional-fields/


